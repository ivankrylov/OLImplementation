<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1998, 2014, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // FORMS.CPP - Definitions for ADL Parser Forms Classes
  26 #include "adlc.hpp"
  27 
  28 //==============================Instructions===================================
  29 //------------------------------InstructForm-----------------------------------
  30 InstructForm::InstructForm(const char *id, bool ideal_only)
  31   : _ident(id), _ideal_only(ideal_only),
  32     _localNames(cmpstr, hashstr, Form::arena),
  33     _effects(cmpstr, hashstr, Form::arena),
  34     _is_mach_constant(false),
  35     _needs_constant_base(false),
  36     _has_call(false)
  37 {
  38       _ftype = Form::INS;
  39 
  40       _matrule              = NULL;
  41       _insencode            = NULL;
  42       _constant             = NULL;
  43       _is_postalloc_expand  = false;
  44       _opcode               = NULL;
  45       _size                 = NULL;
  46       _attribs              = NULL;
  47       _predicate            = NULL;
  48       _exprule              = NULL;
  49       _rewrule              = NULL;
  50       _format               = NULL;
  51       _peephole             = NULL;
  52       _ins_pipe             = NULL;
  53       _uniq_idx             = NULL;
  54       _num_uniq             = 0;
  55       _cisc_spill_operand   = Not_cisc_spillable;// Which operand may cisc-spill
  56       _cisc_spill_alternate = NULL;            // possible cisc replacement
  57       _cisc_reg_mask_name   = NULL;
  58       _is_cisc_alternate    = false;
  59       _is_short_branch      = false;
  60       _short_branch_form    = NULL;
  61       _alignment            = 1;
  62 }
  63 
  64 InstructForm::InstructForm(const char *id, InstructForm *instr, MatchRule *rule)
  65   : _ident(id), _ideal_only(false),
  66     _localNames(instr-&gt;_localNames),
  67     _effects(instr-&gt;_effects),
  68     _is_mach_constant(false),
  69     _needs_constant_base(false),
  70     _has_call(false)
  71 {
  72       _ftype = Form::INS;
  73 
  74       _matrule               = rule;
  75       _insencode             = instr-&gt;_insencode;
  76       _constant              = instr-&gt;_constant;
  77       _is_postalloc_expand   = instr-&gt;_is_postalloc_expand;
  78       _opcode                = instr-&gt;_opcode;
  79       _size                  = instr-&gt;_size;
  80       _attribs               = instr-&gt;_attribs;
  81       _predicate             = instr-&gt;_predicate;
  82       _exprule               = instr-&gt;_exprule;
  83       _rewrule               = instr-&gt;_rewrule;
  84       _format                = instr-&gt;_format;
  85       _peephole              = instr-&gt;_peephole;
  86       _ins_pipe              = instr-&gt;_ins_pipe;
  87       _uniq_idx              = instr-&gt;_uniq_idx;
  88       _num_uniq              = instr-&gt;_num_uniq;
  89       _cisc_spill_operand    = Not_cisc_spillable; // Which operand may cisc-spill
  90       _cisc_spill_alternate  = NULL;               // possible cisc replacement
  91       _cisc_reg_mask_name    = NULL;
  92       _is_cisc_alternate     = false;
  93       _is_short_branch       = false;
  94       _short_branch_form     = NULL;
  95       _alignment             = 1;
  96      // Copy parameters
  97      const char *name;
  98      instr-&gt;_parameters.reset();
  99      for (; (name = instr-&gt;_parameters.iter()) != NULL;)
 100        _parameters.addName(name);
 101 }
 102 
 103 InstructForm::~InstructForm() {
 104 }
 105 
 106 InstructForm *InstructForm::is_instruction() const {
 107   return (InstructForm*)this;
 108 }
 109 
 110 bool InstructForm::ideal_only() const {
 111   return _ideal_only;
 112 }
 113 
 114 bool InstructForm::sets_result() const {
 115   return (_matrule != NULL &amp;&amp; _matrule-&gt;sets_result());
 116 }
 117 
 118 bool InstructForm::needs_projections() {
 119   _components.reset();
 120   for( Component *comp; (comp = _components.iter()) != NULL; ) {
 121     if (comp-&gt;isa(Component::KILL)) {
 122       return true;
 123     }
 124   }
 125   return false;
 126 }
 127 
 128 
 129 bool InstructForm::has_temps() {
 130   if (_matrule) {
 131     // Examine each component to see if it is a TEMP
 132     _components.reset();
 133     // Skip the first component, if already handled as (SET dst (...))
 134     Component *comp = NULL;
 135     if (sets_result())  comp = _components.iter();
 136     while ((comp = _components.iter()) != NULL) {
 137       if (comp-&gt;isa(Component::TEMP)) {
 138         return true;
 139       }
 140     }
 141   }
 142 
 143   return false;
 144 }
 145 
 146 uint InstructForm::num_defs_or_kills() {
 147   uint   defs_or_kills = 0;
 148 
 149   _components.reset();
 150   for( Component *comp; (comp = _components.iter()) != NULL; ) {
 151     if( comp-&gt;isa(Component::DEF) || comp-&gt;isa(Component::KILL) ) {
 152       ++defs_or_kills;
 153     }
 154   }
 155 
 156   return  defs_or_kills;
 157 }
 158 
 159 // This instruction has an expand rule?
 160 bool InstructForm::expands() const {
 161   return ( _exprule != NULL );
 162 }
 163 
 164 // This instruction has a late expand rule?
 165 bool InstructForm::postalloc_expands() const {
 166   return _is_postalloc_expand;
 167 }
 168 
 169 // This instruction has a peephole rule?
 170 Peephole *InstructForm::peepholes() const {
 171   return _peephole;
 172 }
 173 
 174 // This instruction has a peephole rule?
 175 void InstructForm::append_peephole(Peephole *peephole) {
 176   if( _peephole == NULL ) {
 177     _peephole = peephole;
 178   } else {
 179     _peephole-&gt;append_peephole(peephole);
 180   }
 181 }
 182 
 183 
 184 // ideal opcode enumeration
 185 const char *InstructForm::ideal_Opcode( FormDict &amp;globalNames )  const {
 186   if( !_matrule ) return "Node"; // Something weird
 187   // Chain rules do not really have ideal Opcodes; use their source
 188   // operand ideal Opcode instead.
 189   if( is_simple_chain_rule(globalNames) ) {
 190     const char *src = _matrule-&gt;_rChild-&gt;_opType;
 191     OperandForm *src_op = globalNames[src]-&gt;is_operand();
 192     assert( src_op, "Not operand class of chain rule" );
 193     if( !src_op-&gt;_matrule ) return "Node";
 194     return src_op-&gt;_matrule-&gt;_opType;
 195   }
 196   // Operand chain rules do not really have ideal Opcodes
 197   if( _matrule-&gt;is_chain_rule(globalNames) )
 198     return "Node";
 199   return strcmp(_matrule-&gt;_opType,"Set")
 200     ? _matrule-&gt;_opType
 201     : _matrule-&gt;_rChild-&gt;_opType;
 202 }
 203 
 204 // Recursive check on all operands' match rules in my match rule
 205 bool InstructForm::is_pinned(FormDict &amp;globals) {
 206   if ( ! _matrule)  return false;
 207 
 208   int  index   = 0;
 209   if (_matrule-&gt;find_type("Goto",          index)) return true;
 210   if (_matrule-&gt;find_type("If",            index)) return true;
 211   if (_matrule-&gt;find_type("CountedLoopEnd",index)) return true;
 212   if (_matrule-&gt;find_type("Return",        index)) return true;
 213   if (_matrule-&gt;find_type("Rethrow",       index)) return true;
 214   if (_matrule-&gt;find_type("TailCall",      index)) return true;
 215   if (_matrule-&gt;find_type("TailJump",      index)) return true;
 216   if (_matrule-&gt;find_type("Halt",          index)) return true;
 217   if (_matrule-&gt;find_type("Jump",          index)) return true;
 218 
 219   return is_parm(globals);
 220 }
 221 
 222 // Recursive check on all operands' match rules in my match rule
 223 bool InstructForm::is_projection(FormDict &amp;globals) {
 224   if ( ! _matrule)  return false;
 225 
 226   int  index   = 0;
 227   if (_matrule-&gt;find_type("Goto",    index)) return true;
 228   if (_matrule-&gt;find_type("Return",  index)) return true;
 229   if (_matrule-&gt;find_type("Rethrow", index)) return true;
 230   if (_matrule-&gt;find_type("TailCall",index)) return true;
 231   if (_matrule-&gt;find_type("TailJump",index)) return true;
 232   if (_matrule-&gt;find_type("Halt",    index)) return true;
 233 
 234   return false;
 235 }
 236 
 237 // Recursive check on all operands' match rules in my match rule
 238 bool InstructForm::is_parm(FormDict &amp;globals) {
 239   if ( ! _matrule)  return false;
 240 
 241   int  index   = 0;
 242   if (_matrule-&gt;find_type("Parm",index)) return true;
 243 
 244   return false;
 245 }
 246 
 247 bool InstructForm::is_ideal_negD() const {
 248   return (_matrule &amp;&amp; _matrule-&gt;_rChild &amp;&amp; strcmp(_matrule-&gt;_rChild-&gt;_opType, "NegD") == 0);
 249 }
 250 
 251 // Return 'true' if this instruction matches an ideal 'Copy*' node
 252 int InstructForm::is_ideal_copy() const {
 253   return _matrule ? _matrule-&gt;is_ideal_copy() : 0;
 254 }
 255 
 256 // Return 'true' if this instruction is too complex to rematerialize.
 257 int InstructForm::is_expensive() const {
 258   // We can prove it is cheap if it has an empty encoding.
 259   // This helps with platform-specific nops like ThreadLocal and RoundFloat.
 260   if (is_empty_encoding())
 261     return 0;
 262 
 263   if (is_tls_instruction())
 264     return 1;
 265 
 266   if (_matrule == NULL)  return 0;
 267 
 268   return _matrule-&gt;is_expensive();
 269 }
 270 
 271 // Has an empty encoding if _size is a constant zero or there
 272 // are no ins_encode tokens.
 273 int InstructForm::is_empty_encoding() const {
 274   if (_insencode != NULL) {
 275     _insencode-&gt;reset();
 276     if (_insencode-&gt;encode_class_iter() == NULL) {
 277       return 1;
 278     }
 279   }
 280   if (_size != NULL &amp;&amp; strcmp(_size, "0") == 0) {
 281     return 1;
 282   }
 283   return 0;
 284 }
 285 
 286 int InstructForm::is_tls_instruction() const {
 287   if (_ident != NULL &amp;&amp;
 288       ( ! strcmp( _ident,"tlsLoadP") ||
 289         ! strncmp(_ident,"tlsLoadP_",9)) ) {
 290     return 1;
 291   }
 292 
 293   if (_matrule != NULL &amp;&amp; _insencode != NULL) {
 294     const char* opType = _matrule-&gt;_opType;
 295     if (strcmp(opType, "Set")==0)
 296       opType = _matrule-&gt;_rChild-&gt;_opType;
 297     if (strcmp(opType,"ThreadLocal")==0) {
 298       fprintf(stderr, "Warning: ThreadLocal instruction %s should be named 'tlsLoadP_*'\n",
 299               (_ident == NULL ? "NULL" : _ident));
 300       return 1;
 301     }
 302   }
 303 
 304   return 0;
 305 }
 306 
 307 
 308 // Return 'true' if this instruction matches an ideal 'If' node
 309 bool InstructForm::is_ideal_if() const {
 310   if( _matrule == NULL ) return false;
 311 
 312   return _matrule-&gt;is_ideal_if();
 313 }
 314 
 315 // Return 'true' if this instruction matches an ideal 'FastLock' node
 316 bool InstructForm::is_ideal_fastlock() const {
 317   if( _matrule == NULL ) return false;
 318 
 319   return _matrule-&gt;is_ideal_fastlock();
 320 }
 321 
 322 // Return 'true' if this instruction matches an ideal 'MemBarXXX' node
 323 bool InstructForm::is_ideal_membar() const {
 324   if( _matrule == NULL ) return false;
 325 
 326   return _matrule-&gt;is_ideal_membar();
 327 }
 328 
 329 // Return 'true' if this instruction matches an ideal 'LoadPC' node
 330 bool InstructForm::is_ideal_loadPC() const {
 331   if( _matrule == NULL ) return false;
 332 
 333   return _matrule-&gt;is_ideal_loadPC();
 334 }
 335 
 336 // Return 'true' if this instruction matches an ideal 'Box' node
 337 bool InstructForm::is_ideal_box() const {
 338   if( _matrule == NULL ) return false;
 339 
 340   return _matrule-&gt;is_ideal_box();
 341 }
 342 
 343 // Return 'true' if this instruction matches an ideal 'Goto' node
 344 bool InstructForm::is_ideal_goto() const {
 345   if( _matrule == NULL ) return false;
 346 
 347   return _matrule-&gt;is_ideal_goto();
 348 }
 349 
 350 // Return 'true' if this instruction matches an ideal 'Jump' node
 351 bool InstructForm::is_ideal_jump() const {
 352   if( _matrule == NULL ) return false;
 353 
 354   return _matrule-&gt;is_ideal_jump();
 355 }
 356 
 357 // Return 'true' if instruction matches ideal 'If' | 'Goto' | 'CountedLoopEnd'
 358 bool InstructForm::is_ideal_branch() const {
 359   if( _matrule == NULL ) return false;
 360 
 361   return _matrule-&gt;is_ideal_if() || _matrule-&gt;is_ideal_goto();
 362 }
 363 
 364 
 365 // Return 'true' if this instruction matches an ideal 'Return' node
 366 bool InstructForm::is_ideal_return() const {
 367   if( _matrule == NULL ) return false;
 368 
 369   // Check MatchRule to see if the first entry is the ideal "Return" node
 370   int  index   = 0;
 371   if (_matrule-&gt;find_type("Return",index)) return true;
 372   if (_matrule-&gt;find_type("Rethrow",index)) return true;
 373   if (_matrule-&gt;find_type("TailCall",index)) return true;
 374   if (_matrule-&gt;find_type("TailJump",index)) return true;
 375 
 376   return false;
 377 }
 378 
 379 // Return 'true' if this instruction matches an ideal 'Halt' node
 380 bool InstructForm::is_ideal_halt() const {
 381   int  index   = 0;
 382   return _matrule &amp;&amp; _matrule-&gt;find_type("Halt",index);
 383 }
 384 
 385 // Return 'true' if this instruction matches an ideal 'SafePoint' node
 386 bool InstructForm::is_ideal_safepoint() const {
 387   int  index   = 0;
 388   return _matrule &amp;&amp; _matrule-&gt;find_type("SafePoint",index);
 389 }
 390 
 391 // Return 'true' if this instruction matches an ideal 'Nop' node
 392 bool InstructForm::is_ideal_nop() const {
 393   return _ident &amp;&amp; _ident[0] == 'N' &amp;&amp; _ident[1] == 'o' &amp;&amp; _ident[2] == 'p' &amp;&amp; _ident[3] == '_';
 394 }
 395 
 396 bool InstructForm::is_ideal_control() const {
 397   if ( ! _matrule)  return false;
 398 
 399   return is_ideal_return() || is_ideal_branch() || _matrule-&gt;is_ideal_jump() || is_ideal_halt();
 400 }
 401 
 402 // Return 'true' if this instruction matches an ideal 'Call' node
 403 Form::CallType InstructForm::is_ideal_call() const {
 404   if( _matrule == NULL ) return Form::invalid_type;
 405 
 406   // Check MatchRule to see if the first entry is the ideal "Call" node
 407   int  idx   = 0;
 408   if(_matrule-&gt;find_type("CallStaticJava",idx))   return Form::JAVA_STATIC;
 409   idx = 0;
 410   if(_matrule-&gt;find_type("Lock",idx))             return Form::JAVA_STATIC;
 411   idx = 0;
 412   if(_matrule-&gt;find_type("Unlock",idx))           return Form::JAVA_STATIC;
 413   idx = 0;
 414   if(_matrule-&gt;find_type("CallDynamicJava",idx))  return Form::JAVA_DYNAMIC;
 415   idx = 0;
 416   if(_matrule-&gt;find_type("CallRuntime",idx))      return Form::JAVA_RUNTIME;
 417   idx = 0;
 418   if(_matrule-&gt;find_type("CallLeaf",idx))         return Form::JAVA_LEAF;
 419   idx = 0;
 420   if(_matrule-&gt;find_type("CallLeafNoFP",idx))     return Form::JAVA_LEAF;
 421   idx = 0;
 422 
 423   return Form::invalid_type;
 424 }
 425 
 426 // Return 'true' if this instruction matches an ideal 'Load?' node
 427 Form::DataType InstructForm::is_ideal_load() const {
 428   if( _matrule == NULL ) return Form::none;
 429 
 430   return  _matrule-&gt;is_ideal_load();
 431 }
 432 
 433 // Return 'true' if this instruction matches an ideal 'LoadKlass' node
 434 bool InstructForm::skip_antidep_check() const {
 435   if( _matrule == NULL ) return false;
 436 
 437   return  _matrule-&gt;skip_antidep_check();
 438 }
 439 
 440 // Return 'true' if this instruction matches an ideal 'Load?' node
 441 Form::DataType InstructForm::is_ideal_store() const {
 442   if( _matrule == NULL ) return Form::none;
 443 
 444   return  _matrule-&gt;is_ideal_store();
 445 }
 446 
 447 // Return 'true' if this instruction matches an ideal vector node
 448 bool InstructForm::is_vector() const {
 449   if( _matrule == NULL ) return false;
 450 
 451   return _matrule-&gt;is_vector();
 452 }
 453 
 454 
 455 // Return the input register that must match the output register
 456 // If this is not required, return 0
 457 uint InstructForm::two_address(FormDict &amp;globals) {
 458   uint  matching_input = 0;
 459   if(_components.count() == 0) return 0;
 460 
 461   _components.reset();
 462   Component *comp = _components.iter();
 463   // Check if there is a DEF
 464   if( comp-&gt;isa(Component::DEF) ) {
 465     // Check that this is a register
 466     const char  *def_type = comp-&gt;_type;
 467     const Form  *form     = globals[def_type];
 468     OperandForm *op       = form-&gt;is_operand();
 469     if( op ) {
 470       if( op-&gt;constrained_reg_class() != NULL &amp;&amp;
 471           op-&gt;interface_type(globals) == Form::register_interface ) {
 472         // Remember the local name for equality test later
 473         const char *def_name = comp-&gt;_name;
 474         // Check if a component has the same name and is a USE
 475         do {
 476           if( comp-&gt;isa(Component::USE) &amp;&amp; strcmp(comp-&gt;_name,def_name)==0 ) {
 477             return operand_position_format(def_name);
 478           }
 479         } while( (comp = _components.iter()) != NULL);
 480       }
 481     }
 482   }
 483 
 484   return 0;
 485 }
 486 
 487 
 488 // when chaining a constant to an instruction, returns 'true' and sets opType
 489 Form::DataType InstructForm::is_chain_of_constant(FormDict &amp;globals) {
 490   const char *dummy  = NULL;
 491   const char *dummy2 = NULL;
 492   return is_chain_of_constant(globals, dummy, dummy2);
 493 }
 494 Form::DataType InstructForm::is_chain_of_constant(FormDict &amp;globals,
 495                 const char * &amp;opTypeParam) {
 496   const char *result = NULL;
 497 
 498   return is_chain_of_constant(globals, opTypeParam, result);
 499 }
 500 
 501 Form::DataType InstructForm::is_chain_of_constant(FormDict &amp;globals,
 502                 const char * &amp;opTypeParam, const char * &amp;resultParam) {
 503   Form::DataType  data_type = Form::none;
 504   if ( ! _matrule)  return data_type;
 505 
 506   // !!!!!
 507   // The source of the chain rule is 'position = 1'
 508   uint         position = 1;
 509   const char  *result   = NULL;
 510   const char  *name     = NULL;
 511   const char  *opType   = NULL;
 512   // Here base_operand is looking for an ideal type to be returned (opType).
 513   if ( _matrule-&gt;is_chain_rule(globals)
 514        &amp;&amp; _matrule-&gt;base_operand(position, globals, result, name, opType) ) {
 515     data_type = ideal_to_const_type(opType);
 516 
 517     // if it isn't an ideal constant type, just return
 518     if ( data_type == Form::none ) return data_type;
 519 
 520     // Ideal constant types also adjust the opType parameter.
 521     resultParam = result;
 522     opTypeParam = opType;
 523     return data_type;
 524   }
 525 
 526   return data_type;
 527 }
 528 
 529 // Check if a simple chain rule
 530 bool InstructForm::is_simple_chain_rule(FormDict &amp;globals) const {
 531   if( _matrule &amp;&amp; _matrule-&gt;sets_result()
 532       &amp;&amp; _matrule-&gt;_rChild-&gt;_lChild == NULL
 533       &amp;&amp; globals[_matrule-&gt;_rChild-&gt;_opType]
 534       &amp;&amp; globals[_matrule-&gt;_rChild-&gt;_opType]-&gt;is_opclass() ) {
 535     return true;
 536   }
 537   return false;
 538 }
 539 
 540 // check for structural rematerialization
 541 bool InstructForm::rematerialize(FormDict &amp;globals, RegisterForm *registers ) {
 542   bool   rematerialize = false;
 543 
 544   Form::DataType data_type = is_chain_of_constant(globals);
 545   if( data_type != Form::none )
 546     rematerialize = true;
 547 
 548   // Constants
 549   if( _components.count() == 1 &amp;&amp; _components[0]-&gt;is(Component::USE_DEF) )
 550     rematerialize = true;
 551 
 552   // Pseudo-constants (values easily available to the runtime)
 553   if (is_empty_encoding() &amp;&amp; is_tls_instruction())
 554     rematerialize = true;
 555 
 556   // 1-input, 1-output, such as copies or increments.
 557   if( _components.count() == 2 &amp;&amp;
 558       _components[0]-&gt;is(Component::DEF) &amp;&amp;
 559       _components[1]-&gt;isa(Component::USE) )
 560     rematerialize = true;
 561 
 562   // Check for an ideal 'Load?' and eliminate rematerialize option
 563   if ( is_ideal_load() != Form::none || // Ideal load?  Do not rematerialize
 564        is_ideal_copy() != Form::none || // Ideal copy?  Do not rematerialize
 565        is_expensive()  != Form::none) { // Expensive?   Do not rematerialize
 566     rematerialize = false;
 567   }
 568 
 569   // Always rematerialize the flags.  They are more expensive to save &amp;
 570   // restore than to recompute (and possibly spill the compare's inputs).
 571   if( _components.count() &gt;= 1 ) {
 572     Component *c = _components[0];
 573     const Form *form = globals[c-&gt;_type];
 574     OperandForm *opform = form-&gt;is_operand();
 575     if( opform ) {
 576       // Avoid the special stack_slots register classes
 577       const char *rc_name = opform-&gt;constrained_reg_class();
 578       if( rc_name ) {
 579         if( strcmp(rc_name,"stack_slots") ) {
 580           // Check for ideal_type of RegFlags
 581           const char *type = opform-&gt;ideal_type( globals, registers );
 582           if( (type != NULL) &amp;&amp; !strcmp(type, "RegFlags") )
 583             rematerialize = true;
 584         } else
 585           rematerialize = false; // Do not rematerialize things target stk
 586       }
 587     }
 588   }
 589 
 590   return rematerialize;
 591 }
 592 
 593 // loads from memory, so must check for anti-dependence
 594 bool InstructForm::needs_anti_dependence_check(FormDict &amp;globals) const {
 595   if ( skip_antidep_check() ) return false;
 596 
 597   // Machine independent loads must be checked for anti-dependences
 598   if( is_ideal_load() != Form::none )  return true;
 599 
 600   // !!!!! !!!!! !!!!!
 601   // TEMPORARY
 602   // if( is_simple_chain_rule(globals) )  return false;
 603 
 604   // String.(compareTo/equals/indexOf) and Arrays.equals use many memorys edges,
 605   // but writes none
 606   if( _matrule &amp;&amp; _matrule-&gt;_rChild &amp;&amp;
 607       ( strcmp(_matrule-&gt;_rChild-&gt;_opType,"StrComp"    )==0 ||
 608         strcmp(_matrule-&gt;_rChild-&gt;_opType,"StrEquals"  )==0 ||
 609         strcmp(_matrule-&gt;_rChild-&gt;_opType,"StrIndexOf" )==0 ||
 610         strcmp(_matrule-&gt;_rChild-&gt;_opType,"AryEq"      )==0 ))
 611     return true;
 612 
 613   // Check if instruction has a USE of a memory operand class, but no defs
 614   bool USE_of_memory  = false;
 615   bool DEF_of_memory  = false;
 616   Component     *comp = NULL;
 617   ComponentList &amp;components = (ComponentList &amp;)_components;
 618 
 619   components.reset();
 620   while( (comp = components.iter()) != NULL ) {
 621     const Form  *form = globals[comp-&gt;_type];
 622     if( !form ) continue;
 623     OpClassForm *op   = form-&gt;is_opclass();
 624     if( !op ) continue;
 625     if( form-&gt;interface_type(globals) == Form::memory_interface ) {
 626       if( comp-&gt;isa(Component::USE) ) USE_of_memory = true;
 627       if( comp-&gt;isa(Component::DEF) ) {
 628         OperandForm *oper = form-&gt;is_operand();
 629         if( oper &amp;&amp; oper-&gt;is_user_name_for_sReg() ) {
 630           // Stack slots are unaliased memory handled by allocator
 631           oper = oper;  // debug stopping point !!!!!
 632         } else {
 633           DEF_of_memory = true;
 634         }
 635       }
 636     }
 637   }
 638   return (USE_of_memory &amp;&amp; !DEF_of_memory);
 639 }
 640 
 641 
 642 bool InstructForm::is_wide_memory_kill(FormDict &amp;globals) const {
 643   if( _matrule == NULL ) return false;
 644   if( !_matrule-&gt;_opType ) return false;
 645 
 646   if( strcmp(_matrule-&gt;_opType,"MemBarRelease") == 0 ) return true;
 647   if( strcmp(_matrule-&gt;_opType,"MemBarAcquire") == 0 ) return true;
 648   if( strcmp(_matrule-&gt;_opType,"MemBarReleaseLock") == 0 ) return true;
 649   if( strcmp(_matrule-&gt;_opType,"MemBarAcquireLock") == 0 ) return true;
 650   if( strcmp(_matrule-&gt;_opType,"MemBarStoreStore") == 0 ) return true;
 651   if( strcmp(_matrule-&gt;_opType,"StoreFence") == 0 ) return true;
 652   if( strcmp(_matrule-&gt;_opType,"LoadFence") == 0 ) return true;
 653 
 654   return false;
 655 }
 656 
 657 int InstructForm::memory_operand(FormDict &amp;globals) const {
 658   // Machine independent loads must be checked for anti-dependences
 659   // Check if instruction has a USE of a memory operand class, or a def.
 660   int USE_of_memory  = 0;
 661   int DEF_of_memory  = 0;
 662   const char*    last_memory_DEF = NULL; // to test DEF/USE pairing in asserts
 663   const char*    last_memory_USE = NULL;
 664   Component     *unique          = NULL;
 665   Component     *comp            = NULL;
 666   ComponentList &amp;components      = (ComponentList &amp;)_components;
 667 
 668   components.reset();
 669   while( (comp = components.iter()) != NULL ) {
 670     const Form  *form = globals[comp-&gt;_type];
 671     if( !form ) continue;
 672     OpClassForm *op   = form-&gt;is_opclass();
 673     if( !op ) continue;
 674     if( op-&gt;stack_slots_only(globals) )  continue;
 675     if( form-&gt;interface_type(globals) == Form::memory_interface ) {
 676       if( comp-&gt;isa(Component::DEF) ) {
 677         last_memory_DEF = comp-&gt;_name;
 678         DEF_of_memory++;
 679         unique = comp;
 680       } else if( comp-&gt;isa(Component::USE) ) {
 681         if( last_memory_DEF != NULL ) {
 682           assert(0 == strcmp(last_memory_DEF, comp-&gt;_name), "every memory DEF is followed by a USE of the same name");
 683           last_memory_DEF = NULL;
 684         }
 685         // Handles same memory being used multiple times in the case of BMI1 instructions.
 686         if (last_memory_USE != NULL) {
 687           if (strcmp(comp-&gt;_name, last_memory_USE) != 0) {
 688             USE_of_memory++;
 689           }
 690         } else {
 691           USE_of_memory++;
 692         }
 693         last_memory_USE = comp-&gt;_name;
 694 
 695         if (DEF_of_memory == 0)  // defs take precedence
 696           unique = comp;
 697       } else {
 698         assert(last_memory_DEF == NULL, "unpaired memory DEF");
 699       }
 700     }
 701   }
 702   assert(last_memory_DEF == NULL, "unpaired memory DEF");
 703   assert(USE_of_memory &gt;= DEF_of_memory, "unpaired memory DEF");
 704   USE_of_memory -= DEF_of_memory;   // treat paired DEF/USE as one occurrence
 705   if( (USE_of_memory + DEF_of_memory) &gt; 0 ) {
 706     if( is_simple_chain_rule(globals) ) {
 707       //fprintf(stderr, "Warning: chain rule is not really a memory user.\n");
 708       //((InstructForm*)this)-&gt;dump();
 709       // Preceding code prints nothing on sparc and these insns on intel:
 710       // leaP8 leaP32 leaPIdxOff leaPIdxScale leaPIdxScaleOff leaP8 leaP32
 711       // leaPIdxOff leaPIdxScale leaPIdxScaleOff
 712       return NO_MEMORY_OPERAND;
 713     }
 714 
 715     if( DEF_of_memory == 1 ) {
 716       assert(unique != NULL, "");
 717       if( USE_of_memory == 0 ) {
 718         // unique def, no uses
 719       } else {
 720         // // unique def, some uses
 721         // // must return bottom unless all uses match def
 722         // unique = NULL;
 723       }
 724     } else if( DEF_of_memory &gt; 0 ) {
 725       // multiple defs, don't care about uses
 726       unique = NULL;
 727     } else if( USE_of_memory == 1) {
 728       // unique use, no defs
 729       assert(unique != NULL, "");
 730     } else if( USE_of_memory &gt; 0 ) {
 731       // multiple uses, no defs
 732       unique = NULL;
 733     } else {
 734       assert(false, "bad case analysis");
 735     }
 736     // process the unique DEF or USE, if there is one
 737     if( unique == NULL ) {
 738       return MANY_MEMORY_OPERANDS;
 739     } else {
 740       int pos = components.operand_position(unique-&gt;_name);
 741       if( unique-&gt;isa(Component::DEF) ) {
 742         pos += 1;                // get corresponding USE from DEF
 743       }
 744       assert(pos &gt;= 1, "I was just looking at it!");
 745       return pos;
 746     }
 747   }
 748 
 749   // missed the memory op??
 750   if( true ) {  // %%% should not be necessary
 751     if( is_ideal_store() != Form::none ) {
 752       fprintf(stderr, "Warning: cannot find memory opnd in instr.\n");
 753       ((InstructForm*)this)-&gt;dump();
 754       // pretend it has multiple defs and uses
 755       return MANY_MEMORY_OPERANDS;
 756     }
 757     if( is_ideal_load()  != Form::none ) {
 758       fprintf(stderr, "Warning: cannot find memory opnd in instr.\n");
 759       ((InstructForm*)this)-&gt;dump();
 760       // pretend it has multiple uses and no defs
 761       return MANY_MEMORY_OPERANDS;
 762     }
 763   }
 764 
 765   return NO_MEMORY_OPERAND;
 766 }
 767 
 768 
 769 // This instruction captures the machine-independent bottom_type
 770 // Expected use is for pointer vs oop determination for LoadP
 771 bool InstructForm::captures_bottom_type(FormDict &amp;globals) const {
 772   if( _matrule &amp;&amp; _matrule-&gt;_rChild &amp;&amp;
 773        (!strcmp(_matrule-&gt;_rChild-&gt;_opType,"CastPP")       ||  // new result type
 774         !strcmp(_matrule-&gt;_rChild-&gt;_opType,"CastX2P")      ||  // new result type
<a name="1" id="anc1"></a><span class="new"> 775         !strcmp(_matrule-&gt;_rChild-&gt;_opType,"CastDerived")  ||  // new result type</span>
 776         !strcmp(_matrule-&gt;_rChild-&gt;_opType,"DecodeN")      ||
 777         !strcmp(_matrule-&gt;_rChild-&gt;_opType,"EncodeP")      ||
 778         !strcmp(_matrule-&gt;_rChild-&gt;_opType,"DecodeNKlass") ||
 779         !strcmp(_matrule-&gt;_rChild-&gt;_opType,"EncodePKlass") ||
 780         !strcmp(_matrule-&gt;_rChild-&gt;_opType,"LoadN")        ||
 781         !strcmp(_matrule-&gt;_rChild-&gt;_opType,"LoadNKlass")   ||
 782         !strcmp(_matrule-&gt;_rChild-&gt;_opType,"CreateEx")     ||  // type of exception
 783         !strcmp(_matrule-&gt;_rChild-&gt;_opType,"CheckCastPP")  ||
 784         !strcmp(_matrule-&gt;_rChild-&gt;_opType,"GetAndSetP")   ||
 785         !strcmp(_matrule-&gt;_rChild-&gt;_opType,"GetAndSetN")) )  return true;
 786   else if ( is_ideal_load() == Form::idealP )                return true;
 787   else if ( is_ideal_store() != Form::none  )                return true;
 788 
 789   if (needs_base_oop_edge(globals)) return true;
 790 
 791   if (is_vector()) return true;
 792   if (is_mach_constant()) return true;
 793 
 794   return  false;
 795 }
 796 
 797 
 798 // Access instr_cost attribute or return NULL.
 799 const char* InstructForm::cost() {
 800   for (Attribute* cur = _attribs; cur != NULL; cur = (Attribute*)cur-&gt;_next) {
 801     if( strcmp(cur-&gt;_ident,AttributeForm::_ins_cost) == 0 ) {
 802       return cur-&gt;_val;
 803     }
 804   }
 805   return NULL;
 806 }
 807 
 808 // Return count of top-level operands.
 809 uint InstructForm::num_opnds() {
 810   int  num_opnds = _components.num_operands();
 811 
 812   // Need special handling for matching some ideal nodes
 813   // i.e. Matching a return node
 814   /*
 815   if( _matrule ) {
 816     if( strcmp(_matrule-&gt;_opType,"Return"   )==0 ||
 817         strcmp(_matrule-&gt;_opType,"Halt"     )==0 )
 818       return 3;
 819   }
 820     */
 821   return num_opnds;
 822 }
 823 
 824 const char* InstructForm::opnd_ident(int idx) {
 825   return _components.at(idx)-&gt;_name;
 826 }
 827 
 828 const char* InstructForm::unique_opnd_ident(uint idx) {
 829   uint i;
 830   for (i = 1; i &lt; num_opnds(); ++i) {
 831     if (unique_opnds_idx(i) == idx) {
 832       break;
 833     }
 834   }
 835   return (_components.at(i) != NULL) ? _components.at(i)-&gt;_name : "";
 836 }
 837 
 838 // Return count of unmatched operands.
 839 uint InstructForm::num_post_match_opnds() {
 840   uint  num_post_match_opnds = _components.count();
 841   uint  num_match_opnds = _components.match_count();
 842   num_post_match_opnds = num_post_match_opnds - num_match_opnds;
 843 
 844   return num_post_match_opnds;
 845 }
 846 
 847 // Return the number of leaves below this complex operand
 848 uint InstructForm::num_consts(FormDict &amp;globals) const {
 849   if ( ! _matrule) return 0;
 850 
 851   // This is a recursive invocation on all operands in the matchrule
 852   return _matrule-&gt;num_consts(globals);
 853 }
 854 
 855 // Constants in match rule with specified type
 856 uint InstructForm::num_consts(FormDict &amp;globals, Form::DataType type) const {
 857   if ( ! _matrule) return 0;
 858 
 859   // This is a recursive invocation on all operands in the matchrule
 860   return _matrule-&gt;num_consts(globals, type);
 861 }
 862 
 863 
 864 // Return the register class associated with 'leaf'.
 865 const char *InstructForm::out_reg_class(FormDict &amp;globals) {
 866   assert( false, "InstructForm::out_reg_class(FormDict &amp;globals); Not Implemented");
 867 
 868   return NULL;
 869 }
 870 
 871 
 872 
 873 // Lookup the starting position of inputs we are interested in wrt. ideal nodes
 874 uint InstructForm::oper_input_base(FormDict &amp;globals) {
 875   if( !_matrule ) return 1;     // Skip control for most nodes
 876 
 877   // Need special handling for matching some ideal nodes
 878   // i.e. Matching a return node
 879   if( strcmp(_matrule-&gt;_opType,"Return"    )==0 ||
 880       strcmp(_matrule-&gt;_opType,"Rethrow"   )==0 ||
 881       strcmp(_matrule-&gt;_opType,"TailCall"  )==0 ||
 882       strcmp(_matrule-&gt;_opType,"TailJump"  )==0 ||
 883       strcmp(_matrule-&gt;_opType,"SafePoint" )==0 ||
 884       strcmp(_matrule-&gt;_opType,"Halt"      )==0 )
 885     return AdlcVMDeps::Parms;   // Skip the machine-state edges
 886 
 887   if( _matrule-&gt;_rChild &amp;&amp;
 888       ( strcmp(_matrule-&gt;_rChild-&gt;_opType,"AryEq"     )==0 ||
 889         strcmp(_matrule-&gt;_rChild-&gt;_opType,"StrComp"   )==0 ||
 890         strcmp(_matrule-&gt;_rChild-&gt;_opType,"StrEquals" )==0 ||
 891         strcmp(_matrule-&gt;_rChild-&gt;_opType,"StrIndexOf")==0 ||
 892         strcmp(_matrule-&gt;_rChild-&gt;_opType,"EncodeISOArray")==0)) {
 893         // String.(compareTo/equals/indexOf) and Arrays.equals
 894         // and sun.nio.cs.iso8859_1$Encoder.EncodeISOArray
 895         // take 1 control and 1 memory edges.
 896     return 2;
 897   }
 898 
 899   // Check for handling of 'Memory' input/edge in the ideal world.
 900   // The AD file writer is shielded from knowledge of these edges.
 901   int base = 1;                 // Skip control
 902   base += _matrule-&gt;needs_ideal_memory_edge(globals);
 903 
 904   // Also skip the base-oop value for uses of derived oops.
 905   // The AD file writer is shielded from knowledge of these edges.
 906   base += needs_base_oop_edge(globals);
 907 
 908   return base;
 909 }
 910 
 911 // This function determines the order of the MachOper in _opnds[]
 912 // by writing the operand names into the _components list.
 913 //
 914 // Implementation does not modify state of internal structures
 915 void InstructForm::build_components() {
 916   // Add top-level operands to the components
 917   if (_matrule)  _matrule-&gt;append_components(_localNames, _components);
 918 
 919   // Add parameters that "do not appear in match rule".
 920   bool has_temp = false;
 921   const char *name;
 922   const char *kill_name = NULL;
 923   for (_parameters.reset(); (name = _parameters.iter()) != NULL;) {
 924     OperandForm *opForm = (OperandForm*)_localNames[name];
 925 
 926     Effect* e = NULL;
 927     {
 928       const Form* form = _effects[name];
 929       e = form ? form-&gt;is_effect() : NULL;
 930     }
 931 
 932     if (e != NULL) {
 933       has_temp |= e-&gt;is(Component::TEMP);
 934 
 935       // KILLs must be declared after any TEMPs because TEMPs are real
 936       // uses so their operand numbering must directly follow the real
 937       // inputs from the match rule.  Fixing the numbering seems
 938       // complex so simply enforce the restriction during parse.
 939       if (kill_name != NULL &amp;&amp;
 940           e-&gt;isa(Component::TEMP) &amp;&amp; !e-&gt;isa(Component::DEF)) {
 941         OperandForm* kill = (OperandForm*)_localNames[kill_name];
 942         globalAD-&gt;syntax_err(_linenum, "%s: %s %s must be at the end of the argument list\n",
 943                              _ident, kill-&gt;_ident, kill_name);
 944       } else if (e-&gt;isa(Component::KILL) &amp;&amp; !e-&gt;isa(Component::USE)) {
 945         kill_name = name;
 946       }
 947     }
 948 
 949     const Component *component  = _components.search(name);
 950     if ( component  == NULL ) {
 951       if (e) {
 952         _components.insert(name, opForm-&gt;_ident, e-&gt;_use_def, false);
 953         component = _components.search(name);
 954         if (component-&gt;isa(Component::USE) &amp;&amp; !component-&gt;isa(Component::TEMP) &amp;&amp; _matrule) {
 955           const Form *form = globalAD-&gt;globalNames()[component-&gt;_type];
 956           assert( form, "component type must be a defined form");
 957           OperandForm *op   = form-&gt;is_operand();
 958           if (op-&gt;_interface &amp;&amp; op-&gt;_interface-&gt;is_RegInterface()) {
 959             globalAD-&gt;syntax_err(_linenum, "%s: illegal USE of non-input: %s %s\n",
 960                                  _ident, opForm-&gt;_ident, name);
 961           }
 962         }
 963       } else {
 964         // This would be a nice warning but it triggers in a few places in a benign way
 965         // if (_matrule != NULL &amp;&amp; !expands()) {
 966         //   globalAD-&gt;syntax_err(_linenum, "%s: %s %s not mentioned in effect or match rule\n",
 967         //                        _ident, opForm-&gt;_ident, name);
 968         // }
 969         _components.insert(name, opForm-&gt;_ident, Component::INVALID, false);
 970       }
 971     }
 972     else if (e) {
 973       // Component was found in the list
 974       // Check if there is a new effect that requires an extra component.
 975       // This happens when adding 'USE' to a component that is not yet one.
 976       if ((!component-&gt;isa( Component::USE) &amp;&amp; ((e-&gt;_use_def &amp; Component::USE) != 0))) {
 977         if (component-&gt;isa(Component::USE) &amp;&amp; _matrule) {
 978           const Form *form = globalAD-&gt;globalNames()[component-&gt;_type];
 979           assert( form, "component type must be a defined form");
 980           OperandForm *op   = form-&gt;is_operand();
 981           if (op-&gt;_interface &amp;&amp; op-&gt;_interface-&gt;is_RegInterface()) {
 982             globalAD-&gt;syntax_err(_linenum, "%s: illegal USE of non-input: %s %s\n",
 983                                  _ident, opForm-&gt;_ident, name);
 984           }
 985         }
 986         _components.insert(name, opForm-&gt;_ident, e-&gt;_use_def, false);
 987       } else {
 988         Component  *comp = (Component*)component;
 989         comp-&gt;promote_use_def_info(e-&gt;_use_def);
 990       }
 991       // Component positions are zero based.
 992       int  pos  = _components.operand_position(name);
 993       assert( ! (component-&gt;isa(Component::DEF) &amp;&amp; (pos &gt;= 1)),
 994               "Component::DEF can only occur in the first position");
 995     }
 996   }
 997 
 998   // Resolving the interactions between expand rules and TEMPs would
 999   // be complex so simply disallow it.
1000   if (_matrule == NULL &amp;&amp; has_temp) {
1001     globalAD-&gt;syntax_err(_linenum, "%s: TEMPs without match rule isn't supported\n", _ident);
1002   }
1003 
1004   return;
1005 }
1006 
1007 // Return zero-based position in component list;  -1 if not in list.
1008 int   InstructForm::operand_position(const char *name, int usedef) {
1009   return unique_opnds_idx(_components.operand_position(name, usedef, this));
1010 }
1011 
1012 int   InstructForm::operand_position_format(const char *name) {
1013   return unique_opnds_idx(_components.operand_position_format(name, this));
1014 }
1015 
1016 // Return zero-based position in component list; -1 if not in list.
1017 int   InstructForm::label_position() {
1018   return unique_opnds_idx(_components.label_position());
1019 }
1020 
1021 int   InstructForm::method_position() {
1022   return unique_opnds_idx(_components.method_position());
1023 }
1024 
1025 // Return number of relocation entries needed for this instruction.
1026 uint  InstructForm::reloc(FormDict &amp;globals) {
1027   uint reloc_entries  = 0;
1028   // Check for "Call" nodes
1029   if ( is_ideal_call() )      ++reloc_entries;
1030   if ( is_ideal_return() )    ++reloc_entries;
1031   if ( is_ideal_safepoint() ) ++reloc_entries;
1032 
1033 
1034   // Check if operands MAYBE oop pointers, by checking for ConP elements
1035   // Proceed through the leaves of the match-tree and check for ConPs
1036   if ( _matrule != NULL ) {
1037     uint         position = 0;
1038     const char  *result   = NULL;
1039     const char  *name     = NULL;
1040     const char  *opType   = NULL;
1041     while (_matrule-&gt;base_operand(position, globals, result, name, opType)) {
1042       if ( strcmp(opType,"ConP") == 0 ) {
1043 #ifdef SPARC
1044         reloc_entries += 2; // 1 for sethi + 1 for setlo
1045 #else
1046         ++reloc_entries;
1047 #endif
1048       }
1049       ++position;
1050     }
1051   }
1052 
1053   // Above is only a conservative estimate
1054   // because it did not check contents of operand classes.
1055   // !!!!! !!!!!
1056   // Add 1 to reloc info for each operand class in the component list.
1057   Component  *comp;
1058   _components.reset();
1059   while ( (comp = _components.iter()) != NULL ) {
1060     const Form        *form = globals[comp-&gt;_type];
1061     assert( form, "Did not find component's type in global names");
1062     const OpClassForm *opc  = form-&gt;is_opclass();
1063     const OperandForm *oper = form-&gt;is_operand();
1064     if ( opc &amp;&amp; (oper == NULL) ) {
1065       ++reloc_entries;
1066     } else if ( oper ) {
1067       // floats and doubles loaded out of method's constant pool require reloc info
1068       Form::DataType type = oper-&gt;is_base_constant(globals);
1069       if ( (type == Form::idealF) || (type == Form::idealD) ) {
1070         ++reloc_entries;
1071       }
1072     }
1073   }
1074 
1075   // Float and Double constants may come from the CodeBuffer table
1076   // and require relocatable addresses for access
1077   // !!!!!
1078   // Check for any component being an immediate float or double.
1079   Form::DataType data_type = is_chain_of_constant(globals);
1080   if( data_type==idealD || data_type==idealF ) {
1081 #ifdef SPARC
1082     // sparc required more relocation entries for floating constants
1083     // (expires 9/98)
1084     reloc_entries += 6;
1085 #else
1086     reloc_entries++;
1087 #endif
1088   }
1089 
1090   return reloc_entries;
1091 }
1092 
1093 // Utility function defined in archDesc.cpp
1094 extern bool is_def(int usedef);
1095 
1096 // Return the result of reducing an instruction
1097 const char *InstructForm::reduce_result() {
1098   const char* result = "Universe";  // default
1099   _components.reset();
1100   Component *comp = _components.iter();
1101   if (comp != NULL &amp;&amp; comp-&gt;isa(Component::DEF)) {
1102     result = comp-&gt;_type;
1103     // Override this if the rule is a store operation:
1104     if (_matrule &amp;&amp; _matrule-&gt;_rChild &amp;&amp;
1105         is_store_to_memory(_matrule-&gt;_rChild-&gt;_opType))
1106       result = "Universe";
1107   }
1108   return result;
1109 }
1110 
1111 // Return the name of the operand on the right hand side of the binary match
1112 // Return NULL if there is no right hand side
1113 const char *InstructForm::reduce_right(FormDict &amp;globals)  const {
1114   if( _matrule == NULL ) return NULL;
1115   return  _matrule-&gt;reduce_right(globals);
1116 }
1117 
1118 // Similar for left
1119 const char *InstructForm::reduce_left(FormDict &amp;globals)   const {
1120   if( _matrule == NULL ) return NULL;
1121   return  _matrule-&gt;reduce_left(globals);
1122 }
1123 
1124 
1125 // Base class for this instruction, MachNode except for calls
1126 const char *InstructForm::mach_base_class(FormDict &amp;globals)  const {
1127   if( is_ideal_call() == Form::JAVA_STATIC ) {
1128     return "MachCallStaticJavaNode";
1129   }
1130   else if( is_ideal_call() == Form::JAVA_DYNAMIC ) {
1131     return "MachCallDynamicJavaNode";
1132   }
1133   else if( is_ideal_call() == Form::JAVA_RUNTIME ) {
1134     return "MachCallRuntimeNode";
1135   }
1136   else if( is_ideal_call() == Form::JAVA_LEAF ) {
1137     return "MachCallLeafNode";
1138   }
1139   else if (is_ideal_return()) {
1140     return "MachReturnNode";
1141   }
1142   else if (is_ideal_halt()) {
1143     return "MachHaltNode";
1144   }
1145   else if (is_ideal_safepoint()) {
1146     return "MachSafePointNode";
1147   }
1148   else if (is_ideal_if()) {
1149     return "MachIfNode";
1150   }
1151   else if (is_ideal_goto()) {
1152     return "MachGotoNode";
1153   }
1154   else if (is_ideal_fastlock()) {
1155     return "MachFastLockNode";
1156   }
1157   else if (is_ideal_nop()) {
1158     return "MachNopNode";
1159   }
1160   else if (is_mach_constant()) {
1161     return "MachConstantNode";
1162   }
1163   else if (captures_bottom_type(globals)) {
1164     return "MachTypeNode";
1165   } else {
1166     return "MachNode";
1167   }
1168   assert( false, "ShouldNotReachHere()");
1169   return NULL;
1170 }
1171 
1172 // Compare the instruction predicates for textual equality
1173 bool equivalent_predicates( const InstructForm *instr1, const InstructForm *instr2 ) {
1174   const Predicate *pred1  = instr1-&gt;_predicate;
1175   const Predicate *pred2  = instr2-&gt;_predicate;
1176   if( pred1 == NULL &amp;&amp; pred2 == NULL ) {
1177     // no predicates means they are identical
1178     return true;
1179   }
1180   if( pred1 != NULL &amp;&amp; pred2 != NULL ) {
1181     // compare the predicates
1182     if (ADLParser::equivalent_expressions(pred1-&gt;_pred, pred2-&gt;_pred)) {
1183       return true;
1184     }
1185   }
1186 
1187   return false;
1188 }
1189 
1190 // Check if this instruction can cisc-spill to 'alternate'
1191 bool InstructForm::cisc_spills_to(ArchDesc &amp;AD, InstructForm *instr) {
1192   assert( _matrule != NULL &amp;&amp; instr-&gt;_matrule != NULL, "must have match rules");
1193   // Do not replace if a cisc-version has been found.
1194   if( cisc_spill_operand() != Not_cisc_spillable ) return false;
1195 
1196   int         cisc_spill_operand = Maybe_cisc_spillable;
1197   char       *result             = NULL;
1198   char       *result2            = NULL;
1199   const char *op_name            = NULL;
1200   const char *reg_type           = NULL;
1201   FormDict   &amp;globals            = AD.globalNames();
1202   cisc_spill_operand = _matrule-&gt;matchrule_cisc_spill_match(globals, AD.get_registers(), instr-&gt;_matrule, op_name, reg_type);
1203   if( (cisc_spill_operand != Not_cisc_spillable) &amp;&amp; (op_name != NULL) &amp;&amp; equivalent_predicates(this, instr) ) {
1204     cisc_spill_operand = operand_position(op_name, Component::USE);
1205     int def_oper  = operand_position(op_name, Component::DEF);
1206     if( def_oper == NameList::Not_in_list &amp;&amp; instr-&gt;num_opnds() == num_opnds()) {
1207       // Do not support cisc-spilling for destination operands and
1208       // make sure they have the same number of operands.
1209       _cisc_spill_alternate = instr;
1210       instr-&gt;set_cisc_alternate(true);
1211       if( AD._cisc_spill_debug ) {
1212         fprintf(stderr, "Instruction %s cisc-spills-to %s\n", _ident, instr-&gt;_ident);
1213         fprintf(stderr, "   using operand %s %s at index %d\n", reg_type, op_name, cisc_spill_operand);
1214       }
1215       // Record that a stack-version of the reg_mask is needed
1216       // !!!!!
1217       OperandForm *oper = (OperandForm*)(globals[reg_type]-&gt;is_operand());
1218       assert( oper != NULL, "cisc-spilling non operand");
1219       const char *reg_class_name = oper-&gt;constrained_reg_class();
1220       AD.set_stack_or_reg(reg_class_name);
1221       const char *reg_mask_name  = AD.reg_mask(*oper);
1222       set_cisc_reg_mask_name(reg_mask_name);
1223       const char *stack_or_reg_mask_name = AD.stack_or_reg_mask(*oper);
1224     } else {
1225       cisc_spill_operand = Not_cisc_spillable;
1226     }
1227   } else {
1228     cisc_spill_operand = Not_cisc_spillable;
1229   }
1230 
1231   set_cisc_spill_operand(cisc_spill_operand);
1232   return (cisc_spill_operand != Not_cisc_spillable);
1233 }
1234 
1235 // Check to see if this instruction can be replaced with the short branch
1236 // instruction `short-branch'
1237 bool InstructForm::check_branch_variant(ArchDesc &amp;AD, InstructForm *short_branch) {
1238   if (_matrule != NULL &amp;&amp;
1239       this != short_branch &amp;&amp;   // Don't match myself
1240       !is_short_branch() &amp;&amp;     // Don't match another short branch variant
1241       reduce_result() != NULL &amp;&amp;
1242       strcmp(reduce_result(), short_branch-&gt;reduce_result()) == 0 &amp;&amp;
1243       _matrule-&gt;equivalent(AD.globalNames(), short_branch-&gt;_matrule)) {
1244     // The instructions are equivalent.
1245 
1246     // Now verify that both instructions have the same parameters and
1247     // the same effects. Both branch forms should have the same inputs
1248     // and resulting projections to correctly replace a long branch node
1249     // with corresponding short branch node during code generation.
1250 
1251     bool different = false;
1252     if (short_branch-&gt;_components.count() != _components.count()) {
1253        different = true;
1254     } else if (_components.count() &gt; 0) {
1255       short_branch-&gt;_components.reset();
1256       _components.reset();
1257       Component *comp;
1258       while ((comp = _components.iter()) != NULL) {
1259         Component *short_comp = short_branch-&gt;_components.iter();
1260         if (short_comp == NULL ||
1261             short_comp-&gt;_type != comp-&gt;_type ||
1262             short_comp-&gt;_usedef != comp-&gt;_usedef) {
1263           different = true;
1264           break;
1265         }
1266       }
1267       if (short_branch-&gt;_components.iter() != NULL)
1268         different = true;
1269     }
1270     if (different) {
1271       globalAD-&gt;syntax_err(short_branch-&gt;_linenum, "Instruction %s and its short form %s have different parameters\n", _ident, short_branch-&gt;_ident);
1272     }
1273     if (AD._adl_debug &gt; 1 || AD._short_branch_debug) {
1274       fprintf(stderr, "Instruction %s has short form %s\n", _ident, short_branch-&gt;_ident);
1275     }
1276     _short_branch_form = short_branch;
1277     return true;
1278   }
1279   return false;
1280 }
1281 
1282 
1283 // --------------------------- FILE *output_routines
1284 //
1285 // Generate the format call for the replacement variable
1286 void InstructForm::rep_var_format(FILE *fp, const char *rep_var) {
1287   // Handle special constant table variables.
1288   if (strcmp(rep_var, "constanttablebase") == 0) {
1289     fprintf(fp, "char reg[128];  ra-&gt;dump_register(in(mach_constant_base_node_input()), reg);\n");
1290     fprintf(fp, "    st-&gt;print(\"%%s\", reg);\n");
1291     return;
1292   }
1293   if (strcmp(rep_var, "constantoffset") == 0) {
1294     fprintf(fp, "st-&gt;print(\"#%%d\", constant_offset_unchecked());\n");
1295     return;
1296   }
1297   if (strcmp(rep_var, "constantaddress") == 0) {
1298     fprintf(fp, "st-&gt;print(\"constant table base + #%%d\", constant_offset_unchecked());\n");
1299     return;
1300   }
1301 
1302   // Find replacement variable's type
1303   const Form *form   = _localNames[rep_var];
1304   if (form == NULL) {
1305     globalAD-&gt;syntax_err(_linenum, "Unknown replacement variable %s in format statement of %s.",
1306                          rep_var, _ident);
1307     return;
1308   }
1309   OpClassForm *opc   = form-&gt;is_opclass();
1310   assert( opc, "replacement variable was not found in local names");
1311   // Lookup the index position of the replacement variable
1312   int idx  = operand_position_format(rep_var);
1313   if ( idx == -1 ) {
1314     globalAD-&gt;syntax_err(_linenum, "Could not find replacement variable %s in format statement of %s.\n",
1315                          rep_var, _ident);
1316     assert(strcmp(opc-&gt;_ident, "label") == 0, "Unimplemented");
1317     return;
1318   }
1319 
1320   if (is_noninput_operand(idx)) {
1321     // This component isn't in the input array.  Print out the static
1322     // name of the register.
1323     OperandForm* oper = form-&gt;is_operand();
1324     if (oper != NULL &amp;&amp; oper-&gt;is_bound_register()) {
1325       const RegDef* first = oper-&gt;get_RegClass()-&gt;find_first_elem();
1326       fprintf(fp, "    st-&gt;print_raw(\"%s\");\n", first-&gt;_regname);
1327     } else {
1328       globalAD-&gt;syntax_err(_linenum, "In %s can't find format for %s %s", _ident, opc-&gt;_ident, rep_var);
1329     }
1330   } else {
1331     // Output the format call for this operand
1332     fprintf(fp,"opnd_array(%d)-&gt;",idx);
1333     if (idx == 0)
1334       fprintf(fp,"int_format(ra, this, st); // %s\n", rep_var);
1335     else
1336       fprintf(fp,"ext_format(ra, this,idx%d, st); // %s\n", idx, rep_var );
1337   }
1338 }
1339 
1340 // Seach through operands to determine parameters unique positions.
1341 void InstructForm::set_unique_opnds() {
1342   uint* uniq_idx = NULL;
1343   uint  nopnds = num_opnds();
1344   uint  num_uniq = nopnds;
1345   uint i;
1346   _uniq_idx_length = 0;
1347   if (nopnds &gt; 0) {
1348     // Allocate index array.  Worst case we're mapping from each
1349     // component back to an index and any DEF always goes at 0 so the
1350     // length of the array has to be the number of components + 1.
1351     _uniq_idx_length = _components.count() + 1;
1352     uniq_idx = (uint*) malloc(sizeof(uint) * _uniq_idx_length);
1353     for (i = 0; i &lt; _uniq_idx_length; i++) {
1354       uniq_idx[i] = i;
1355     }
1356   }
1357   // Do it only if there is a match rule and no expand rule.  With an
1358   // expand rule it is done by creating new mach node in Expand()
1359   // method.
1360   if (nopnds &gt; 0 &amp;&amp; _matrule != NULL &amp;&amp; _exprule == NULL) {
1361     const char *name;
1362     uint count;
1363     bool has_dupl_use = false;
1364 
1365     _parameters.reset();
1366     while ((name = _parameters.iter()) != NULL) {
1367       count = 0;
1368       uint position = 0;
1369       uint uniq_position = 0;
1370       _components.reset();
1371       Component *comp = NULL;
1372       if (sets_result()) {
1373         comp = _components.iter();
1374         position++;
1375       }
1376       // The next code is copied from the method operand_position().
1377       for (; (comp = _components.iter()) != NULL; ++position) {
1378         // When the first component is not a DEF,
1379         // leave space for the result operand!
1380         if (position==0 &amp;&amp; (!comp-&gt;isa(Component::DEF))) {
1381           ++position;
1382         }
1383         if (strcmp(name, comp-&gt;_name) == 0) {
1384           if (++count &gt; 1) {
1385             assert(position &lt; _uniq_idx_length, "out of bounds");
1386             uniq_idx[position] = uniq_position;
1387             has_dupl_use = true;
1388           } else {
1389             uniq_position = position;
1390           }
1391         }
1392         if (comp-&gt;isa(Component::DEF) &amp;&amp; comp-&gt;isa(Component::USE)) {
1393           ++position;
1394           if (position != 1)
1395             --position;   // only use two slots for the 1st USE_DEF
1396         }
1397       }
1398     }
1399     if (has_dupl_use) {
1400       for (i = 1; i &lt; nopnds; i++) {
1401         if (i != uniq_idx[i]) {
1402           break;
1403         }
1404       }
1405       uint j = i;
1406       for (; i &lt; nopnds; i++) {
1407         if (i == uniq_idx[i]) {
1408           uniq_idx[i] = j++;
1409         }
1410       }
1411       num_uniq = j;
1412     }
1413   }
1414   _uniq_idx = uniq_idx;
1415   _num_uniq = num_uniq;
1416 }
1417 
1418 // Generate index values needed for determining the operand position
1419 void InstructForm::index_temps(FILE *fp, FormDict &amp;globals, const char *prefix, const char *receiver) {
1420   uint  idx = 0;                  // position of operand in match rule
1421   int   cur_num_opnds = num_opnds();
1422 
1423   // Compute the index into vector of operand pointers:
1424   // idx0=0 is used to indicate that info comes from this same node, not from input edge.
1425   // idx1 starts at oper_input_base()
1426   if ( cur_num_opnds &gt;= 1 ) {
1427     fprintf(fp,"  // Start at oper_input_base() and count operands\n");
1428     fprintf(fp,"  unsigned %sidx0 = %d;\n", prefix, oper_input_base(globals));
1429     fprintf(fp,"  unsigned %sidx1 = %d;", prefix, oper_input_base(globals));
1430     fprintf(fp," \t// %s\n", unique_opnd_ident(1));
1431 
1432     // Generate starting points for other unique operands if they exist
1433     for ( idx = 2; idx &lt; num_unique_opnds(); ++idx ) {
1434       if( *receiver == 0 ) {
1435         fprintf(fp,"  unsigned %sidx%d = %sidx%d + opnd_array(%d)-&gt;num_edges();",
1436                 prefix, idx, prefix, idx-1, idx-1 );
1437       } else {
1438         fprintf(fp,"  unsigned %sidx%d = %sidx%d + %s_opnds[%d]-&gt;num_edges();",
1439                 prefix, idx, prefix, idx-1, receiver, idx-1 );
1440       }
1441       fprintf(fp," \t// %s\n", unique_opnd_ident(idx));
1442     }
1443   }
1444   if( *receiver != 0 ) {
1445     // This value is used by generate_peepreplace when copying a node.
1446     // Don't emit it in other cases since it can hide bugs with the
1447     // use invalid idx's.
1448     fprintf(fp,"  unsigned %sidx%d = %sreq(); \n", prefix, idx, receiver);
1449   }
1450 
1451 }
1452 
1453 // ---------------------------
1454 bool InstructForm::verify() {
1455   // !!!!! !!!!!
1456   // Check that a "label" operand occurs last in the operand list, if present
1457   return true;
1458 }
1459 
1460 void InstructForm::dump() {
1461   output(stderr);
1462 }
1463 
1464 void InstructForm::output(FILE *fp) {
1465   fprintf(fp,"\nInstruction: %s\n", (_ident?_ident:""));
1466   if (_matrule)   _matrule-&gt;output(fp);
1467   if (_insencode) _insencode-&gt;output(fp);
1468   if (_constant)  _constant-&gt;output(fp);
1469   if (_opcode)    _opcode-&gt;output(fp);
1470   if (_attribs)   _attribs-&gt;output(fp);
1471   if (_predicate) _predicate-&gt;output(fp);
1472   if (_effects.Size()) {
1473     fprintf(fp,"Effects\n");
1474     _effects.dump();
1475   }
1476   if (_exprule)   _exprule-&gt;output(fp);
1477   if (_rewrule)   _rewrule-&gt;output(fp);
1478   if (_format)    _format-&gt;output(fp);
1479   if (_peephole)  _peephole-&gt;output(fp);
1480 }
1481 
1482 void MachNodeForm::dump() {
1483   output(stderr);
1484 }
1485 
1486 void MachNodeForm::output(FILE *fp) {
1487   fprintf(fp,"\nMachNode: %s\n", (_ident?_ident:""));
1488 }
1489 
1490 //------------------------------build_predicate--------------------------------
1491 // Build instruction predicates.  If the user uses the same operand name
1492 // twice, we need to check that the operands are pointer-eequivalent in
1493 // the DFA during the labeling process.
1494 Predicate *InstructForm::build_predicate() {
1495   char buf[1024], *s=buf;
1496   Dict names(cmpstr,hashstr,Form::arena);       // Map Names to counts
1497 
1498   MatchNode *mnode =
1499     strcmp(_matrule-&gt;_opType, "Set") ? _matrule : _matrule-&gt;_rChild;
1500   mnode-&gt;count_instr_names(names);
1501 
1502   uint first = 1;
1503   // Start with the predicate supplied in the .ad file.
1504   if( _predicate ) {
1505     if( first ) first=0;
1506     strcpy(s,"("); s += strlen(s);
1507     strcpy(s,_predicate-&gt;_pred);
1508     s += strlen(s);
1509     strcpy(s,")"); s += strlen(s);
1510   }
1511   for( DictI i(&amp;names); i.test(); ++i ) {
1512     uintptr_t cnt = (uintptr_t)i._value;
1513     if( cnt &gt; 1 ) {             // Need a predicate at all?
1514       assert( cnt == 2, "Unimplemented" );
1515       // Handle many pairs
1516       if( first ) first=0;
1517       else {                    // All tests must pass, so use '&amp;&amp;'
1518         strcpy(s," &amp;&amp; ");
1519         s += strlen(s);
1520       }
1521       // Add predicate to working buffer
1522       sprintf(s,"/*%s*/(",(char*)i._key);
1523       s += strlen(s);
1524       mnode-&gt;build_instr_pred(s,(char*)i._key,0);
1525       s += strlen(s);
1526       strcpy(s," == "); s += strlen(s);
1527       mnode-&gt;build_instr_pred(s,(char*)i._key,1);
1528       s += strlen(s);
1529       strcpy(s,")"); s += strlen(s);
1530     }
1531   }
1532   if( s == buf ) s = NULL;
1533   else {
1534     assert( strlen(buf) &lt; sizeof(buf), "String buffer overflow" );
1535     s = strdup(buf);
1536   }
1537   return new Predicate(s);
1538 }
1539 
1540 //------------------------------EncodeForm-------------------------------------
1541 // Constructor
1542 EncodeForm::EncodeForm()
1543   : _encClass(cmpstr,hashstr, Form::arena) {
1544 }
1545 EncodeForm::~EncodeForm() {
1546 }
1547 
1548 // record a new register class
1549 EncClass *EncodeForm::add_EncClass(const char *className) {
1550   EncClass *encClass = new EncClass(className);
1551   _eclasses.addName(className);
1552   _encClass.Insert(className,encClass);
1553   return encClass;
1554 }
1555 
1556 // Lookup the function body for an encoding class
1557 EncClass  *EncodeForm::encClass(const char *className) {
1558   assert( className != NULL, "Must provide a defined encoding name");
1559 
1560   EncClass *encClass = (EncClass*)_encClass[className];
1561   return encClass;
1562 }
1563 
1564 // Lookup the function body for an encoding class
1565 const char *EncodeForm::encClassBody(const char *className) {
1566   if( className == NULL ) return NULL;
1567 
1568   EncClass *encClass = (EncClass*)_encClass[className];
1569   assert( encClass != NULL, "Encode Class is missing.");
1570   encClass-&gt;_code.reset();
1571   const char *code = (const char*)encClass-&gt;_code.iter();
1572   assert( code != NULL, "Found an empty encode class body.");
1573 
1574   return code;
1575 }
1576 
1577 // Lookup the function body for an encoding class
1578 const char *EncodeForm::encClassPrototype(const char *className) {
1579   assert( className != NULL, "Encode class name must be non NULL.");
1580 
1581   return className;
1582 }
1583 
1584 void EncodeForm::dump() {                  // Debug printer
1585   output(stderr);
1586 }
1587 
1588 void EncodeForm::output(FILE *fp) {          // Write info to output files
1589   const char *name;
1590   fprintf(fp,"\n");
1591   fprintf(fp,"-------------------- Dump EncodeForm --------------------\n");
1592   for (_eclasses.reset(); (name = _eclasses.iter()) != NULL;) {
1593     ((EncClass*)_encClass[name])-&gt;output(fp);
1594   }
1595   fprintf(fp,"-------------------- end  EncodeForm --------------------\n");
1596 }
1597 //------------------------------EncClass---------------------------------------
1598 EncClass::EncClass(const char *name)
1599   : _localNames(cmpstr,hashstr, Form::arena), _name(name) {
1600 }
1601 EncClass::~EncClass() {
1602 }
1603 
1604 // Add a parameter &lt;type,name&gt; pair
1605 void EncClass::add_parameter(const char *parameter_type, const char *parameter_name) {
1606   _parameter_type.addName( parameter_type );
1607   _parameter_name.addName( parameter_name );
1608 }
1609 
1610 // Verify operand types in parameter list
1611 bool EncClass::check_parameter_types(FormDict &amp;globals) {
1612   // !!!!!
1613   return false;
1614 }
1615 
1616 // Add the decomposed "code" sections of an encoding's code-block
1617 void EncClass::add_code(const char *code) {
1618   _code.addName(code);
1619 }
1620 
1621 // Add the decomposed "replacement variables" of an encoding's code-block
1622 void EncClass::add_rep_var(char *replacement_var) {
1623   _code.addName(NameList::_signal);
1624   _rep_vars.addName(replacement_var);
1625 }
1626 
1627 // Lookup the function body for an encoding class
1628 int EncClass::rep_var_index(const char *rep_var) {
1629   uint        position = 0;
1630   const char *name     = NULL;
1631 
1632   _parameter_name.reset();
1633   while ( (name = _parameter_name.iter()) != NULL ) {
1634     if ( strcmp(rep_var,name) == 0 ) return position;
1635     ++position;
1636   }
1637 
1638   return -1;
1639 }
1640 
1641 // Check after parsing
1642 bool EncClass::verify() {
1643   // 1!!!!
1644   // Check that each replacement variable, '$name' in architecture description
1645   // is actually a local variable for this encode class, or a reserved name
1646   // "primary, secondary, tertiary"
1647   return true;
1648 }
1649 
1650 void EncClass::dump() {
1651   output(stderr);
1652 }
1653 
1654 // Write info to output files
1655 void EncClass::output(FILE *fp) {
1656   fprintf(fp,"EncClass: %s", (_name ? _name : ""));
1657 
1658   // Output the parameter list
1659   _parameter_type.reset();
1660   _parameter_name.reset();
1661   const char *type = _parameter_type.iter();
1662   const char *name = _parameter_name.iter();
1663   fprintf(fp, " ( ");
1664   for ( ; (type != NULL) &amp;&amp; (name != NULL);
1665         (type = _parameter_type.iter()), (name = _parameter_name.iter()) ) {
1666     fprintf(fp, " %s %s,", type, name);
1667   }
1668   fprintf(fp, " ) ");
1669 
1670   // Output the code block
1671   _code.reset();
1672   _rep_vars.reset();
1673   const char *code;
1674   while ( (code = _code.iter()) != NULL ) {
1675     if ( _code.is_signal(code) ) {
1676       // A replacement variable
1677       const char *rep_var = _rep_vars.iter();
1678       fprintf(fp,"($%s)", rep_var);
1679     } else {
1680       // A section of code
1681       fprintf(fp,"%s", code);
1682     }
1683   }
1684 
1685 }
1686 
1687 //------------------------------Opcode-----------------------------------------
1688 Opcode::Opcode(char *primary, char *secondary, char *tertiary)
1689   : _primary(primary), _secondary(secondary), _tertiary(tertiary) {
1690 }
1691 
1692 Opcode::~Opcode() {
1693 }
1694 
1695 Opcode::opcode_type Opcode::as_opcode_type(const char *param) {
1696   if( strcmp(param,"primary") == 0 ) {
1697     return Opcode::PRIMARY;
1698   }
1699   else if( strcmp(param,"secondary") == 0 ) {
1700     return Opcode::SECONDARY;
1701   }
1702   else if( strcmp(param,"tertiary") == 0 ) {
1703     return Opcode::TERTIARY;
1704   }
1705   return Opcode::NOT_AN_OPCODE;
1706 }
1707 
1708 bool Opcode::print_opcode(FILE *fp, Opcode::opcode_type desired_opcode) {
1709   // Default values previously provided by MachNode::primary()...
1710   const char *description = NULL;
1711   const char *value       = NULL;
1712   // Check if user provided any opcode definitions
1713   if( this != NULL ) {
1714     // Update 'value' if user provided a definition in the instruction
1715     switch (desired_opcode) {
1716     case PRIMARY:
1717       description = "primary()";
1718       if( _primary   != NULL)  { value = _primary;     }
1719       break;
1720     case SECONDARY:
1721       description = "secondary()";
1722       if( _secondary != NULL ) { value = _secondary;   }
1723       break;
1724     case TERTIARY:
1725       description = "tertiary()";
1726       if( _tertiary  != NULL ) { value = _tertiary;    }
1727       break;
1728     default:
1729       assert( false, "ShouldNotReachHere();");
1730       break;
1731     }
1732   }
1733   if (value != NULL) {
1734     fprintf(fp, "(%s /*%s*/)", value, description);
1735   }
1736   return value != NULL;
1737 }
1738 
1739 void Opcode::dump() {
1740   output(stderr);
1741 }
1742 
1743 // Write info to output files
1744 void Opcode::output(FILE *fp) {
1745   if (_primary   != NULL) fprintf(fp,"Primary   opcode: %s\n", _primary);
1746   if (_secondary != NULL) fprintf(fp,"Secondary opcode: %s\n", _secondary);
1747   if (_tertiary  != NULL) fprintf(fp,"Tertiary  opcode: %s\n", _tertiary);
1748 }
1749 
1750 //------------------------------InsEncode--------------------------------------
1751 InsEncode::InsEncode() {
1752 }
1753 InsEncode::~InsEncode() {
1754 }
1755 
1756 // Add "encode class name" and its parameters
1757 NameAndList *InsEncode::add_encode(char *encoding) {
1758   assert( encoding != NULL, "Must provide name for encoding");
1759 
1760   // add_parameter(NameList::_signal);
1761   NameAndList *encode = new NameAndList(encoding);
1762   _encoding.addName((char*)encode);
1763 
1764   return encode;
1765 }
1766 
1767 // Access the list of encodings
1768 void InsEncode::reset() {
1769   _encoding.reset();
1770   // _parameter.reset();
1771 }
1772 const char* InsEncode::encode_class_iter() {
1773   NameAndList  *encode_class = (NameAndList*)_encoding.iter();
1774   return  ( encode_class != NULL ? encode_class-&gt;name() : NULL );
1775 }
1776 // Obtain parameter name from zero based index
1777 const char *InsEncode::rep_var_name(InstructForm &amp;inst, uint param_no) {
1778   NameAndList *params = (NameAndList*)_encoding.current();
1779   assert( params != NULL, "Internal Error");
1780   const char *param = (*params)[param_no];
1781 
1782   // Remove '$' if parser placed it there.
1783   return ( param != NULL &amp;&amp; *param == '$') ? (param+1) : param;
1784 }
1785 
1786 void InsEncode::dump() {
1787   output(stderr);
1788 }
1789 
1790 // Write info to output files
1791 void InsEncode::output(FILE *fp) {
1792   NameAndList *encoding  = NULL;
1793   const char  *parameter = NULL;
1794 
1795   fprintf(fp,"InsEncode: ");
1796   _encoding.reset();
1797 
1798   while ( (encoding = (NameAndList*)_encoding.iter()) != 0 ) {
1799     // Output the encoding being used
1800     fprintf(fp,"%s(", encoding-&gt;name() );
1801 
1802     // Output its parameter list, if any
1803     bool first_param = true;
1804     encoding-&gt;reset();
1805     while (  (parameter = encoding-&gt;iter()) != 0 ) {
1806       // Output the ',' between parameters
1807       if ( ! first_param )  fprintf(fp,", ");
1808       first_param = false;
1809       // Output the parameter
1810       fprintf(fp,"%s", parameter);
1811     } // done with parameters
1812     fprintf(fp,")  ");
1813   } // done with encodings
1814 
1815   fprintf(fp,"\n");
1816 }
1817 
1818 //------------------------------Effect-----------------------------------------
1819 static int effect_lookup(const char *name) {
1820   if(!strcmp(name, "USE")) return Component::USE;
1821   if(!strcmp(name, "DEF")) return Component::DEF;
1822   if(!strcmp(name, "USE_DEF")) return Component::USE_DEF;
1823   if(!strcmp(name, "KILL")) return Component::KILL;
1824   if(!strcmp(name, "USE_KILL")) return Component::USE_KILL;
1825   if(!strcmp(name, "TEMP")) return Component::TEMP;
1826   if(!strcmp(name, "INVALID")) return Component::INVALID;
1827   if(!strcmp(name, "CALL")) return Component::CALL;
1828   assert( false,"Invalid effect name specified\n");
1829   return Component::INVALID;
1830 }
1831 
1832 const char *Component::getUsedefName() {
1833   switch (_usedef) {
1834     case Component::INVALID:  return "INVALID";  break;
1835     case Component::USE:      return "USE";      break;
1836     case Component::USE_DEF:  return "USE_DEF";  break;
1837     case Component::USE_KILL: return "USE_KILL"; break;
1838     case Component::KILL:     return "KILL";     break;
1839     case Component::TEMP:     return "TEMP";     break;
1840     case Component::DEF:      return "DEF";      break;
1841     case Component::CALL:     return "CALL";     break;
1842     default: assert(false, "unknown effect");
1843   }
1844   return "Undefined Use/Def info";
1845 }
1846 
1847 Effect::Effect(const char *name) : _name(name), _use_def(effect_lookup(name)) {
1848   _ftype = Form::EFF;
1849 }
1850 
1851 Effect::~Effect() {
1852 }
1853 
1854 // Dynamic type check
1855 Effect *Effect::is_effect() const {
1856   return (Effect*)this;
1857 }
1858 
1859 
1860 // True if this component is equal to the parameter.
1861 bool Effect::is(int use_def_kill_enum) const {
1862   return (_use_def == use_def_kill_enum ? true : false);
1863 }
1864 // True if this component is used/def'd/kill'd as the parameter suggests.
1865 bool Effect::isa(int use_def_kill_enum) const {
1866   return (_use_def &amp; use_def_kill_enum) == use_def_kill_enum;
1867 }
1868 
1869 void Effect::dump() {
1870   output(stderr);
1871 }
1872 
1873 void Effect::output(FILE *fp) {          // Write info to output files
1874   fprintf(fp,"Effect: %s\n", (_name?_name:""));
1875 }
1876 
1877 //------------------------------ExpandRule-------------------------------------
1878 ExpandRule::ExpandRule() : _expand_instrs(),
1879                            _newopconst(cmpstr, hashstr, Form::arena) {
1880   _ftype = Form::EXP;
1881 }
1882 
1883 ExpandRule::~ExpandRule() {                  // Destructor
1884 }
1885 
1886 void ExpandRule::add_instruction(NameAndList *instruction_name_and_operand_list) {
1887   _expand_instrs.addName((char*)instruction_name_and_operand_list);
1888 }
1889 
1890 void ExpandRule::reset_instructions() {
1891   _expand_instrs.reset();
1892 }
1893 
1894 NameAndList* ExpandRule::iter_instructions() {
1895   return (NameAndList*)_expand_instrs.iter();
1896 }
1897 
1898 
1899 void ExpandRule::dump() {
1900   output(stderr);
1901 }
1902 
1903 void ExpandRule::output(FILE *fp) {         // Write info to output files
1904   NameAndList *expand_instr = NULL;
1905   const char *opid = NULL;
1906 
1907   fprintf(fp,"\nExpand Rule:\n");
1908 
1909   // Iterate over the instructions 'node' expands into
1910   for(reset_instructions(); (expand_instr = iter_instructions()) != NULL; ) {
1911     fprintf(fp,"%s(", expand_instr-&gt;name());
1912 
1913     // iterate over the operand list
1914     for( expand_instr-&gt;reset(); (opid = expand_instr-&gt;iter()) != NULL; ) {
1915       fprintf(fp,"%s ", opid);
1916     }
1917     fprintf(fp,");\n");
1918   }
1919 }
1920 
1921 //------------------------------RewriteRule------------------------------------
1922 RewriteRule::RewriteRule(char* params, char* block)
1923   : _tempParams(params), _tempBlock(block) { };  // Constructor
1924 RewriteRule::~RewriteRule() {                 // Destructor
1925 }
1926 
1927 void RewriteRule::dump() {
1928   output(stderr);
1929 }
1930 
1931 void RewriteRule::output(FILE *fp) {         // Write info to output files
1932   fprintf(fp,"\nRewrite Rule:\n%s\n%s\n",
1933           (_tempParams?_tempParams:""),
1934           (_tempBlock?_tempBlock:""));
1935 }
1936 
1937 
1938 //==============================MachNodes======================================
1939 //------------------------------MachNodeForm-----------------------------------
1940 MachNodeForm::MachNodeForm(char *id)
1941   : _ident(id) {
1942 }
1943 
1944 MachNodeForm::~MachNodeForm() {
1945 }
1946 
1947 MachNodeForm *MachNodeForm::is_machnode() const {
1948   return (MachNodeForm*)this;
1949 }
1950 
1951 //==============================Operand Classes================================
1952 //------------------------------OpClassForm------------------------------------
1953 OpClassForm::OpClassForm(const char* id) : _ident(id) {
1954   _ftype = Form::OPCLASS;
1955 }
1956 
1957 OpClassForm::~OpClassForm() {
1958 }
1959 
1960 bool OpClassForm::ideal_only() const { return 0; }
1961 
1962 OpClassForm *OpClassForm::is_opclass() const {
1963   return (OpClassForm*)this;
1964 }
1965 
1966 Form::InterfaceType OpClassForm::interface_type(FormDict &amp;globals) const {
1967   if( _oplst.count() == 0 ) return Form::no_interface;
1968 
1969   // Check that my operands have the same interface type
1970   Form::InterfaceType  interface;
1971   bool  first = true;
1972   NameList &amp;op_list = (NameList &amp;)_oplst;
1973   op_list.reset();
1974   const char *op_name;
1975   while( (op_name = op_list.iter()) != NULL ) {
1976     const Form  *form    = globals[op_name];
1977     OperandForm *operand = form-&gt;is_operand();
1978     assert( operand, "Entry in operand class that is not an operand");
1979     if( first ) {
1980       first     = false;
1981       interface = operand-&gt;interface_type(globals);
1982     } else {
1983       interface = (interface == operand-&gt;interface_type(globals) ? interface : Form::no_interface);
1984     }
1985   }
1986   return interface;
1987 }
1988 
1989 bool OpClassForm::stack_slots_only(FormDict &amp;globals) const {
1990   if( _oplst.count() == 0 ) return false;  // how?
1991 
1992   NameList &amp;op_list = (NameList &amp;)_oplst;
1993   op_list.reset();
1994   const char *op_name;
1995   while( (op_name = op_list.iter()) != NULL ) {
1996     const Form  *form    = globals[op_name];
1997     OperandForm *operand = form-&gt;is_operand();
1998     assert( operand, "Entry in operand class that is not an operand");
1999     if( !operand-&gt;stack_slots_only(globals) )  return false;
2000   }
2001   return true;
2002 }
2003 
2004 
2005 void OpClassForm::dump() {
2006   output(stderr);
2007 }
2008 
2009 void OpClassForm::output(FILE *fp) {
2010   const char *name;
2011   fprintf(fp,"\nOperand Class: %s\n", (_ident?_ident:""));
2012   fprintf(fp,"\nCount = %d\n", _oplst.count());
2013   for(_oplst.reset(); (name = _oplst.iter()) != NULL;) {
2014     fprintf(fp,"%s, ",name);
2015   }
2016   fprintf(fp,"\n");
2017 }
2018 
2019 
2020 //==============================Operands=======================================
2021 //------------------------------OperandForm------------------------------------
2022 OperandForm::OperandForm(const char* id)
2023   : OpClassForm(id), _ideal_only(false),
2024     _localNames(cmpstr, hashstr, Form::arena) {
2025       _ftype = Form::OPER;
2026 
2027       _matrule   = NULL;
2028       _interface = NULL;
2029       _attribs   = NULL;
2030       _predicate = NULL;
2031       _constraint= NULL;
2032       _construct = NULL;
2033       _format    = NULL;
2034 }
2035 OperandForm::OperandForm(const char* id, bool ideal_only)
2036   : OpClassForm(id), _ideal_only(ideal_only),
2037     _localNames(cmpstr, hashstr, Form::arena) {
2038       _ftype = Form::OPER;
2039 
2040       _matrule   = NULL;
2041       _interface = NULL;
2042       _attribs   = NULL;
2043       _predicate = NULL;
2044       _constraint= NULL;
2045       _construct = NULL;
2046       _format    = NULL;
2047 }
2048 OperandForm::~OperandForm() {
2049 }
2050 
2051 
2052 OperandForm *OperandForm::is_operand() const {
2053   return (OperandForm*)this;
2054 }
2055 
2056 bool OperandForm::ideal_only() const {
2057   return _ideal_only;
2058 }
2059 
2060 Form::InterfaceType OperandForm::interface_type(FormDict &amp;globals) const {
2061   if( _interface == NULL )  return Form::no_interface;
2062 
2063   return _interface-&gt;interface_type(globals);
2064 }
2065 
2066 
2067 bool OperandForm::stack_slots_only(FormDict &amp;globals) const {
2068   if( _constraint == NULL )  return false;
2069   return _constraint-&gt;stack_slots_only();
2070 }
2071 
2072 
2073 // Access op_cost attribute or return NULL.
2074 const char* OperandForm::cost() {
2075   for (Attribute* cur = _attribs; cur != NULL; cur = (Attribute*)cur-&gt;_next) {
2076     if( strcmp(cur-&gt;_ident,AttributeForm::_op_cost) == 0 ) {
2077       return cur-&gt;_val;
2078     }
2079   }
2080   return NULL;
2081 }
2082 
2083 // Return the number of leaves below this complex operand
2084 uint OperandForm::num_leaves() const {
2085   if ( ! _matrule) return 0;
2086 
2087   int num_leaves = _matrule-&gt;_numleaves;
2088   return num_leaves;
2089 }
2090 
2091 // Return the number of constants contained within this complex operand
2092 uint OperandForm::num_consts(FormDict &amp;globals) const {
2093   if ( ! _matrule) return 0;
2094 
2095   // This is a recursive invocation on all operands in the matchrule
2096   return _matrule-&gt;num_consts(globals);
2097 }
2098 
2099 // Return the number of constants in match rule with specified type
2100 uint OperandForm::num_consts(FormDict &amp;globals, Form::DataType type) const {
2101   if ( ! _matrule) return 0;
2102 
2103   // This is a recursive invocation on all operands in the matchrule
2104   return _matrule-&gt;num_consts(globals, type);
2105 }
2106 
2107 // Return the number of pointer constants contained within this complex operand
2108 uint OperandForm::num_const_ptrs(FormDict &amp;globals) const {
2109   if ( ! _matrule) return 0;
2110 
2111   // This is a recursive invocation on all operands in the matchrule
2112   return _matrule-&gt;num_const_ptrs(globals);
2113 }
2114 
2115 uint OperandForm::num_edges(FormDict &amp;globals) const {
2116   uint edges  = 0;
2117   uint leaves = num_leaves();
2118   uint consts = num_consts(globals);
2119 
2120   // If we are matching a constant directly, there are no leaves.
2121   edges = ( leaves &gt; consts ) ? leaves - consts : 0;
2122 
2123   // !!!!!
2124   // Special case operands that do not have a corresponding ideal node.
2125   if( (edges == 0) &amp;&amp; (consts == 0) ) {
2126     if( constrained_reg_class() != NULL ) {
2127       edges = 1;
2128     } else {
2129       if( _matrule
2130           &amp;&amp; (_matrule-&gt;_lChild == NULL) &amp;&amp; (_matrule-&gt;_rChild == NULL) ) {
2131         const Form *form = globals[_matrule-&gt;_opType];
2132         OperandForm *oper = form ? form-&gt;is_operand() : NULL;
2133         if( oper ) {
2134           return oper-&gt;num_edges(globals);
2135         }
2136       }
2137     }
2138   }
2139 
2140   return edges;
2141 }
2142 
2143 
2144 // Check if this operand is usable for cisc-spilling
2145 bool  OperandForm::is_cisc_reg(FormDict &amp;globals) const {
2146   const char *ideal = ideal_type(globals);
2147   bool is_cisc_reg = (ideal &amp;&amp; (ideal_to_Reg_type(ideal) != none));
2148   return is_cisc_reg;
2149 }
2150 
2151 bool  OpClassForm::is_cisc_mem(FormDict &amp;globals) const {
2152   Form::InterfaceType my_interface = interface_type(globals);
2153   return (my_interface == memory_interface);
2154 }
2155 
2156 
2157 // node matches ideal 'Bool'
2158 bool OperandForm::is_ideal_bool() const {
2159   if( _matrule == NULL ) return false;
2160 
2161   return _matrule-&gt;is_ideal_bool();
2162 }
2163 
2164 // Require user's name for an sRegX to be stackSlotX
2165 Form::DataType OperandForm::is_user_name_for_sReg() const {
2166   DataType data_type = none;
2167   if( _ident != NULL ) {
2168     if(      strcmp(_ident,"stackSlotI") == 0 ) data_type = Form::idealI;
2169     else if( strcmp(_ident,"stackSlotP") == 0 ) data_type = Form::idealP;
2170     else if( strcmp(_ident,"stackSlotD") == 0 ) data_type = Form::idealD;
2171     else if( strcmp(_ident,"stackSlotF") == 0 ) data_type = Form::idealF;
2172     else if( strcmp(_ident,"stackSlotL") == 0 ) data_type = Form::idealL;
2173   }
2174   assert((data_type == none) || (_matrule == NULL), "No match-rule for stackSlotX");
2175 
2176   return data_type;
2177 }
2178 
2179 
2180 // Return ideal type, if there is a single ideal type for this operand
2181 const char *OperandForm::ideal_type(FormDict &amp;globals, RegisterForm *registers) const {
2182   const char *type = NULL;
2183   if (ideal_only()) type = _ident;
2184   else if( _matrule == NULL ) {
2185     // Check for condition code register
2186     const char *rc_name = constrained_reg_class();
2187     // !!!!!
2188     if (rc_name == NULL) return NULL;
2189     // !!!!! !!!!!
2190     // Check constraints on result's register class
2191     if( registers ) {
2192       RegClass *reg_class  = registers-&gt;getRegClass(rc_name);
2193       assert( reg_class != NULL, "Register class is not defined");
2194 
2195       // Check for ideal type of entries in register class, all are the same type
2196       reg_class-&gt;reset();
2197       RegDef *reg_def = reg_class-&gt;RegDef_iter();
2198       assert( reg_def != NULL, "No entries in register class");
2199       assert( reg_def-&gt;_idealtype != NULL, "Did not define ideal type for register");
2200       // Return substring that names the register's ideal type
2201       type = reg_def-&gt;_idealtype + 3;
2202       assert( *(reg_def-&gt;_idealtype + 0) == 'O', "Expect Op_ prefix");
2203       assert( *(reg_def-&gt;_idealtype + 1) == 'p', "Expect Op_ prefix");
2204       assert( *(reg_def-&gt;_idealtype + 2) == '_', "Expect Op_ prefix");
2205     }
2206   }
2207   else if( _matrule-&gt;_lChild == NULL &amp;&amp; _matrule-&gt;_rChild == NULL ) {
2208     // This operand matches a single type, at the top level.
2209     // Check for ideal type
2210     type = _matrule-&gt;_opType;
2211     if( strcmp(type,"Bool") == 0 )
2212       return "Bool";
2213     // transitive lookup
2214     const Form *frm = globals[type];
2215     OperandForm *op = frm-&gt;is_operand();
2216     type = op-&gt;ideal_type(globals, registers);
2217   }
2218   return type;
2219 }
2220 
2221 
2222 // If there is a single ideal type for this interface field, return it.
2223 const char *OperandForm::interface_ideal_type(FormDict &amp;globals,
2224                                               const char *field) const {
2225   const char  *ideal_type = NULL;
2226   const char  *value      = NULL;
2227 
2228   // Check if "field" is valid for this operand's interface
2229   if ( ! is_interface_field(field, value) )   return ideal_type;
2230 
2231   // !!!!! !!!!! !!!!!
2232   // If a valid field has a constant value, identify "ConI" or "ConP" or ...
2233 
2234   // Else, lookup type of field's replacement variable
2235 
2236   return ideal_type;
2237 }
2238 
2239 
2240 RegClass* OperandForm::get_RegClass() const {
2241   if (_interface &amp;&amp; !_interface-&gt;is_RegInterface()) return NULL;
2242   return globalAD-&gt;get_registers()-&gt;getRegClass(constrained_reg_class());
2243 }
2244 
2245 
2246 bool OperandForm::is_bound_register() const {
2247   RegClass* reg_class = get_RegClass();
2248   if (reg_class == NULL) {
2249     return false;
2250   }
2251 
2252   const char* name = ideal_type(globalAD-&gt;globalNames());
2253   if (name == NULL) {
2254     return false;
2255   }
2256 
2257   uint size = 0;
2258   if (strcmp(name, "RegFlags") == 0) size = 1;
2259   if (strcmp(name, "RegI") == 0) size = 1;
2260   if (strcmp(name, "RegF") == 0) size = 1;
2261   if (strcmp(name, "RegD") == 0) size = 2;
2262   if (strcmp(name, "RegL") == 0) size = 2;
2263   if (strcmp(name, "RegN") == 0) size = 1;
2264   if (strcmp(name, "RegP") == 0) size = globalAD-&gt;get_preproc_def("_LP64") ? 2 : 1;
2265   if (size == 0) {
2266     return false;
2267   }
2268   return size == reg_class-&gt;size();
2269 }
2270 
2271 
2272 // Check if this is a valid field for this operand,
2273 // Return 'true' if valid, and set the value to the string the user provided.
2274 bool  OperandForm::is_interface_field(const char *field,
2275                                       const char * &amp;value) const {
2276   return false;
2277 }
2278 
2279 
2280 // Return register class name if a constraint specifies the register class.
2281 const char *OperandForm::constrained_reg_class() const {
2282   const char *reg_class  = NULL;
2283   if ( _constraint ) {
2284     // !!!!!
2285     Constraint *constraint = _constraint;
2286     if ( strcmp(_constraint-&gt;_func,"ALLOC_IN_RC") == 0 ) {
2287       reg_class = _constraint-&gt;_arg;
2288     }
2289   }
2290 
2291   return reg_class;
2292 }
2293 
2294 
2295 // Return the register class associated with 'leaf'.
2296 const char *OperandForm::in_reg_class(uint leaf, FormDict &amp;globals) {
2297   const char *reg_class = NULL; // "RegMask::Empty";
2298 
2299   if((_matrule == NULL) || (_matrule-&gt;is_chain_rule(globals))) {
2300     reg_class = constrained_reg_class();
2301     return reg_class;
2302   }
2303   const char *result   = NULL;
2304   const char *name     = NULL;
2305   const char *type     = NULL;
2306   // iterate through all base operands
2307   // until we reach the register that corresponds to "leaf"
2308   // This function is not looking for an ideal type.  It needs the first
2309   // level user type associated with the leaf.
2310   for(uint idx = 0;_matrule-&gt;base_operand(idx,globals,result,name,type);++idx) {
2311     const Form *form = (_localNames[name] ? _localNames[name] : globals[result]);
2312     OperandForm *oper = form ? form-&gt;is_operand() : NULL;
2313     if( oper ) {
2314       reg_class = oper-&gt;constrained_reg_class();
2315       if( reg_class ) {
2316         reg_class = reg_class;
2317       } else {
2318         // ShouldNotReachHere();
2319       }
2320     } else {
2321       // ShouldNotReachHere();
2322     }
2323 
2324     // Increment our target leaf position if current leaf is not a candidate.
2325     if( reg_class == NULL)    ++leaf;
2326     // Exit the loop with the value of reg_class when at the correct index
2327     if( idx == leaf )         break;
2328     // May iterate through all base operands if reg_class for 'leaf' is NULL
2329   }
2330   return reg_class;
2331 }
2332 
2333 
2334 // Recursive call to construct list of top-level operands.
2335 // Implementation does not modify state of internal structures
2336 void OperandForm::build_components() {
2337   if (_matrule)  _matrule-&gt;append_components(_localNames, _components);
2338 
2339   // Add parameters that "do not appear in match rule".
2340   const char *name;
2341   for (_parameters.reset(); (name = _parameters.iter()) != NULL;) {
2342     OperandForm *opForm = (OperandForm*)_localNames[name];
2343 
2344     if ( _components.operand_position(name) == -1 ) {
2345       _components.insert(name, opForm-&gt;_ident, Component::INVALID, false);
2346     }
2347   }
2348 
2349   return;
2350 }
2351 
2352 int OperandForm::operand_position(const char *name, int usedef) {
2353   return _components.operand_position(name, usedef, this);
2354 }
2355 
2356 
2357 // Return zero-based position in component list, only counting constants;
2358 // Return -1 if not in list.
2359 int OperandForm::constant_position(FormDict &amp;globals, const Component *last) {
2360   // Iterate through components and count constants preceding 'constant'
2361   int position = 0;
2362   Component *comp;
2363   _components.reset();
2364   while( (comp = _components.iter()) != NULL  &amp;&amp; (comp != last) ) {
2365     // Special case for operands that take a single user-defined operand
2366     // Skip the initial definition in the component list.
2367     if( strcmp(comp-&gt;_name,this-&gt;_ident) == 0 ) continue;
2368 
2369     const char *type = comp-&gt;_type;
2370     // Lookup operand form for replacement variable's type
2371     const Form *form = globals[type];
2372     assert( form != NULL, "Component's type not found");
2373     OperandForm *oper = form ? form-&gt;is_operand() : NULL;
2374     if( oper ) {
2375       if( oper-&gt;_matrule-&gt;is_base_constant(globals) != Form::none ) {
2376         ++position;
2377       }
2378     }
2379   }
2380 
2381   // Check for being passed a component that was not in the list
2382   if( comp != last )  position = -1;
2383 
2384   return position;
2385 }
2386 // Provide position of constant by "name"
2387 int OperandForm::constant_position(FormDict &amp;globals, const char *name) {
2388   const Component *comp = _components.search(name);
2389   int idx = constant_position( globals, comp );
2390 
2391   return idx;
2392 }
2393 
2394 
2395 // Return zero-based position in component list, only counting constants;
2396 // Return -1 if not in list.
2397 int OperandForm::register_position(FormDict &amp;globals, const char *reg_name) {
2398   // Iterate through components and count registers preceding 'last'
2399   uint  position = 0;
2400   Component *comp;
2401   _components.reset();
2402   while( (comp = _components.iter()) != NULL
2403          &amp;&amp; (strcmp(comp-&gt;_name,reg_name) != 0) ) {
2404     // Special case for operands that take a single user-defined operand
2405     // Skip the initial definition in the component list.
2406     if( strcmp(comp-&gt;_name,this-&gt;_ident) == 0 ) continue;
2407 
2408     const char *type = comp-&gt;_type;
2409     // Lookup operand form for component's type
2410     const Form *form = globals[type];
2411     assert( form != NULL, "Component's type not found");
2412     OperandForm *oper = form ? form-&gt;is_operand() : NULL;
2413     if( oper ) {
2414       if( oper-&gt;_matrule-&gt;is_base_register(globals) ) {
2415         ++position;
2416       }
2417     }
2418   }
2419 
2420   return position;
2421 }
2422 
2423 
2424 const char *OperandForm::reduce_result()  const {
2425   return _ident;
2426 }
2427 // Return the name of the operand on the right hand side of the binary match
2428 // Return NULL if there is no right hand side
2429 const char *OperandForm::reduce_right(FormDict &amp;globals)  const {
2430   return  ( _matrule ? _matrule-&gt;reduce_right(globals) : NULL );
2431 }
2432 
2433 // Similar for left
2434 const char *OperandForm::reduce_left(FormDict &amp;globals)   const {
2435   return  ( _matrule ? _matrule-&gt;reduce_left(globals) : NULL );
2436 }
2437 
2438 
2439 // --------------------------- FILE *output_routines
2440 //
2441 // Output code for disp_is_oop, if true.
2442 void OperandForm::disp_is_oop(FILE *fp, FormDict &amp;globals) {
2443   //  Check it is a memory interface with a non-user-constant disp field
2444   if ( this-&gt;_interface == NULL ) return;
2445   MemInterface *mem_interface = this-&gt;_interface-&gt;is_MemInterface();
2446   if ( mem_interface == NULL )    return;
2447   const char   *disp  = mem_interface-&gt;_disp;
2448   if ( *disp != '$' )             return;
2449 
2450   // Lookup replacement variable in operand's component list
2451   const char   *rep_var = disp + 1;
2452   const Component *comp = this-&gt;_components.search(rep_var);
2453   assert( comp != NULL, "Replacement variable not found in components");
2454   // Lookup operand form for replacement variable's type
2455   const char      *type = comp-&gt;_type;
2456   Form            *form = (Form*)globals[type];
2457   assert( form != NULL, "Replacement variable's type not found");
2458   OperandForm     *op   = form-&gt;is_operand();
2459   assert( op, "Memory Interface 'disp' can only emit an operand form");
2460   // Check if this is a ConP, which may require relocation
2461   if ( op-&gt;is_base_constant(globals) == Form::idealP ) {
2462     // Find the constant's index:  _c0, _c1, _c2, ... , _cN
2463     uint idx  = op-&gt;constant_position( globals, rep_var);
2464     fprintf(fp,"  virtual relocInfo::relocType disp_reloc() const {");
2465     fprintf(fp,  "  return _c%d-&gt;reloc();", idx);
2466     fprintf(fp, " }\n");
2467   }
2468 }
2469 
2470 // Generate code for internal and external format methods
2471 //
2472 // internal access to reg# node-&gt;_idx
2473 // access to subsumed constant _c0, _c1,
2474 void  OperandForm::int_format(FILE *fp, FormDict &amp;globals, uint index) {
2475   Form::DataType dtype;
2476   if (_matrule &amp;&amp; (_matrule-&gt;is_base_register(globals) ||
2477                    strcmp(ideal_type(globalAD-&gt;globalNames()), "RegFlags") == 0)) {
2478     // !!!!! !!!!!
2479     fprintf(fp,"  { char reg_str[128];\n");
2480     fprintf(fp,"    ra-&gt;dump_register(node,reg_str);\n");
2481     fprintf(fp,"    st-&gt;print(\"%cs\",reg_str);\n",'%');
2482     fprintf(fp,"  }\n");
2483   } else if (_matrule &amp;&amp; (dtype = _matrule-&gt;is_base_constant(globals)) != Form::none) {
2484     format_constant( fp, index, dtype );
2485   } else if (ideal_to_sReg_type(_ident) != Form::none) {
2486     // Special format for Stack Slot Register
2487     fprintf(fp,"  { char reg_str[128];\n");
2488     fprintf(fp,"    ra-&gt;dump_register(node,reg_str);\n");
2489     fprintf(fp,"    st-&gt;print(\"%cs\",reg_str);\n",'%');
2490     fprintf(fp,"  }\n");
2491   } else {
2492     fprintf(fp,"  st-&gt;print(\"No format defined for %s\n\");\n", _ident);
2493     fflush(fp);
2494     fprintf(stderr,"No format defined for %s\n", _ident);
2495     dump();
2496     assert( false,"Internal error:\n  output_internal_operand() attempting to output other than a Register or Constant");
2497   }
2498 }
2499 
2500 // Similar to "int_format" but for cases where data is external to operand
2501 // external access to reg# node-&gt;in(idx)-&gt;_idx,
2502 void  OperandForm::ext_format(FILE *fp, FormDict &amp;globals, uint index) {
2503   Form::DataType dtype;
2504   if (_matrule &amp;&amp; (_matrule-&gt;is_base_register(globals) ||
2505                    strcmp(ideal_type(globalAD-&gt;globalNames()), "RegFlags") == 0)) {
2506     fprintf(fp,"  { char reg_str[128];\n");
2507     fprintf(fp,"    ra-&gt;dump_register(node-&gt;in(idx");
2508     if ( index != 0 ) fprintf(fp,              "+%d",index);
2509     fprintf(fp,                                      "),reg_str);\n");
2510     fprintf(fp,"    st-&gt;print(\"%cs\",reg_str);\n",'%');
2511     fprintf(fp,"  }\n");
2512   } else if (_matrule &amp;&amp; (dtype = _matrule-&gt;is_base_constant(globals)) != Form::none) {
2513     format_constant( fp, index, dtype );
2514   } else if (ideal_to_sReg_type(_ident) != Form::none) {
2515     // Special format for Stack Slot Register
2516     fprintf(fp,"  { char reg_str[128];\n");
2517     fprintf(fp,"    ra-&gt;dump_register(node-&gt;in(idx");
2518     if ( index != 0 ) fprintf(fp,                  "+%d",index);
2519     fprintf(fp,                                       "),reg_str);\n");
2520     fprintf(fp,"    st-&gt;print(\"%cs\",reg_str);\n",'%');
2521     fprintf(fp,"  }\n");
2522   } else {
2523     fprintf(fp,"  st-&gt;print(\"No format defined for %s\n\");\n", _ident);
2524     assert( false,"Internal error:\n  output_external_operand() attempting to output other than a Register or Constant");
2525   }
2526 }
2527 
2528 void OperandForm::format_constant(FILE *fp, uint const_index, uint const_type) {
2529   switch(const_type) {
2530   case Form::idealI: fprintf(fp,"  st-&gt;print(\"#%%d\", _c%d);\n", const_index); break;
2531   case Form::idealP: fprintf(fp,"  if (_c%d) _c%d-&gt;dump_on(st);\n", const_index, const_index); break;
2532   case Form::idealNKlass:
2533   case Form::idealN: fprintf(fp,"  if (_c%d) _c%d-&gt;dump_on(st);\n", const_index, const_index); break;
2534   case Form::idealL: fprintf(fp,"  st-&gt;print(\"#\" INT64_FORMAT, (int64_t)_c%d);\n", const_index); break;
2535   case Form::idealF: fprintf(fp,"  st-&gt;print(\"#%%f\", _c%d);\n", const_index); break;
2536   case Form::idealD: fprintf(fp,"  st-&gt;print(\"#%%f\", _c%d);\n", const_index); break;
2537   default:
2538     assert( false, "ShouldNotReachHere()");
2539   }
2540 }
2541 
2542 // Return the operand form corresponding to the given index, else NULL.
2543 OperandForm *OperandForm::constant_operand(FormDict &amp;globals,
2544                                            uint      index) {
2545   // !!!!!
2546   // Check behavior on complex operands
2547   uint n_consts = num_consts(globals);
2548   if( n_consts &gt; 0 ) {
2549     uint i = 0;
2550     const char *type;
2551     Component  *comp;
2552     _components.reset();
2553     if ((comp = _components.iter()) == NULL) {
2554       assert(n_consts == 1, "Bad component list detected.\n");
2555       // Current operand is THE operand
2556       if ( index == 0 ) {
2557         return this;
2558       }
2559     } // end if NULL
2560     else {
2561       // Skip the first component, it can not be a DEF of a constant
2562       do {
2563         type = comp-&gt;base_type(globals);
2564         // Check that "type" is a 'ConI', 'ConP', ...
2565         if ( ideal_to_const_type(type) != Form::none ) {
2566           // When at correct component, get corresponding Operand
2567           if ( index == 0 ) {
2568             return globals[comp-&gt;_type]-&gt;is_operand();
2569           }
2570           // Decrement number of constants to go
2571           --index;
2572         }
2573       } while((comp = _components.iter()) != NULL);
2574     }
2575   }
2576 
2577   // Did not find a constant for this index.
2578   return NULL;
2579 }
2580 
2581 // If this operand has a single ideal type, return its type
2582 Form::DataType OperandForm::simple_type(FormDict &amp;globals) const {
2583   const char *type_name = ideal_type(globals);
2584   Form::DataType type   = type_name ? ideal_to_const_type( type_name )
2585                                     : Form::none;
2586   return type;
2587 }
2588 
2589 Form::DataType OperandForm::is_base_constant(FormDict &amp;globals) const {
2590   if ( _matrule == NULL )    return Form::none;
2591 
2592   return _matrule-&gt;is_base_constant(globals);
2593 }
2594 
2595 // "true" if this operand is a simple type that is swallowed
2596 bool  OperandForm::swallowed(FormDict &amp;globals) const {
2597   Form::DataType type   = simple_type(globals);
2598   if( type != Form::none ) {
2599     return true;
2600   }
2601 
2602   return false;
2603 }
2604 
2605 // Output code to access the value of the index'th constant
2606 void OperandForm::access_constant(FILE *fp, FormDict &amp;globals,
2607                                   uint const_index) {
2608   OperandForm *oper = constant_operand(globals, const_index);
2609   assert( oper, "Index exceeds number of constants in operand");
2610   Form::DataType dtype = oper-&gt;is_base_constant(globals);
2611 
2612   switch(dtype) {
2613   case idealI: fprintf(fp,"_c%d",           const_index); break;
2614   case idealP: fprintf(fp,"_c%d-&gt;get_con()",const_index); break;
2615   case idealL: fprintf(fp,"_c%d",           const_index); break;
2616   case idealF: fprintf(fp,"_c%d",           const_index); break;
2617   case idealD: fprintf(fp,"_c%d",           const_index); break;
2618   default:
2619     assert( false, "ShouldNotReachHere()");
2620   }
2621 }
2622 
2623 
2624 void OperandForm::dump() {
2625   output(stderr);
2626 }
2627 
2628 void OperandForm::output(FILE *fp) {
2629   fprintf(fp,"\nOperand: %s\n", (_ident?_ident:""));
2630   if (_matrule)    _matrule-&gt;dump();
2631   if (_interface)  _interface-&gt;dump();
2632   if (_attribs)    _attribs-&gt;dump();
2633   if (_predicate)  _predicate-&gt;dump();
2634   if (_constraint) _constraint-&gt;dump();
2635   if (_construct)  _construct-&gt;dump();
2636   if (_format)     _format-&gt;dump();
2637 }
2638 
2639 //------------------------------Constraint-------------------------------------
2640 Constraint::Constraint(const char *func, const char *arg)
2641   : _func(func), _arg(arg) {
2642 }
2643 Constraint::~Constraint() { /* not owner of char* */
2644 }
2645 
2646 bool Constraint::stack_slots_only() const {
2647   return strcmp(_func, "ALLOC_IN_RC") == 0
2648       &amp;&amp; strcmp(_arg,  "stack_slots") == 0;
2649 }
2650 
2651 void Constraint::dump() {
2652   output(stderr);
2653 }
2654 
2655 void Constraint::output(FILE *fp) {           // Write info to output files
2656   assert((_func != NULL &amp;&amp; _arg != NULL),"missing constraint function or arg");
2657   fprintf(fp,"Constraint: %s ( %s )\n", _func, _arg);
2658 }
2659 
2660 //------------------------------Predicate--------------------------------------
2661 Predicate::Predicate(char *pr)
2662   : _pred(pr) {
2663 }
2664 Predicate::~Predicate() {
2665 }
2666 
2667 void Predicate::dump() {
2668   output(stderr);
2669 }
2670 
2671 void Predicate::output(FILE *fp) {
2672   fprintf(fp,"Predicate");  // Write to output files
2673 }
2674 //------------------------------Interface--------------------------------------
2675 Interface::Interface(const char *name) : _name(name) {
2676 }
2677 Interface::~Interface() {
2678 }
2679 
2680 Form::InterfaceType Interface::interface_type(FormDict &amp;globals) const {
2681   Interface *thsi = (Interface*)this;
2682   if ( thsi-&gt;is_RegInterface()   ) return Form::register_interface;
2683   if ( thsi-&gt;is_MemInterface()   ) return Form::memory_interface;
2684   if ( thsi-&gt;is_ConstInterface() ) return Form::constant_interface;
2685   if ( thsi-&gt;is_CondInterface()  ) return Form::conditional_interface;
2686 
2687   return Form::no_interface;
2688 }
2689 
2690 RegInterface   *Interface::is_RegInterface() {
2691   if ( strcmp(_name,"REG_INTER") != 0 )
2692     return NULL;
2693   return (RegInterface*)this;
2694 }
2695 MemInterface   *Interface::is_MemInterface() {
2696   if ( strcmp(_name,"MEMORY_INTER") != 0 )  return NULL;
2697   return (MemInterface*)this;
2698 }
2699 ConstInterface *Interface::is_ConstInterface() {
2700   if ( strcmp(_name,"CONST_INTER") != 0 )  return NULL;
2701   return (ConstInterface*)this;
2702 }
2703 CondInterface  *Interface::is_CondInterface() {
2704   if ( strcmp(_name,"COND_INTER") != 0 )  return NULL;
2705   return (CondInterface*)this;
2706 }
2707 
2708 
2709 void Interface::dump() {
2710   output(stderr);
2711 }
2712 
2713 // Write info to output files
2714 void Interface::output(FILE *fp) {
2715   fprintf(fp,"Interface: %s\n", (_name ? _name : "") );
2716 }
2717 
2718 //------------------------------RegInterface-----------------------------------
2719 RegInterface::RegInterface() : Interface("REG_INTER") {
2720 }
2721 RegInterface::~RegInterface() {
2722 }
2723 
2724 void RegInterface::dump() {
2725   output(stderr);
2726 }
2727 
2728 // Write info to output files
2729 void RegInterface::output(FILE *fp) {
2730   Interface::output(fp);
2731 }
2732 
2733 //------------------------------ConstInterface---------------------------------
2734 ConstInterface::ConstInterface() : Interface("CONST_INTER") {
2735 }
2736 ConstInterface::~ConstInterface() {
2737 }
2738 
2739 void ConstInterface::dump() {
2740   output(stderr);
2741 }
2742 
2743 // Write info to output files
2744 void ConstInterface::output(FILE *fp) {
2745   Interface::output(fp);
2746 }
2747 
2748 //------------------------------MemInterface-----------------------------------
2749 MemInterface::MemInterface(char *base, char *index, char *scale, char *disp)
2750   : Interface("MEMORY_INTER"), _base(base), _index(index), _scale(scale), _disp(disp) {
2751 }
2752 MemInterface::~MemInterface() {
2753   // not owner of any character arrays
2754 }
2755 
2756 void MemInterface::dump() {
2757   output(stderr);
2758 }
2759 
2760 // Write info to output files
2761 void MemInterface::output(FILE *fp) {
2762   Interface::output(fp);
2763   if ( _base  != NULL ) fprintf(fp,"  base  == %s\n", _base);
2764   if ( _index != NULL ) fprintf(fp,"  index == %s\n", _index);
2765   if ( _scale != NULL ) fprintf(fp,"  scale == %s\n", _scale);
2766   if ( _disp  != NULL ) fprintf(fp,"  disp  == %s\n", _disp);
2767   // fprintf(fp,"\n");
2768 }
2769 
2770 //------------------------------CondInterface----------------------------------
2771 CondInterface::CondInterface(const char* equal,         const char* equal_format,
2772                              const char* not_equal,     const char* not_equal_format,
2773                              const char* less,          const char* less_format,
2774                              const char* greater_equal, const char* greater_equal_format,
2775                              const char* less_equal,    const char* less_equal_format,
2776                              const char* greater,       const char* greater_format,
2777                              const char* overflow,      const char* overflow_format,
2778                              const char* no_overflow,   const char* no_overflow_format)
2779   : Interface("COND_INTER"),
2780     _equal(equal),                 _equal_format(equal_format),
2781     _not_equal(not_equal),         _not_equal_format(not_equal_format),
2782     _less(less),                   _less_format(less_format),
2783     _greater_equal(greater_equal), _greater_equal_format(greater_equal_format),
2784     _less_equal(less_equal),       _less_equal_format(less_equal_format),
2785     _greater(greater),             _greater_format(greater_format),
2786     _overflow(overflow),           _overflow_format(overflow_format),
2787     _no_overflow(no_overflow),     _no_overflow_format(no_overflow_format) {
2788 }
2789 CondInterface::~CondInterface() {
2790   // not owner of any character arrays
2791 }
2792 
2793 void CondInterface::dump() {
2794   output(stderr);
2795 }
2796 
2797 // Write info to output files
2798 void CondInterface::output(FILE *fp) {
2799   Interface::output(fp);
2800   if ( _equal  != NULL )     fprintf(fp," equal        == %s\n", _equal);
2801   if ( _not_equal  != NULL ) fprintf(fp," not_equal    == %s\n", _not_equal);
2802   if ( _less  != NULL )      fprintf(fp," less         == %s\n", _less);
2803   if ( _greater_equal  != NULL ) fprintf(fp," greater_equal    == %s\n", _greater_equal);
2804   if ( _less_equal  != NULL ) fprintf(fp," less_equal   == %s\n", _less_equal);
2805   if ( _greater  != NULL )    fprintf(fp," greater      == %s\n", _greater);
2806   if ( _overflow != NULL )    fprintf(fp," overflow     == %s\n", _overflow);
2807   if ( _no_overflow != NULL ) fprintf(fp," no_overflow  == %s\n", _no_overflow);
2808   // fprintf(fp,"\n");
2809 }
2810 
2811 //------------------------------ConstructRule----------------------------------
2812 ConstructRule::ConstructRule(char *cnstr)
2813   : _construct(cnstr) {
2814 }
2815 ConstructRule::~ConstructRule() {
2816 }
2817 
2818 void ConstructRule::dump() {
2819   output(stderr);
2820 }
2821 
2822 void ConstructRule::output(FILE *fp) {
2823   fprintf(fp,"\nConstruct Rule\n");  // Write to output files
2824 }
2825 
2826 
2827 //==============================Shared Forms===================================
2828 //------------------------------AttributeForm----------------------------------
2829 int         AttributeForm::_insId   = 0;           // start counter at 0
2830 int         AttributeForm::_opId    = 0;           // start counter at 0
2831 const char* AttributeForm::_ins_cost = "ins_cost"; // required name
2832 const char* AttributeForm::_op_cost  = "op_cost";  // required name
2833 
2834 AttributeForm::AttributeForm(char *attr, int type, char *attrdef)
2835   : Form(Form::ATTR), _attrname(attr), _atype(type), _attrdef(attrdef) {
2836     if (type==OP_ATTR) {
2837       id = ++_opId;
2838     }
2839     else if (type==INS_ATTR) {
2840       id = ++_insId;
2841     }
2842     else assert( false,"");
2843 }
2844 AttributeForm::~AttributeForm() {
2845 }
2846 
2847 // Dynamic type check
2848 AttributeForm *AttributeForm::is_attribute() const {
2849   return (AttributeForm*)this;
2850 }
2851 
2852 
2853 // inlined  // int  AttributeForm::type() { return id;}
2854 
2855 void AttributeForm::dump() {
2856   output(stderr);
2857 }
2858 
2859 void AttributeForm::output(FILE *fp) {
2860   if( _attrname &amp;&amp; _attrdef ) {
2861     fprintf(fp,"\n// AttributeForm \nstatic const int %s = %s;\n",
2862             _attrname, _attrdef);
2863   }
2864   else {
2865     fprintf(fp,"\n// AttributeForm missing name %s or definition %s\n",
2866             (_attrname?_attrname:""), (_attrdef?_attrdef:"") );
2867   }
2868 }
2869 
2870 //------------------------------Component--------------------------------------
2871 Component::Component(const char *name, const char *type, int usedef)
2872   : _name(name), _type(type), _usedef(usedef) {
2873     _ftype = Form::COMP;
2874 }
2875 Component::~Component() {
2876 }
2877 
2878 // True if this component is equal to the parameter.
2879 bool Component::is(int use_def_kill_enum) const {
2880   return (_usedef == use_def_kill_enum ? true : false);
2881 }
2882 // True if this component is used/def'd/kill'd as the parameter suggests.
2883 bool Component::isa(int use_def_kill_enum) const {
2884   return (_usedef &amp; use_def_kill_enum) == use_def_kill_enum;
2885 }
2886 
2887 // Extend this component with additional use/def/kill behavior
2888 int Component::promote_use_def_info(int new_use_def) {
2889   _usedef |= new_use_def;
2890 
2891   return _usedef;
2892 }
2893 
2894 // Check the base type of this component, if it has one
2895 const char *Component::base_type(FormDict &amp;globals) {
2896   const Form *frm = globals[_type];
2897   if (frm == NULL) return NULL;
2898   OperandForm *op = frm-&gt;is_operand();
2899   if (op == NULL) return NULL;
2900   if (op-&gt;ideal_only()) return op-&gt;_ident;
2901   return (char *)op-&gt;ideal_type(globals);
2902 }
2903 
2904 void Component::dump() {
2905   output(stderr);
2906 }
2907 
2908 void Component::output(FILE *fp) {
2909   fprintf(fp,"Component:");  // Write to output files
2910   fprintf(fp, "  name = %s", _name);
2911   fprintf(fp, ", type = %s", _type);
2912   assert(_usedef != 0, "unknown effect");
2913   fprintf(fp, ", use/def = %s\n", getUsedefName());
2914 }
2915 
2916 
2917 //------------------------------ComponentList---------------------------------
2918 ComponentList::ComponentList() : NameList(), _matchcnt(0) {
2919 }
2920 ComponentList::~ComponentList() {
2921   // // This list may not own its elements if copied via assignment
2922   // Component *component;
2923   // for (reset(); (component = iter()) != NULL;) {
2924   //   delete component;
2925   // }
2926 }
2927 
2928 void   ComponentList::insert(Component *component, bool mflag) {
2929   NameList::addName((char *)component);
2930   if(mflag) _matchcnt++;
2931 }
2932 void   ComponentList::insert(const char *name, const char *opType, int usedef,
2933                              bool mflag) {
2934   Component * component = new Component(name, opType, usedef);
2935   insert(component, mflag);
2936 }
2937 Component *ComponentList::current() { return (Component*)NameList::current(); }
2938 Component *ComponentList::iter()    { return (Component*)NameList::iter(); }
2939 Component *ComponentList::match_iter() {
2940   if(_iter &lt; _matchcnt) return (Component*)NameList::iter();
2941   return NULL;
2942 }
2943 Component *ComponentList::post_match_iter() {
2944   Component *comp = iter();
2945   // At end of list?
2946   if ( comp == NULL ) {
2947     return comp;
2948   }
2949   // In post-match components?
2950   if (_iter &gt; match_count()-1) {
2951     return comp;
2952   }
2953 
2954   return post_match_iter();
2955 }
2956 
2957 void       ComponentList::reset()   { NameList::reset(); }
2958 int        ComponentList::count()   { return NameList::count(); }
2959 
2960 Component *ComponentList::operator[](int position) {
2961   // Shortcut complete iteration if there are not enough entries
2962   if (position &gt;= count()) return NULL;
2963 
2964   int        index     = 0;
2965   Component *component = NULL;
2966   for (reset(); (component = iter()) != NULL;) {
2967     if (index == position) {
2968       return component;
2969     }
2970     ++index;
2971   }
2972 
2973   return NULL;
2974 }
2975 
2976 const Component *ComponentList::search(const char *name) {
2977   PreserveIter pi(this);
2978   reset();
2979   for( Component *comp = NULL; ((comp = iter()) != NULL); ) {
2980     if( strcmp(comp-&gt;_name,name) == 0 ) return comp;
2981   }
2982 
2983   return NULL;
2984 }
2985 
2986 // Return number of USEs + number of DEFs
2987 // When there are no components, or the first component is a USE,
2988 // then we add '1' to hold a space for the 'result' operand.
2989 int ComponentList::num_operands() {
2990   PreserveIter pi(this);
2991   uint       count = 1;           // result operand
2992   uint       position = 0;
2993 
2994   Component *component  = NULL;
2995   for( reset(); (component = iter()) != NULL; ++position ) {
2996     if( component-&gt;isa(Component::USE) ||
2997         ( position == 0 &amp;&amp; (! component-&gt;isa(Component::DEF))) ) {
2998       ++count;
2999     }
3000   }
3001 
3002   return count;
3003 }
3004 
3005 // Return zero-based position of operand 'name' in list;  -1 if not in list.
3006 // if parameter 'usedef' is ::USE, it will match USE, USE_DEF, ...
3007 int ComponentList::operand_position(const char *name, int usedef, Form *fm) {
3008   PreserveIter pi(this);
3009   int position = 0;
3010   int num_opnds = num_operands();
3011   Component *component;
3012   Component* preceding_non_use = NULL;
3013   Component* first_def = NULL;
3014   for (reset(); (component = iter()) != NULL; ++position) {
3015     // When the first component is not a DEF,
3016     // leave space for the result operand!
3017     if ( position==0 &amp;&amp; (! component-&gt;isa(Component::DEF)) ) {
3018       ++position;
3019       ++num_opnds;
3020     }
3021     if (strcmp(name, component-&gt;_name)==0 &amp;&amp; (component-&gt;isa(usedef))) {
3022       // When the first entry in the component list is a DEF and a USE
3023       // Treat them as being separate, a DEF first, then a USE
3024       if( position==0
3025           &amp;&amp; usedef==Component::USE &amp;&amp; component-&gt;isa(Component::DEF) ) {
3026         assert(position+1 &lt; num_opnds, "advertised index in bounds");
3027         return position+1;
3028       } else {
3029         if( preceding_non_use &amp;&amp; strcmp(component-&gt;_name, preceding_non_use-&gt;_name) ) {
3030           fprintf(stderr, "the name '%s(%s)' should not precede the name '%s(%s)'",
3031                   preceding_non_use-&gt;_name, preceding_non_use-&gt;getUsedefName(),
3032                   name, component-&gt;getUsedefName());
3033           if (fm &amp;&amp; fm-&gt;is_instruction()) fprintf(stderr,  "in form '%s'", fm-&gt;is_instruction()-&gt;_ident);
3034           if (fm &amp;&amp; fm-&gt;is_operand()) fprintf(stderr,  "in form '%s'", fm-&gt;is_operand()-&gt;_ident);
3035           fprintf(stderr,  "\n");
3036         }
3037         if( position &gt;= num_opnds ) {
3038           fprintf(stderr, "the name '%s' is too late in its name list", name);
3039           if (fm &amp;&amp; fm-&gt;is_instruction()) fprintf(stderr,  "in form '%s'", fm-&gt;is_instruction()-&gt;_ident);
3040           if (fm &amp;&amp; fm-&gt;is_operand()) fprintf(stderr,  "in form '%s'", fm-&gt;is_operand()-&gt;_ident);
3041           fprintf(stderr,  "\n");
3042         }
3043         assert(position &lt; num_opnds, "advertised index in bounds");
3044         return position;
3045       }
3046     }
3047     if( component-&gt;isa(Component::DEF)
3048         &amp;&amp; component-&gt;isa(Component::USE) ) {
3049       ++position;
3050       if( position != 1 )  --position;   // only use two slots for the 1st USE_DEF
3051     }
3052     if( component-&gt;isa(Component::DEF) &amp;&amp; !first_def ) {
3053       first_def = component;
3054     }
3055     if( !component-&gt;isa(Component::USE) &amp;&amp; component != first_def ) {
3056       preceding_non_use = component;
3057     } else if( preceding_non_use &amp;&amp; !strcmp(component-&gt;_name, preceding_non_use-&gt;_name) ) {
3058       preceding_non_use = NULL;
3059     }
3060   }
3061   return Not_in_list;
3062 }
3063 
3064 // Find position for this name, regardless of use/def information
3065 int ComponentList::operand_position(const char *name) {
3066   PreserveIter pi(this);
3067   int position = 0;
3068   Component *component;
3069   for (reset(); (component = iter()) != NULL; ++position) {
3070     // When the first component is not a DEF,
3071     // leave space for the result operand!
3072     if ( position==0 &amp;&amp; (! component-&gt;isa(Component::DEF)) ) {
3073       ++position;
3074     }
3075     if (strcmp(name, component-&gt;_name)==0) {
3076       return position;
3077     }
3078     if( component-&gt;isa(Component::DEF)
3079         &amp;&amp; component-&gt;isa(Component::USE) ) {
3080       ++position;
3081       if( position != 1 )  --position;   // only use two slots for the 1st USE_DEF
3082     }
3083   }
3084   return Not_in_list;
3085 }
3086 
3087 int ComponentList::operand_position_format(const char *name, Form *fm) {
3088   PreserveIter pi(this);
3089   int  first_position = operand_position(name);
3090   int  use_position   = operand_position(name, Component::USE, fm);
3091 
3092   return ((first_position &lt; use_position) ? use_position : first_position);
3093 }
3094 
3095 int ComponentList::label_position() {
3096   PreserveIter pi(this);
3097   int position = 0;
3098   reset();
3099   for( Component *comp; (comp = iter()) != NULL; ++position) {
3100     // When the first component is not a DEF,
3101     // leave space for the result operand!
3102     if ( position==0 &amp;&amp; (! comp-&gt;isa(Component::DEF)) ) {
3103       ++position;
3104     }
3105     if (strcmp(comp-&gt;_type, "label")==0) {
3106       return position;
3107     }
3108     if( comp-&gt;isa(Component::DEF)
3109         &amp;&amp; comp-&gt;isa(Component::USE) ) {
3110       ++position;
3111       if( position != 1 )  --position;   // only use two slots for the 1st USE_DEF
3112     }
3113   }
3114 
3115   return -1;
3116 }
3117 
3118 int ComponentList::method_position() {
3119   PreserveIter pi(this);
3120   int position = 0;
3121   reset();
3122   for( Component *comp; (comp = iter()) != NULL; ++position) {
3123     // When the first component is not a DEF,
3124     // leave space for the result operand!
3125     if ( position==0 &amp;&amp; (! comp-&gt;isa(Component::DEF)) ) {
3126       ++position;
3127     }
3128     if (strcmp(comp-&gt;_type, "method")==0) {
3129       return position;
3130     }
3131     if( comp-&gt;isa(Component::DEF)
3132         &amp;&amp; comp-&gt;isa(Component::USE) ) {
3133       ++position;
3134       if( position != 1 )  --position;   // only use two slots for the 1st USE_DEF
3135     }
3136   }
3137 
3138   return -1;
3139 }
3140 
3141 void ComponentList::dump() { output(stderr); }
3142 
3143 void ComponentList::output(FILE *fp) {
3144   PreserveIter pi(this);
3145   fprintf(fp, "\n");
3146   Component *component;
3147   for (reset(); (component = iter()) != NULL;) {
3148     component-&gt;output(fp);
3149   }
3150   fprintf(fp, "\n");
3151 }
3152 
3153 //------------------------------MatchNode--------------------------------------
3154 MatchNode::MatchNode(ArchDesc &amp;ad, const char *result, const char *mexpr,
3155                      const char *opType, MatchNode *lChild, MatchNode *rChild)
3156   : _AD(ad), _result(result), _name(mexpr), _opType(opType),
3157     _lChild(lChild), _rChild(rChild), _internalop(0), _numleaves(0),
3158     _commutative_id(0) {
3159   _numleaves = (lChild ? lChild-&gt;_numleaves : 0)
3160                + (rChild ? rChild-&gt;_numleaves : 0);
3161 }
3162 
3163 MatchNode::MatchNode(ArchDesc &amp;ad, MatchNode&amp; mnode)
3164   : _AD(ad), _result(mnode._result), _name(mnode._name),
3165     _opType(mnode._opType), _lChild(mnode._lChild), _rChild(mnode._rChild),
3166     _internalop(0), _numleaves(mnode._numleaves),
3167     _commutative_id(mnode._commutative_id) {
3168 }
3169 
3170 MatchNode::MatchNode(ArchDesc &amp;ad, MatchNode&amp; mnode, int clone)
3171   : _AD(ad), _result(mnode._result), _name(mnode._name),
3172     _opType(mnode._opType),
3173     _internalop(0), _numleaves(mnode._numleaves),
3174     _commutative_id(mnode._commutative_id) {
3175   if (mnode._lChild) {
3176     _lChild = new MatchNode(ad, *mnode._lChild, clone);
3177   } else {
3178     _lChild = NULL;
3179   }
3180   if (mnode._rChild) {
3181     _rChild = new MatchNode(ad, *mnode._rChild, clone);
3182   } else {
3183     _rChild = NULL;
3184   }
3185 }
3186 
3187 MatchNode::~MatchNode() {
3188   // // This node may not own its children if copied via assignment
3189   // if( _lChild ) delete _lChild;
3190   // if( _rChild ) delete _rChild;
3191 }
3192 
3193 bool  MatchNode::find_type(const char *type, int &amp;position) const {
3194   if ( (_lChild != NULL) &amp;&amp; (_lChild-&gt;find_type(type, position)) ) return true;
3195   if ( (_rChild != NULL) &amp;&amp; (_rChild-&gt;find_type(type, position)) ) return true;
3196 
3197   if (strcmp(type,_opType)==0)  {
3198     return true;
3199   } else {
3200     ++position;
3201   }
3202   return false;
3203 }
3204 
3205 // Recursive call collecting info on top-level operands, not transitive.
3206 // Implementation does not modify state of internal structures.
3207 void MatchNode::append_components(FormDict&amp; locals, ComponentList&amp; components,
3208                                   bool def_flag) const {
3209   int usedef = def_flag ? Component::DEF : Component::USE;
3210   FormDict &amp;globals = _AD.globalNames();
3211 
3212   assert (_name != NULL, "MatchNode::build_components encountered empty node\n");
3213   // Base case
3214   if (_lChild==NULL &amp;&amp; _rChild==NULL) {
3215     // If _opType is not an operation, do not build a component for it #####
3216     const Form *f = globals[_opType];
3217     if( f != NULL ) {
3218       // Add non-ideals that are operands, operand-classes,
3219       if( ! f-&gt;ideal_only()
3220           &amp;&amp; (f-&gt;is_opclass() || f-&gt;is_operand()) ) {
3221         components.insert(_name, _opType, usedef, true);
3222       }
3223     }
3224     return;
3225   }
3226   // Promote results of "Set" to DEF
3227   bool tmpdef_flag = (!strcmp(_opType, "Set")) ? true : false;
3228   if (_lChild) _lChild-&gt;append_components(locals, components, tmpdef_flag);
3229   tmpdef_flag = false;   // only applies to component immediately following 'Set'
3230   if (_rChild) _rChild-&gt;append_components(locals, components, tmpdef_flag);
3231 }
3232 
3233 // Find the n'th base-operand in the match node,
3234 // recursively investigates match rules of user-defined operands.
3235 //
3236 // Implementation does not modify state of internal structures since they
3237 // can be shared.
3238 bool MatchNode::base_operand(uint &amp;position, FormDict &amp;globals,
3239                              const char * &amp;result, const char * &amp;name,
3240                              const char * &amp;opType) const {
3241   assert (_name != NULL, "MatchNode::base_operand encountered empty node\n");
3242   // Base case
3243   if (_lChild==NULL &amp;&amp; _rChild==NULL) {
3244     // Check for special case: "Universe", "label"
3245     if (strcmp(_opType,"Universe") == 0 || strcmp(_opType,"label")==0 ) {
3246       if (position == 0) {
3247         result = _result;
3248         name   = _name;
3249         opType = _opType;
3250         return 1;
3251       } else {
3252         -- position;
3253         return 0;
3254       }
3255     }
3256 
3257     const Form *form = globals[_opType];
3258     MatchNode *matchNode = NULL;
3259     // Check for user-defined type
3260     if (form) {
3261       // User operand or instruction?
3262       OperandForm  *opForm = form-&gt;is_operand();
3263       InstructForm *inForm = form-&gt;is_instruction();
3264       if ( opForm ) {
3265         matchNode = (MatchNode*)opForm-&gt;_matrule;
3266       } else if ( inForm ) {
3267         matchNode = (MatchNode*)inForm-&gt;_matrule;
3268       }
3269     }
3270     // if this is user-defined, recurse on match rule
3271     // User-defined operand and instruction forms have a match-rule.
3272     if (matchNode) {
3273       return (matchNode-&gt;base_operand(position,globals,result,name,opType));
3274     } else {
3275       // Either not a form, or a system-defined form (no match rule).
3276       if (position==0) {
3277         result = _result;
3278         name   = _name;
3279         opType = _opType;
3280         return 1;
3281       } else {
3282         --position;
3283         return 0;
3284       }
3285     }
3286 
3287   } else {
3288     // Examine the left child and right child as well
3289     if (_lChild) {
3290       if (_lChild-&gt;base_operand(position, globals, result, name, opType))
3291         return 1;
3292     }
3293 
3294     if (_rChild) {
3295       if (_rChild-&gt;base_operand(position, globals, result, name, opType))
3296         return 1;
3297     }
3298   }
3299 
3300   return 0;
3301 }
3302 
3303 // Recursive call on all operands' match rules in my match rule.
3304 uint  MatchNode::num_consts(FormDict &amp;globals) const {
3305   uint        index      = 0;
3306   uint        num_consts = 0;
3307   const char *result;
3308   const char *name;
3309   const char *opType;
3310 
3311   for (uint position = index;
3312        base_operand(position,globals,result,name,opType); position = index) {
3313     ++index;
3314     if( ideal_to_const_type(opType) )        num_consts++;
3315   }
3316 
3317   return num_consts;
3318 }
3319 
3320 // Recursive call on all operands' match rules in my match rule.
3321 // Constants in match rule subtree with specified type
3322 uint  MatchNode::num_consts(FormDict &amp;globals, Form::DataType type) const {
3323   uint        index      = 0;
3324   uint        num_consts = 0;
3325   const char *result;
3326   const char *name;
3327   const char *opType;
3328 
3329   for (uint position = index;
3330        base_operand(position,globals,result,name,opType); position = index) {
3331     ++index;
3332     if( ideal_to_const_type(opType) == type ) num_consts++;
3333   }
3334 
3335   return num_consts;
3336 }
3337 
3338 // Recursive call on all operands' match rules in my match rule.
3339 uint  MatchNode::num_const_ptrs(FormDict &amp;globals) const {
3340   return  num_consts( globals, Form::idealP );
3341 }
3342 
3343 bool  MatchNode::sets_result() const {
3344   return   ( (strcmp(_name,"Set") == 0) ? true : false );
3345 }
3346 
3347 const char *MatchNode::reduce_right(FormDict &amp;globals) const {
3348   // If there is no right reduction, return NULL.
3349   const char      *rightStr    = NULL;
3350 
3351   // If we are a "Set", start from the right child.
3352   const MatchNode *const mnode = sets_result() ?
3353     (const MatchNode *)this-&gt;_rChild :
3354     (const MatchNode *)this;
3355 
3356   // If our right child exists, it is the right reduction
3357   if ( mnode-&gt;_rChild ) {
3358     rightStr = mnode-&gt;_rChild-&gt;_internalop ? mnode-&gt;_rChild-&gt;_internalop
3359       : mnode-&gt;_rChild-&gt;_opType;
3360   }
3361   // Else, May be simple chain rule: (Set dst operand_form), rightStr=NULL;
3362   return rightStr;
3363 }
3364 
3365 const char *MatchNode::reduce_left(FormDict &amp;globals) const {
3366   // If there is no left reduction, return NULL.
3367   const char  *leftStr  = NULL;
3368 
3369   // If we are a "Set", start from the right child.
3370   const MatchNode *const mnode = sets_result() ?
3371     (const MatchNode *)this-&gt;_rChild :
3372     (const MatchNode *)this;
3373 
3374   // If our left child exists, it is the left reduction
3375   if ( mnode-&gt;_lChild ) {
3376     leftStr = mnode-&gt;_lChild-&gt;_internalop ? mnode-&gt;_lChild-&gt;_internalop
3377       : mnode-&gt;_lChild-&gt;_opType;
3378   } else {
3379     // May be simple chain rule: (Set dst operand_form_source)
3380     if ( sets_result() ) {
3381       OperandForm *oper = globals[mnode-&gt;_opType]-&gt;is_operand();
3382       if( oper ) {
3383         leftStr = mnode-&gt;_opType;
3384       }
3385     }
3386   }
3387   return leftStr;
3388 }
3389 
3390 //------------------------------count_instr_names------------------------------
3391 // Count occurrences of operands names in the leaves of the instruction
3392 // match rule.
3393 void MatchNode::count_instr_names( Dict &amp;names ) {
3394   if( !this ) return;
3395   if( _lChild ) _lChild-&gt;count_instr_names(names);
3396   if( _rChild ) _rChild-&gt;count_instr_names(names);
3397   if( !_lChild &amp;&amp; !_rChild ) {
3398     uintptr_t cnt = (uintptr_t)names[_name];
3399     cnt++;                      // One more name found
3400     names.Insert(_name,(void*)cnt);
3401   }
3402 }
3403 
3404 //------------------------------build_instr_pred-------------------------------
3405 // Build a path to 'name' in buf.  Actually only build if cnt is zero, so we
3406 // can skip some leading instances of 'name'.
3407 int MatchNode::build_instr_pred( char *buf, const char *name, int cnt ) {
3408   if( _lChild ) {
3409     if( !cnt ) strcpy( buf, "_kids[0]-&gt;" );
3410     cnt = _lChild-&gt;build_instr_pred( buf+strlen(buf), name, cnt );
3411     if( cnt &lt; 0 ) return cnt;   // Found it, all done
3412   }
3413   if( _rChild ) {
3414     if( !cnt ) strcpy( buf, "_kids[1]-&gt;" );
3415     cnt = _rChild-&gt;build_instr_pred( buf+strlen(buf), name, cnt );
3416     if( cnt &lt; 0 ) return cnt;   // Found it, all done
3417   }
3418   if( !_lChild &amp;&amp; !_rChild ) {  // Found a leaf
3419     // Wrong name?  Give up...
3420     if( strcmp(name,_name) ) return cnt;
3421     if( !cnt ) strcpy(buf,"_leaf");
3422     return cnt-1;
3423   }
3424   return cnt;
3425 }
3426 
3427 
3428 //------------------------------build_internalop-------------------------------
3429 // Build string representation of subtree
3430 void MatchNode::build_internalop( ) {
3431   char *iop, *subtree;
3432   const char *lstr, *rstr;
3433   // Build string representation of subtree
3434   // Operation lchildType rchildType
3435   int len = (int)strlen(_opType) + 4;
3436   lstr = (_lChild) ? ((_lChild-&gt;_internalop) ?
3437                        _lChild-&gt;_internalop : _lChild-&gt;_opType) : "";
3438   rstr = (_rChild) ? ((_rChild-&gt;_internalop) ?
3439                        _rChild-&gt;_internalop : _rChild-&gt;_opType) : "";
3440   len += (int)strlen(lstr) + (int)strlen(rstr);
3441   subtree = (char *)malloc(len);
3442   sprintf(subtree,"_%s_%s_%s", _opType, lstr, rstr);
3443   // Hash the subtree string in _internalOps; if a name exists, use it
3444   iop = (char *)_AD._internalOps[subtree];
3445   // Else create a unique name, and add it to the hash table
3446   if (iop == NULL) {
3447     iop = subtree;
3448     _AD._internalOps.Insert(subtree, iop);
3449     _AD._internalOpNames.addName(iop);
3450     _AD._internalMatch.Insert(iop, this);
3451   }
3452   // Add the internal operand name to the MatchNode
3453   _internalop = iop;
3454   _result = iop;
3455 }
3456 
3457 
3458 void MatchNode::dump() {
3459   output(stderr);
3460 }
3461 
3462 void MatchNode::output(FILE *fp) {
3463   if (_lChild==0 &amp;&amp; _rChild==0) {
3464     fprintf(fp," %s",_name);    // operand
3465   }
3466   else {
3467     fprintf(fp," (%s ",_name);  // " (opcodeName "
3468     if(_lChild) _lChild-&gt;output(fp); //               left operand
3469     if(_rChild) _rChild-&gt;output(fp); //                    right operand
3470     fprintf(fp,")");                 //                                 ")"
3471   }
3472 }
3473 
3474 int MatchNode::needs_ideal_memory_edge(FormDict &amp;globals) const {
3475   static const char *needs_ideal_memory_list[] = {
3476     "StoreI","StoreL","StoreP","StoreN","StoreNKlass","StoreD","StoreF" ,
3477     "StoreB","StoreC","Store" ,"StoreFP",
3478     "LoadI", "LoadL", "LoadP" ,"LoadN", "LoadD" ,"LoadF"  ,
3479     "LoadB" , "LoadUB", "LoadUS" ,"LoadS" ,"Load" ,
3480     "StoreVector", "LoadVector",
3481     "LoadRange", "LoadKlass", "LoadNKlass", "LoadL_unaligned", "LoadD_unaligned",
3482     "LoadPLocked",
3483     "StorePConditional", "StoreIConditional", "StoreLConditional",
3484     "CompareAndSwapI", "CompareAndSwapL", "CompareAndSwapP", "CompareAndSwapN",
3485     "StoreCM",
3486     "ClearArray",
3487     "GetAndAddI", "GetAndSetI", "GetAndSetP",
3488     "GetAndAddL", "GetAndSetL", "GetAndSetN",
3489   };
3490   int cnt = sizeof(needs_ideal_memory_list)/sizeof(char*);
3491   if( strcmp(_opType,"PrefetchRead")==0 ||
3492       strcmp(_opType,"PrefetchWrite")==0 ||
3493       strcmp(_opType,"PrefetchAllocation")==0 )
3494     return 1;
3495   if( _lChild ) {
3496     const char *opType = _lChild-&gt;_opType;
3497     for( int i=0; i&lt;cnt; i++ )
3498       if( strcmp(opType,needs_ideal_memory_list[i]) == 0 )
3499         return 1;
3500     if( _lChild-&gt;needs_ideal_memory_edge(globals) )
3501       return 1;
3502   }
3503   if( _rChild ) {
3504     const char *opType = _rChild-&gt;_opType;
3505     for( int i=0; i&lt;cnt; i++ )
3506       if( strcmp(opType,needs_ideal_memory_list[i]) == 0 )
3507         return 1;
3508     if( _rChild-&gt;needs_ideal_memory_edge(globals) )
3509       return 1;
3510   }
3511 
3512   return 0;
3513 }
3514 
3515 // TRUE if defines a derived oop, and so needs a base oop edge present
3516 // post-matching.
3517 int MatchNode::needs_base_oop_edge() const {
3518   if( !strcmp(_opType,"AddP") ) return 1;
3519   if( strcmp(_opType,"Set") ) return 0;
3520   return !strcmp(_rChild-&gt;_opType,"AddP");
3521 }
3522 
3523 int InstructForm::needs_base_oop_edge(FormDict &amp;globals) const {
3524   if( is_simple_chain_rule(globals) ) {
3525     const char *src = _matrule-&gt;_rChild-&gt;_opType;
3526     OperandForm *src_op = globals[src]-&gt;is_operand();
3527     assert( src_op, "Not operand class of chain rule" );
3528     return src_op-&gt;_matrule ? src_op-&gt;_matrule-&gt;needs_base_oop_edge() : 0;
3529   }                             // Else check instruction
3530 
3531   return _matrule ? _matrule-&gt;needs_base_oop_edge() : 0;
3532 }
3533 
3534 
3535 //-------------------------cisc spilling methods-------------------------------
3536 // helper routines and methods for detecting cisc-spilling instructions
3537 //-------------------------cisc_spill_merge------------------------------------
3538 int MatchNode::cisc_spill_merge(int left_spillable, int right_spillable) {
3539   int cisc_spillable  = Maybe_cisc_spillable;
3540 
3541   // Combine results of left and right checks
3542   if( (left_spillable == Maybe_cisc_spillable) &amp;&amp; (right_spillable == Maybe_cisc_spillable) ) {
3543     // neither side is spillable, nor prevents cisc spilling
3544     cisc_spillable = Maybe_cisc_spillable;
3545   }
3546   else if( (left_spillable == Maybe_cisc_spillable) &amp;&amp; (right_spillable &gt; Maybe_cisc_spillable) ) {
3547     // right side is spillable
3548     cisc_spillable = right_spillable;
3549   }
3550   else if( (right_spillable == Maybe_cisc_spillable) &amp;&amp; (left_spillable &gt; Maybe_cisc_spillable) ) {
3551     // left side is spillable
3552     cisc_spillable = left_spillable;
3553   }
3554   else if( (left_spillable == Not_cisc_spillable) || (right_spillable == Not_cisc_spillable) ) {
3555     // left or right prevents cisc spilling this instruction
3556     cisc_spillable = Not_cisc_spillable;
3557   }
3558   else {
3559     // Only allow one to spill
3560     cisc_spillable = Not_cisc_spillable;
3561   }
3562 
3563   return cisc_spillable;
3564 }
3565 
3566 //-------------------------root_ops_match--------------------------------------
3567 bool static root_ops_match(FormDict &amp;globals, const char *op1, const char *op2) {
3568   // Base Case: check that the current operands/operations match
3569   assert( op1, "Must have op's name");
3570   assert( op2, "Must have op's name");
3571   const Form *form1 = globals[op1];
3572   const Form *form2 = globals[op2];
3573 
3574   return (form1 == form2);
3575 }
3576 
3577 //-------------------------cisc_spill_match_node-------------------------------
3578 // Recursively check two MatchRules for legal conversion via cisc-spilling
3579 int MatchNode::cisc_spill_match(FormDict&amp; globals, RegisterForm* registers, MatchNode* mRule2, const char* &amp;operand, const char* &amp;reg_type) {
3580   int cisc_spillable  = Maybe_cisc_spillable;
3581   int left_spillable  = Maybe_cisc_spillable;
3582   int right_spillable = Maybe_cisc_spillable;
3583 
3584   // Check that each has same number of operands at this level
3585   if( (_lChild &amp;&amp; !(mRule2-&gt;_lChild)) || (_rChild &amp;&amp; !(mRule2-&gt;_rChild)) )
3586     return Not_cisc_spillable;
3587 
3588   // Base Case: check that the current operands/operations match
3589   // or are CISC spillable
3590   assert( _opType, "Must have _opType");
3591   assert( mRule2-&gt;_opType, "Must have _opType");
3592   const Form *form  = globals[_opType];
3593   const Form *form2 = globals[mRule2-&gt;_opType];
3594   if( form == form2 ) {
3595     cisc_spillable = Maybe_cisc_spillable;
3596   } else {
3597     const InstructForm *form2_inst = form2 ? form2-&gt;is_instruction() : NULL;
3598     const char *name_left  = mRule2-&gt;_lChild ? mRule2-&gt;_lChild-&gt;_opType : NULL;
3599     const char *name_right = mRule2-&gt;_rChild ? mRule2-&gt;_rChild-&gt;_opType : NULL;
3600     DataType data_type = Form::none;
3601     if (form-&gt;is_operand()) {
3602       // Make sure the loadX matches the type of the reg
3603       data_type = form-&gt;ideal_to_Reg_type(form-&gt;is_operand()-&gt;ideal_type(globals));
3604     }
3605     // Detect reg vs (loadX memory)
3606     if( form-&gt;is_cisc_reg(globals)
3607         &amp;&amp; form2_inst
3608         &amp;&amp; data_type != Form::none
3609         &amp;&amp; (is_load_from_memory(mRule2-&gt;_opType) == data_type) // reg vs. (load memory)
3610         &amp;&amp; (name_left != NULL)       // NOT (load)
3611         &amp;&amp; (name_right == NULL) ) {  // NOT (load memory foo)
3612       const Form *form2_left = name_left ? globals[name_left] : NULL;
3613       if( form2_left &amp;&amp; form2_left-&gt;is_cisc_mem(globals) ) {
3614         cisc_spillable = Is_cisc_spillable;
3615         operand        = _name;
3616         reg_type       = _result;
3617         return Is_cisc_spillable;
3618       } else {
3619         cisc_spillable = Not_cisc_spillable;
3620       }
3621     }
3622     // Detect reg vs memory
3623     else if( form-&gt;is_cisc_reg(globals) &amp;&amp; form2-&gt;is_cisc_mem(globals) ) {
3624       cisc_spillable = Is_cisc_spillable;
3625       operand        = _name;
3626       reg_type       = _result;
3627       return Is_cisc_spillable;
3628     } else {
3629       cisc_spillable = Not_cisc_spillable;
3630     }
3631   }
3632 
3633   // If cisc is still possible, check rest of tree
3634   if( cisc_spillable == Maybe_cisc_spillable ) {
3635     // Check that each has same number of operands at this level
3636     if( (_lChild &amp;&amp; !(mRule2-&gt;_lChild)) || (_rChild &amp;&amp; !(mRule2-&gt;_rChild)) ) return Not_cisc_spillable;
3637 
3638     // Check left operands
3639     if( (_lChild == NULL) &amp;&amp; (mRule2-&gt;_lChild == NULL) ) {
3640       left_spillable = Maybe_cisc_spillable;
3641     } else {
3642       left_spillable = _lChild-&gt;cisc_spill_match(globals, registers, mRule2-&gt;_lChild, operand, reg_type);
3643     }
3644 
3645     // Check right operands
3646     if( (_rChild == NULL) &amp;&amp; (mRule2-&gt;_rChild == NULL) ) {
3647       right_spillable =  Maybe_cisc_spillable;
3648     } else {
3649       right_spillable = _rChild-&gt;cisc_spill_match(globals, registers, mRule2-&gt;_rChild, operand, reg_type);
3650     }
3651 
3652     // Combine results of left and right checks
3653     cisc_spillable = cisc_spill_merge(left_spillable, right_spillable);
3654   }
3655 
3656   return cisc_spillable;
3657 }
3658 
3659 //---------------------------cisc_spill_match_rule------------------------------
3660 // Recursively check two MatchRules for legal conversion via cisc-spilling
3661 // This method handles the root of Match tree,
3662 // general recursive checks done in MatchNode
3663 int  MatchRule::matchrule_cisc_spill_match(FormDict&amp; globals, RegisterForm* registers,
3664                                            MatchRule* mRule2, const char* &amp;operand,
3665                                            const char* &amp;reg_type) {
3666   int cisc_spillable  = Maybe_cisc_spillable;
3667   int left_spillable  = Maybe_cisc_spillable;
3668   int right_spillable = Maybe_cisc_spillable;
3669 
3670   // Check that each sets a result
3671   if( !(sets_result() &amp;&amp; mRule2-&gt;sets_result()) ) return Not_cisc_spillable;
3672   // Check that each has same number of operands at this level
3673   if( (_lChild &amp;&amp; !(mRule2-&gt;_lChild)) || (_rChild &amp;&amp; !(mRule2-&gt;_rChild)) ) return Not_cisc_spillable;
3674 
3675   // Check left operands: at root, must be target of 'Set'
3676   if( (_lChild == NULL) || (mRule2-&gt;_lChild == NULL) ) {
3677     left_spillable = Not_cisc_spillable;
3678   } else {
3679     // Do not support cisc-spilling instruction's target location
3680     if( root_ops_match(globals, _lChild-&gt;_opType, mRule2-&gt;_lChild-&gt;_opType) ) {
3681       left_spillable = Maybe_cisc_spillable;
3682     } else {
3683       left_spillable = Not_cisc_spillable;
3684     }
3685   }
3686 
3687   // Check right operands: recursive walk to identify reg-&gt;mem operand
3688   if( (_rChild == NULL) &amp;&amp; (mRule2-&gt;_rChild == NULL) ) {
3689     right_spillable =  Maybe_cisc_spillable;
3690   } else {
3691     right_spillable = _rChild-&gt;cisc_spill_match(globals, registers, mRule2-&gt;_rChild, operand, reg_type);
3692   }
3693 
3694   // Combine results of left and right checks
3695   cisc_spillable = cisc_spill_merge(left_spillable, right_spillable);
3696 
3697   return cisc_spillable;
3698 }
3699 
3700 //----------------------------- equivalent ------------------------------------
3701 // Recursively check to see if two match rules are equivalent.
3702 // This rule handles the root.
3703 bool MatchRule::equivalent(FormDict &amp;globals, MatchNode *mRule2) {
3704   // Check that each sets a result
3705   if (sets_result() != mRule2-&gt;sets_result()) {
3706     return false;
3707   }
3708 
3709   // Check that the current operands/operations match
3710   assert( _opType, "Must have _opType");
3711   assert( mRule2-&gt;_opType, "Must have _opType");
3712   const Form *form  = globals[_opType];
3713   const Form *form2 = globals[mRule2-&gt;_opType];
3714   if( form != form2 ) {
3715     return false;
3716   }
3717 
3718   if (_lChild ) {
3719     if( !_lChild-&gt;equivalent(globals, mRule2-&gt;_lChild) )
3720       return false;
3721   } else if (mRule2-&gt;_lChild) {
3722     return false; // I have NULL left child, mRule2 has non-NULL left child.
3723   }
3724 
3725   if (_rChild ) {
3726     if( !_rChild-&gt;equivalent(globals, mRule2-&gt;_rChild) )
3727       return false;
3728   } else if (mRule2-&gt;_rChild) {
3729     return false; // I have NULL right child, mRule2 has non-NULL right child.
3730   }
3731 
3732   // We've made it through the gauntlet.
3733   return true;
3734 }
3735 
3736 //----------------------------- equivalent ------------------------------------
3737 // Recursively check to see if two match rules are equivalent.
3738 // This rule handles the operands.
3739 bool MatchNode::equivalent(FormDict &amp;globals, MatchNode *mNode2) {
3740   if( !mNode2 )
3741     return false;
3742 
3743   // Check that the current operands/operations match
3744   assert( _opType, "Must have _opType");
3745   assert( mNode2-&gt;_opType, "Must have _opType");
3746   const Form *form  = globals[_opType];
3747   const Form *form2 = globals[mNode2-&gt;_opType];
3748   if( form != form2 ) {
3749     return false;
3750   }
3751 
3752   // Check that their children also match
3753   if (_lChild ) {
3754     if( !_lChild-&gt;equivalent(globals, mNode2-&gt;_lChild) )
3755       return false;
3756   } else if (mNode2-&gt;_lChild) {
3757     return false; // I have NULL left child, mNode2 has non-NULL left child.
3758   }
3759 
3760   if (_rChild ) {
3761     if( !_rChild-&gt;equivalent(globals, mNode2-&gt;_rChild) )
3762       return false;
3763   } else if (mNode2-&gt;_rChild) {
3764     return false; // I have NULL right child, mNode2 has non-NULL right child.
3765   }
3766 
3767   // We've made it through the gauntlet.
3768   return true;
3769 }
3770 
3771 //-------------------------- has_commutative_op -------------------------------
3772 // Recursively check for commutative operations with subtree operands
3773 // which could be swapped.
3774 void MatchNode::count_commutative_op(int&amp; count) {
3775   static const char *commut_op_list[] = {
3776     "AddI","AddL","AddF","AddD",
3777     "AndI","AndL",
3778     "MaxI","MinI",
3779     "MulI","MulL","MulF","MulD",
3780     "OrI" ,"OrL" ,
3781     "XorI","XorL"
3782   };
3783   int cnt = sizeof(commut_op_list)/sizeof(char*);
3784 
3785   if( _lChild &amp;&amp; _rChild &amp;&amp; (_lChild-&gt;_lChild || _rChild-&gt;_lChild) ) {
3786     // Don't swap if right operand is an immediate constant.
3787     bool is_const = false;
3788     if( _rChild-&gt;_lChild == NULL &amp;&amp; _rChild-&gt;_rChild == NULL ) {
3789       FormDict &amp;globals = _AD.globalNames();
3790       const Form *form = globals[_rChild-&gt;_opType];
3791       if ( form ) {
3792         OperandForm  *oper = form-&gt;is_operand();
3793         if( oper &amp;&amp; oper-&gt;interface_type(globals) == Form::constant_interface )
3794           is_const = true;
3795       }
3796     }
3797     if( !is_const ) {
3798       for( int i=0; i&lt;cnt; i++ ) {
3799         if( strcmp(_opType, commut_op_list[i]) == 0 ) {
3800           count++;
3801           _commutative_id = count; // id should be &gt; 0
3802           break;
3803         }
3804       }
3805     }
3806   }
3807   if( _lChild )
3808     _lChild-&gt;count_commutative_op(count);
3809   if( _rChild )
3810     _rChild-&gt;count_commutative_op(count);
3811 }
3812 
3813 //-------------------------- swap_commutative_op ------------------------------
3814 // Recursively swap specified commutative operation with subtree operands.
3815 void MatchNode::swap_commutative_op(bool atroot, int id) {
3816   if( _commutative_id == id ) { // id should be &gt; 0
3817     assert(_lChild &amp;&amp; _rChild &amp;&amp; (_lChild-&gt;_lChild || _rChild-&gt;_lChild ),
3818             "not swappable operation");
3819     MatchNode* tmp = _lChild;
3820     _lChild = _rChild;
3821     _rChild = tmp;
3822     // Don't exit here since we need to build internalop.
3823   }
3824 
3825   bool is_set = ( strcmp(_opType, "Set") == 0 );
3826   if( _lChild )
3827     _lChild-&gt;swap_commutative_op(is_set, id);
3828   if( _rChild )
3829     _rChild-&gt;swap_commutative_op(is_set, id);
3830 
3831   // If not the root, reduce this subtree to an internal operand
3832   if( !atroot &amp;&amp; (_lChild || _rChild) ) {
3833     build_internalop();
3834   }
3835 }
3836 
3837 //-------------------------- swap_commutative_op ------------------------------
3838 // Recursively swap specified commutative operation with subtree operands.
3839 void MatchRule::matchrule_swap_commutative_op(const char* instr_ident, int count, int&amp; match_rules_cnt) {
3840   assert(match_rules_cnt &lt; 100," too many match rule clones");
3841   // Clone
3842   MatchRule* clone = new MatchRule(_AD, this);
3843   // Swap operands of commutative operation
3844   ((MatchNode*)clone)-&gt;swap_commutative_op(true, count);
3845   char* buf = (char*) malloc(strlen(instr_ident) + 4);
3846   sprintf(buf, "%s_%d", instr_ident, match_rules_cnt++);
3847   clone-&gt;_result = buf;
3848 
3849   clone-&gt;_next = this-&gt;_next;
3850   this-&gt; _next = clone;
3851   if( (--count) &gt; 0 ) {
3852     this-&gt; matchrule_swap_commutative_op(instr_ident, count, match_rules_cnt);
3853     clone-&gt;matchrule_swap_commutative_op(instr_ident, count, match_rules_cnt);
3854   }
3855 }
3856 
3857 //------------------------------MatchRule--------------------------------------
3858 MatchRule::MatchRule(ArchDesc &amp;ad)
3859   : MatchNode(ad), _depth(0), _construct(NULL), _numchilds(0) {
3860     _next = NULL;
3861 }
3862 
3863 MatchRule::MatchRule(ArchDesc &amp;ad, MatchRule* mRule)
3864   : MatchNode(ad, *mRule, 0), _depth(mRule-&gt;_depth),
3865     _construct(mRule-&gt;_construct), _numchilds(mRule-&gt;_numchilds) {
3866     _next = NULL;
3867 }
3868 
3869 MatchRule::MatchRule(ArchDesc &amp;ad, MatchNode* mroot, int depth, char *cnstr,
3870                      int numleaves)
3871   : MatchNode(ad,*mroot), _depth(depth), _construct(cnstr),
3872     _numchilds(0) {
3873       _next = NULL;
3874       mroot-&gt;_lChild = NULL;
3875       mroot-&gt;_rChild = NULL;
3876       delete mroot;
3877       _numleaves = numleaves;
3878       _numchilds = (_lChild ? 1 : 0) + (_rChild ? 1 : 0);
3879 }
3880 MatchRule::~MatchRule() {
3881 }
3882 
3883 // Recursive call collecting info on top-level operands, not transitive.
3884 // Implementation does not modify state of internal structures.
3885 void MatchRule::append_components(FormDict&amp; locals, ComponentList&amp; components, bool def_flag) const {
3886   assert (_name != NULL, "MatchNode::build_components encountered empty node\n");
3887 
3888   MatchNode::append_components(locals, components,
3889                                false /* not necessarily a def */);
3890 }
3891 
3892 // Recursive call on all operands' match rules in my match rule.
3893 // Implementation does not modify state of internal structures  since they
3894 // can be shared.
3895 // The MatchNode that is called first treats its
3896 bool MatchRule::base_operand(uint &amp;position0, FormDict &amp;globals,
3897                              const char *&amp;result, const char * &amp;name,
3898                              const char * &amp;opType)const{
3899   uint position = position0;
3900 
3901   return (MatchNode::base_operand( position, globals, result, name, opType));
3902 }
3903 
3904 
3905 bool MatchRule::is_base_register(FormDict &amp;globals) const {
3906   uint   position = 1;
3907   const char  *result   = NULL;
3908   const char  *name     = NULL;
3909   const char  *opType   = NULL;
3910   if (!base_operand(position, globals, result, name, opType)) {
3911     position = 0;
3912     if( base_operand(position, globals, result, name, opType) &amp;&amp;
3913         (strcmp(opType,"RegI")==0 ||
3914          strcmp(opType,"RegP")==0 ||
3915          strcmp(opType,"RegN")==0 ||
3916          strcmp(opType,"RegL")==0 ||
3917          strcmp(opType,"RegF")==0 ||
3918          strcmp(opType,"RegD")==0 ||
3919          strcmp(opType,"VecS")==0 ||
3920          strcmp(opType,"VecD")==0 ||
3921          strcmp(opType,"VecX")==0 ||
3922          strcmp(opType,"VecY")==0 ||
3923          strcmp(opType,"Reg" )==0) ) {
3924       return 1;
3925     }
3926   }
3927   return 0;
3928 }
3929 
3930 Form::DataType MatchRule::is_base_constant(FormDict &amp;globals) const {
3931   uint         position = 1;
3932   const char  *result   = NULL;
3933   const char  *name     = NULL;
3934   const char  *opType   = NULL;
3935   if (!base_operand(position, globals, result, name, opType)) {
3936     position = 0;
3937     if (base_operand(position, globals, result, name, opType)) {
3938       return ideal_to_const_type(opType);
3939     }
3940   }
3941   return Form::none;
3942 }
3943 
3944 bool MatchRule::is_chain_rule(FormDict &amp;globals) const {
3945 
3946   // Check for chain rule, and do not generate a match list for it
3947   if ((_lChild == NULL) &amp;&amp; (_rChild == NULL) ) {
3948     const Form *form = globals[_opType];
3949     // If this is ideal, then it is a base match, not a chain rule.
3950     if ( form &amp;&amp; form-&gt;is_operand() &amp;&amp; (!form-&gt;ideal_only())) {
3951       return true;
3952     }
3953   }
3954   // Check for "Set" form of chain rule, and do not generate a match list
3955   if (_rChild) {
3956     const char *rch = _rChild-&gt;_opType;
3957     const Form *form = globals[rch];
3958     if ((!strcmp(_opType,"Set") &amp;&amp;
3959          ((form) &amp;&amp; form-&gt;is_operand()))) {
3960       return true;
3961     }
3962   }
3963   return false;
3964 }
3965 
3966 int MatchRule::is_ideal_copy() const {
3967   if( _rChild ) {
3968     const char  *opType = _rChild-&gt;_opType;
3969 #if 1
3970     if( strcmp(opType,"CastIP")==0 )
3971       return 1;
3972 #else
3973     if( strcmp(opType,"CastII")==0 )
3974       return 1;
3975     // Do not treat *CastPP this way, because it
3976     // may transfer a raw pointer to an oop.
3977     // If the register allocator were to coalesce this
3978     // into a single LRG, the GC maps would be incorrect.
3979     //if( strcmp(opType,"CastPP")==0 )
3980     //  return 1;
3981     //if( strcmp(opType,"CheckCastPP")==0 )
3982     //  return 1;
3983     //
3984     // Do not treat CastX2P or CastP2X this way, because
3985     // raw pointers and int types are treated differently
3986     // when saving local &amp; stack info for safepoints in
3987     // Output().
3988     //if( strcmp(opType,"CastX2P")==0 )
3989     //  return 1;
3990     //if( strcmp(opType,"CastP2X")==0 )
3991     //  return 1;
3992 #endif
3993   }
3994   if( is_chain_rule(_AD.globalNames()) &amp;&amp;
3995       _lChild &amp;&amp; strncmp(_lChild-&gt;_opType,"stackSlot",9)==0 )
3996     return 1;
3997   return 0;
3998 }
3999 
4000 
4001 int MatchRule::is_expensive() const {
4002   if( _rChild ) {
4003     const char  *opType = _rChild-&gt;_opType;
4004     if( strcmp(opType,"AtanD")==0 ||
4005         strcmp(opType,"CosD")==0 ||
4006         strcmp(opType,"DivD")==0 ||
4007         strcmp(opType,"DivF")==0 ||
4008         strcmp(opType,"DivI")==0 ||
4009         strcmp(opType,"ExpD")==0 ||
4010         strcmp(opType,"LogD")==0 ||
4011         strcmp(opType,"Log10D")==0 ||
4012         strcmp(opType,"ModD")==0 ||
4013         strcmp(opType,"ModF")==0 ||
4014         strcmp(opType,"ModI")==0 ||
4015         strcmp(opType,"PowD")==0 ||
4016         strcmp(opType,"SinD")==0 ||
4017         strcmp(opType,"SqrtD")==0 ||
4018         strcmp(opType,"TanD")==0 ||
4019         strcmp(opType,"ConvD2F")==0 ||
4020         strcmp(opType,"ConvD2I")==0 ||
4021         strcmp(opType,"ConvD2L")==0 ||
4022         strcmp(opType,"ConvF2D")==0 ||
4023         strcmp(opType,"ConvF2I")==0 ||
4024         strcmp(opType,"ConvF2L")==0 ||
4025         strcmp(opType,"ConvI2D")==0 ||
4026         strcmp(opType,"ConvI2F")==0 ||
4027         strcmp(opType,"ConvI2L")==0 ||
4028         strcmp(opType,"ConvL2D")==0 ||
4029         strcmp(opType,"ConvL2F")==0 ||
4030         strcmp(opType,"ConvL2I")==0 ||
4031         strcmp(opType,"DecodeN")==0 ||
4032         strcmp(opType,"EncodeP")==0 ||
4033         strcmp(opType,"EncodePKlass")==0 ||
4034         strcmp(opType,"DecodeNKlass")==0 ||
4035         strcmp(opType,"RoundDouble")==0 ||
4036         strcmp(opType,"RoundFloat")==0 ||
4037         strcmp(opType,"ReverseBytesI")==0 ||
4038         strcmp(opType,"ReverseBytesL")==0 ||
4039         strcmp(opType,"ReverseBytesUS")==0 ||
4040         strcmp(opType,"ReverseBytesS")==0 ||
4041         strcmp(opType,"ReplicateB")==0 ||
4042         strcmp(opType,"ReplicateS")==0 ||
4043         strcmp(opType,"ReplicateI")==0 ||
4044         strcmp(opType,"ReplicateL")==0 ||
4045         strcmp(opType,"ReplicateF")==0 ||
4046         strcmp(opType,"ReplicateD")==0 ||
4047         0 /* 0 to line up columns nicely */ )
4048       return 1;
4049   }
4050   return 0;
4051 }
4052 
4053 bool MatchRule::is_ideal_if() const {
4054   if( !_opType ) return false;
4055   return
4056     !strcmp(_opType,"If"            ) ||
4057     !strcmp(_opType,"CountedLoopEnd");
4058 }
4059 
4060 bool MatchRule::is_ideal_fastlock() const {
4061   if ( _opType &amp;&amp; (strcmp(_opType,"Set") == 0) &amp;&amp; _rChild ) {
4062     return (strcmp(_rChild-&gt;_opType,"FastLock") == 0);
4063   }
4064   return false;
4065 }
4066 
4067 bool MatchRule::is_ideal_membar() const {
4068   if( !_opType ) return false;
4069   return
4070     !strcmp(_opType,"MemBarAcquire") ||
4071     !strcmp(_opType,"MemBarRelease") ||
4072     !strcmp(_opType,"MemBarAcquireLock") ||
4073     !strcmp(_opType,"MemBarReleaseLock") ||
4074     !strcmp(_opType,"LoadFence" ) ||
4075     !strcmp(_opType,"StoreFence") ||
4076     !strcmp(_opType,"MemBarVolatile") ||
4077     !strcmp(_opType,"MemBarCPUOrder") ||
4078     !strcmp(_opType,"MemBarStoreStore");
4079 }
4080 
4081 bool MatchRule::is_ideal_loadPC() const {
4082   if ( _opType &amp;&amp; (strcmp(_opType,"Set") == 0) &amp;&amp; _rChild ) {
4083     return (strcmp(_rChild-&gt;_opType,"LoadPC") == 0);
4084   }
4085   return false;
4086 }
4087 
4088 bool MatchRule::is_ideal_box() const {
4089   if ( _opType &amp;&amp; (strcmp(_opType,"Set") == 0) &amp;&amp; _rChild ) {
4090     return (strcmp(_rChild-&gt;_opType,"Box") == 0);
4091   }
4092   return false;
4093 }
4094 
4095 bool MatchRule::is_ideal_goto() const {
4096   bool   ideal_goto = false;
4097 
4098   if( _opType &amp;&amp; (strcmp(_opType,"Goto") == 0) ) {
4099     ideal_goto = true;
4100   }
4101   return ideal_goto;
4102 }
4103 
4104 bool MatchRule::is_ideal_jump() const {
4105   if( _opType ) {
4106     if( !strcmp(_opType,"Jump") )
4107       return true;
4108   }
4109   return false;
4110 }
4111 
4112 bool MatchRule::is_ideal_bool() const {
4113   if( _opType ) {
4114     if( !strcmp(_opType,"Bool") )
4115       return true;
4116   }
4117   return false;
4118 }
4119 
4120 
4121 Form::DataType MatchRule::is_ideal_load() const {
4122   Form::DataType ideal_load = Form::none;
4123 
4124   if ( _opType &amp;&amp; (strcmp(_opType,"Set") == 0) &amp;&amp; _rChild ) {
4125     const char *opType = _rChild-&gt;_opType;
4126     ideal_load = is_load_from_memory(opType);
4127   }
4128 
4129   return ideal_load;
4130 }
4131 
4132 bool MatchRule::is_vector() const {
4133   static const char *vector_list[] = {
4134     "AddVB","AddVS","AddVI","AddVL","AddVF","AddVD",
4135     "SubVB","SubVS","SubVI","SubVL","SubVF","SubVD",
4136     "MulVS","MulVI","MulVF","MulVD",
4137     "DivVF","DivVD",
4138     "AndV" ,"XorV" ,"OrV",
4139     "LShiftCntV","RShiftCntV",
4140     "LShiftVB","LShiftVS","LShiftVI","LShiftVL",
4141     "RShiftVB","RShiftVS","RShiftVI","RShiftVL",
4142     "URShiftVB","URShiftVS","URShiftVI","URShiftVL",
4143     "ReplicateB","ReplicateS","ReplicateI","ReplicateL","ReplicateF","ReplicateD",
4144     "LoadVector","StoreVector",
4145     // Next are not supported currently.
4146     "PackB","PackS","PackI","PackL","PackF","PackD","Pack2L","Pack2D",
4147     "ExtractB","ExtractUB","ExtractC","ExtractS","ExtractI","ExtractL","ExtractF","ExtractD"
4148   };
4149   int cnt = sizeof(vector_list)/sizeof(char*);
4150   if (_rChild) {
4151     const char  *opType = _rChild-&gt;_opType;
4152     for (int i=0; i&lt;cnt; i++)
4153       if (strcmp(opType,vector_list[i]) == 0)
4154         return true;
4155   }
4156   return false;
4157 }
4158 
4159 
4160 bool MatchRule::skip_antidep_check() const {
4161   // Some loads operate on what is effectively immutable memory so we
4162   // should skip the anti dep computations.  For some of these nodes
4163   // the rewritable field keeps the anti dep logic from triggering but
4164   // for certain kinds of LoadKlass it does not since they are
4165   // actually reading memory which could be rewritten by the runtime,
4166   // though never by generated code.  This disables it uniformly for
4167   // the nodes that behave like this: LoadKlass, LoadNKlass and
4168   // LoadRange.
4169   if ( _opType &amp;&amp; (strcmp(_opType,"Set") == 0) &amp;&amp; _rChild ) {
4170     const char *opType = _rChild-&gt;_opType;
4171     if (strcmp("LoadKlass", opType) == 0 ||
4172         strcmp("LoadNKlass", opType) == 0 ||
4173         strcmp("LoadRange", opType) == 0) {
4174       return true;
4175     }
4176   }
4177 
4178   return false;
4179 }
4180 
4181 
4182 Form::DataType MatchRule::is_ideal_store() const {
4183   Form::DataType ideal_store = Form::none;
4184 
4185   if ( _opType &amp;&amp; (strcmp(_opType,"Set") == 0) &amp;&amp; _rChild ) {
4186     const char *opType = _rChild-&gt;_opType;
4187     ideal_store = is_store_to_memory(opType);
4188   }
4189 
4190   return ideal_store;
4191 }
4192 
4193 
4194 void MatchRule::dump() {
4195   output(stderr);
4196 }
4197 
4198 // Write just one line.
4199 void MatchRule::output_short(FILE *fp) {
4200   fprintf(fp,"MatchRule: ( %s",_name);
4201   if (_lChild) _lChild-&gt;output(fp);
4202   if (_rChild) _rChild-&gt;output(fp);
4203   fprintf(fp," )");
4204 }
4205 
4206 void MatchRule::output(FILE *fp) {
4207   output_short(fp);
4208   fprintf(fp,"\n   nesting depth = %d\n", _depth);
4209   if (_result) fprintf(fp,"   Result Type = %s", _result);
4210   fprintf(fp,"\n");
4211 }
4212 
4213 //------------------------------Attribute--------------------------------------
4214 Attribute::Attribute(char *id, char* val, int type)
4215   : _ident(id), _val(val), _atype(type) {
4216 }
4217 Attribute::~Attribute() {
4218 }
4219 
4220 int Attribute::int_val(ArchDesc &amp;ad) {
4221   // Make sure it is an integer constant:
4222   int result = 0;
4223   if (!_val || !ADLParser::is_int_token(_val, result)) {
4224     ad.syntax_err(0, "Attribute %s must have an integer value: %s",
4225                   _ident, _val ? _val : "");
4226   }
4227   return result;
4228 }
4229 
4230 void Attribute::dump() {
4231   output(stderr);
4232 } // Debug printer
4233 
4234 // Write to output files
4235 void Attribute::output(FILE *fp) {
4236   fprintf(fp,"Attribute: %s  %s\n", (_ident?_ident:""), (_val?_val:""));
4237 }
4238 
4239 //------------------------------FormatRule----------------------------------
4240 FormatRule::FormatRule(char *temp)
4241   : _temp(temp) {
4242 }
4243 FormatRule::~FormatRule() {
4244 }
4245 
4246 void FormatRule::dump() {
4247   output(stderr);
4248 }
4249 
4250 // Write to output files
4251 void FormatRule::output(FILE *fp) {
4252   fprintf(fp,"\nFormat Rule: \n%s", (_temp?_temp:""));
4253   fprintf(fp,"\n");
4254 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
