<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/share/vm/classfile/javaClasses.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "classfile/altHashing.hpp"
  27 #include "classfile/javaClasses.hpp"
  28 #include "classfile/symbolTable.hpp"
  29 #include "classfile/vmSymbols.hpp"
  30 #include "code/debugInfo.hpp"
  31 #include "code/pcDesc.hpp"
  32 #include "compiler/compilerOracle.hpp"
  33 #include "interpreter/interpreter.hpp"
  34 #include "memory/oopFactory.hpp"
  35 #include "memory/resourceArea.hpp"
  36 #include "memory/universe.inline.hpp"
  37 #include "oops/fieldStreams.hpp"
  38 #include "oops/instanceKlass.hpp"
  39 #include "oops/instanceMirrorKlass.hpp"
  40 #include "oops/klass.hpp"
  41 #include "oops/method.hpp"
  42 #include "oops/symbol.hpp"
  43 #include "oops/typeArrayOop.hpp"
  44 #include "prims/jvmtiRedefineClassesTrace.hpp"
  45 #include "runtime/fieldDescriptor.hpp"
  46 #include "runtime/handles.inline.hpp"
  47 #include "runtime/interfaceSupport.hpp"
  48 #include "runtime/java.hpp"
  49 #include "runtime/javaCalls.hpp"
  50 #include "runtime/safepoint.hpp"
  51 #include "runtime/thread.inline.hpp"
  52 #include "runtime/vframe.hpp"
  53 #include "utilities/preserveException.hpp"
  54 
  55 PRAGMA_FORMAT_MUTE_WARNINGS_FOR_GCC
  56 
  57 #define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \
  58   klass::_##name##_offset = JavaClasses::compute_injected_offset(JavaClasses::klass##_##name##_enum);
  59 
  60 #define DECLARE_INJECTED_FIELD(klass, name, signature, may_be_java)           \
  61   { SystemDictionary::WK_KLASS_ENUM_NAME(klass), vmSymbols::VM_SYMBOL_ENUM_NAME(name##_name), vmSymbols::VM_SYMBOL_ENUM_NAME(signature), may_be_java },
  62 
  63 InjectedField JavaClasses::_injected_fields[] = {
  64   ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD)
  65 };
  66 
  67 int JavaClasses::compute_injected_offset(InjectedFieldID id) {
  68   return _injected_fields[id].compute_offset();
  69 }
  70 
  71 
  72 InjectedField* JavaClasses::get_injected(Symbol* class_name, int* field_count) {
  73   *field_count = 0;
  74 
  75   vmSymbols::SID sid = vmSymbols::find_sid(class_name);
  76   if (sid == vmSymbols::NO_SID) {
  77     // Only well known classes can inject fields
  78     return NULL;
  79   }
  80 
  81   int count = 0;
  82   int start = -1;
  83 
  84 #define LOOKUP_INJECTED_FIELD(klass, name, signature, may_be_java) \
  85   if (sid == vmSymbols::VM_SYMBOL_ENUM_NAME(klass)) {              \
  86     count++;                                                       \
  87     if (start == -1) start = klass##_##name##_enum;                \
  88   }
  89   ALL_INJECTED_FIELDS(LOOKUP_INJECTED_FIELD);
  90 #undef LOOKUP_INJECTED_FIELD
  91 
  92   if (start != -1) {
  93     *field_count = count;
  94     return _injected_fields + start;
  95   }
  96   return NULL;
  97 }
  98 
  99 
 100 static bool find_field(InstanceKlass* ik,
 101                        Symbol* name_symbol, Symbol* signature_symbol,
 102                        fieldDescriptor* fd,
 103                        bool allow_super = false) {
 104   if (allow_super)
 105     return ik-&gt;find_field(name_symbol, signature_symbol, fd) != NULL;
 106   else
 107     return ik-&gt;find_local_field(name_symbol, signature_symbol, fd);
 108 }
 109 
 110 // Helpful routine for computing field offsets at run time rather than hardcoding them
 111 static void
 112 compute_offset(int &amp;dest_offset,
 113                Klass* klass_oop, Symbol* name_symbol, Symbol* signature_symbol,
 114                bool allow_super = false) {
 115   fieldDescriptor fd;
 116   InstanceKlass* ik = InstanceKlass::cast(klass_oop);
 117   if (!find_field(ik, name_symbol, signature_symbol, &amp;fd, allow_super)) {
 118     ResourceMark rm;
 119     tty-&gt;print_cr("Invalid layout of %s at %s", ik-&gt;external_name(), name_symbol-&gt;as_C_string());
 120 #ifndef PRODUCT
 121     klass_oop-&gt;print();
 122     tty-&gt;print_cr("all fields:");
 123     for (AllFieldStream fs(InstanceKlass::cast(klass_oop)); !fs.done(); fs.next()) {
 124       tty-&gt;print_cr("  name: %s, sig: %s, flags: %08x", fs.name()-&gt;as_C_string(), fs.signature()-&gt;as_C_string(), fs.access_flags().as_int());
 125     }
 126 #endif //PRODUCT
 127     vm_exit_during_initialization("Invalid layout of preloaded class: use -XX:+TraceClassLoading to see the origin of the problem class");
 128   }
 129   dest_offset = fd.offset();
 130 }
 131 
 132 // Same as above but for "optional" offsets that might not be present in certain JDK versions
 133 static void
 134 compute_optional_offset(int&amp; dest_offset,
 135                         Klass* klass_oop, Symbol* name_symbol, Symbol* signature_symbol,
 136                         bool allow_super = false) {
 137   fieldDescriptor fd;
 138   InstanceKlass* ik = InstanceKlass::cast(klass_oop);
 139   if (find_field(ik, name_symbol, signature_symbol, &amp;fd, allow_super)) {
 140     dest_offset = fd.offset();
 141   }
 142 }
 143 
 144 
 145 int java_lang_String::value_offset  = 0;
 146 int java_lang_String::offset_offset = 0;
 147 int java_lang_String::count_offset  = 0;
 148 int java_lang_String::hash_offset   = 0;
 149 
 150 bool java_lang_String::initialized  = false;
 151 
 152 void java_lang_String::compute_offsets() {
 153   assert(!initialized, "offsets should be initialized only once");
 154 
 155   Klass* k = SystemDictionary::String_klass();
 156   compute_offset(value_offset,           k, vmSymbols::value_name(),  vmSymbols::char_array_signature());
 157   compute_optional_offset(offset_offset, k, vmSymbols::offset_name(), vmSymbols::int_signature());
 158   compute_optional_offset(count_offset,  k, vmSymbols::count_name(),  vmSymbols::int_signature());
 159   compute_optional_offset(hash_offset,   k, vmSymbols::hash_name(),   vmSymbols::int_signature());
 160 
 161   initialized = true;
 162 }
 163 
 164 Handle java_lang_String::basic_create(int length, TRAPS) {
 165   assert(initialized, "Must be initialized");
 166   // Create the String object first, so there's a chance that the String
 167   // and the char array it points to end up in the same cache line.
 168   oop obj;
 169   obj = InstanceKlass::cast(SystemDictionary::String_klass())-&gt;allocate_instance(CHECK_NH);
 170 
 171   // Create the char array.  The String object must be handlized here
 172   // because GC can happen as a result of the allocation attempt.
 173   Handle h_obj(THREAD, obj);
 174   typeArrayOop buffer;
 175     buffer = oopFactory::new_charArray(length, CHECK_NH);
 176 
 177   // Point the String at the char array
 178   obj = h_obj();
 179   set_value(obj, buffer);
 180   // No need to zero the offset, allocation zero'ed the entire String object
 181   assert(offset(obj) == 0, "initial String offset should be zero");
 182 //set_offset(obj, 0);
 183   set_count(obj, length);
 184 
 185   return h_obj;
 186 }
 187 
 188 Handle java_lang_String::create_from_unicode(jchar* unicode, int length, TRAPS) {
 189   Handle h_obj = basic_create(length, CHECK_NH);
 190   typeArrayOop buffer = value(h_obj());
 191   for (int index = 0; index &lt; length; index++) {
 192     buffer-&gt;char_at_put(index, unicode[index]);
 193   }
 194   return h_obj;
 195 }
 196 
 197 oop java_lang_String::create_oop_from_unicode(jchar* unicode, int length, TRAPS) {
 198   Handle h_obj = create_from_unicode(unicode, length, CHECK_0);
 199   return h_obj();
 200 }
 201 
 202 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 203   if (utf8_str == NULL) {
 204     return Handle();
 205   }
 206   int length = UTF8::unicode_length(utf8_str);
 207   Handle h_obj = basic_create(length, CHECK_NH);
 208   if (length &gt; 0) {
 209     UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 210   }
 211   return h_obj;
 212 }
 213 
 214 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
 215   Handle h_obj = create_from_str(utf8_str, CHECK_0);
 216   return h_obj();
 217 }
 218 
 219 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 220   int length = UTF8::unicode_length((char*)symbol-&gt;bytes(), symbol-&gt;utf8_length());
 221   Handle h_obj = basic_create(length, CHECK_NH);
 222   if (length &gt; 0) {
 223     UTF8::convert_to_unicode((char*)symbol-&gt;bytes(), value(h_obj())-&gt;char_at_addr(0), length);
 224   }
 225   return h_obj;
 226 }
 227 
 228 // Converts a C string to a Java String based on current encoding
 229 Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
 230   assert(str != NULL, "bad arguments");
 231 
 232   typedef jstring (*to_java_string_fn_t)(JNIEnv*, const char *);
 233   static to_java_string_fn_t _to_java_string_fn = NULL;
 234 
 235   if (_to_java_string_fn == NULL) {
 236     void *lib_handle = os::native_java_library();
 237     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, "NewStringPlatform"));
 238     if (_to_java_string_fn == NULL) {
 239       fatal("NewStringPlatform missing");
 240     }
 241   }
 242 
 243   jstring js = NULL;
 244   { JavaThread* thread = (JavaThread*)THREAD;
 245     assert(thread-&gt;is_Java_thread(), "must be java thread");
 246     HandleMark hm(thread);
 247     ThreadToNativeFromVM ttn(thread);
 248     js = (_to_java_string_fn)(thread-&gt;jni_environment(), str);
 249   }
 250   return Handle(THREAD, JNIHandles::resolve(js));
 251 }
 252 
 253 // Converts a Java String to a native C string that can be used for
 254 // native OS calls.
 255 char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
 256 
 257   typedef char* (*to_platform_string_fn_t)(JNIEnv*, jstring, bool*);
 258   static to_platform_string_fn_t _to_platform_string_fn = NULL;
 259 
 260   if (_to_platform_string_fn == NULL) {
 261     void *lib_handle = os::native_java_library();
 262     _to_platform_string_fn = CAST_TO_FN_PTR(to_platform_string_fn_t, os::dll_lookup(lib_handle, "GetStringPlatformChars"));
 263     if (_to_platform_string_fn == NULL) {
 264       fatal("GetStringPlatformChars missing");
 265     }
 266   }
 267 
 268   char *native_platform_string;
 269   { JavaThread* thread = (JavaThread*)THREAD;
 270     assert(thread-&gt;is_Java_thread(), "must be java thread");
 271     JNIEnv *env = thread-&gt;jni_environment();
 272     jstring js = (jstring) JNIHandles::make_local(env, java_string());
 273     bool is_copy;
 274     HandleMark hm(thread);
 275     ThreadToNativeFromVM ttn(thread);
 276     native_platform_string = (_to_platform_string_fn)(env, js, &amp;is_copy);
 277     assert(is_copy == JNI_TRUE, "is_copy value changed");
 278     JNIHandles::destroy_local(js);
 279   }
 280   return native_platform_string;
 281 }
 282 
 283 Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {
 284   oop          obj    = java_string();
 285   // Typical usage is to convert all '/' to '.' in string.
 286   typeArrayOop value  = java_lang_String::value(obj);
 287   int          offset = java_lang_String::offset(obj);
 288   int          length = java_lang_String::length(obj);
 289 
 290   // First check if any from_char exist
 291   int index; // Declared outside, used later
 292   for (index = 0; index &lt; length; index++) {
 293     if (value-&gt;char_at(index + offset) == from_char) {
 294       break;
 295     }
 296   }
 297   if (index == length) {
 298     // No from_char, so do not copy.
 299     return java_string;
 300   }
 301 
 302   // Create new UNICODE buffer. Must handlize value because GC
 303   // may happen during String and char array creation.
 304   typeArrayHandle h_value(THREAD, value);
 305   Handle string = basic_create(length, CHECK_NH);
 306 
 307   typeArrayOop from_buffer = h_value();
 308   typeArrayOop to_buffer   = java_lang_String::value(string());
 309 
 310   // Copy contents
 311   for (index = 0; index &lt; length; index++) {
 312     jchar c = from_buffer-&gt;char_at(index + offset);
 313     if (c == from_char) {
 314       c = to_char;
 315     }
 316     to_buffer-&gt;char_at_put(index, c);
 317   }
 318   return string;
 319 }
 320 
 321 jchar* java_lang_String::as_unicode_string(oop java_string, int&amp; length, TRAPS) {
 322   typeArrayOop value  = java_lang_String::value(java_string);
 323   int          offset = java_lang_String::offset(java_string);
 324                length = java_lang_String::length(java_string);
 325 
 326   jchar* result = NEW_RESOURCE_ARRAY_RETURN_NULL(jchar, length);
 327   if (result != NULL) {
 328     for (int index = 0; index &lt; length; index++) {
 329       result[index] = value-&gt;char_at(index + offset);
 330     }
 331   } else {
 332     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), "could not allocate Unicode string");
 333   }
 334   return result;
 335 }
 336 
 337 unsigned int java_lang_String::hash_code(oop java_string) {
 338   int          length = java_lang_String::length(java_string);
 339   // Zero length string will hash to zero with String.hashCode() function.
 340   if (length == 0) return 0;
 341 
 342   typeArrayOop value  = java_lang_String::value(java_string);
 343   int          offset = java_lang_String::offset(java_string);
 344   return java_lang_String::hash_code(value-&gt;char_at_addr(offset), length);
 345 }
 346 
 347 char* java_lang_String::as_quoted_ascii(oop java_string) {
 348   typeArrayOop value  = java_lang_String::value(java_string);
 349   int          offset = java_lang_String::offset(java_string);
 350   int          length = java_lang_String::length(java_string);
 351 
 352   jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(offset);
 353   if (base == NULL) return NULL;
 354 
 355   int result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 356   char* result = NEW_RESOURCE_ARRAY(char, result_length);
 357   UNICODE::as_quoted_ascii(base, length, result, result_length);
 358   assert(result_length &gt;= length + 1, "must not be shorter");
 359   assert(result_length == (int)strlen(result) + 1, "must match");
 360   return result;
 361 }
 362 
 363 unsigned int java_lang_String::hash_string(oop java_string) {
 364   int          length = java_lang_String::length(java_string);
 365   // Zero length string doesn't hash necessarily hash to zero.
 366   if (length == 0) {
 367     return StringTable::hash_string(NULL, 0);
 368   }
 369 
 370   typeArrayOop value  = java_lang_String::value(java_string);
 371   int          offset = java_lang_String::offset(java_string);
 372   return StringTable::hash_string(value-&gt;char_at_addr(offset), length);
 373 }
 374 
 375 Symbol* java_lang_String::as_symbol(Handle java_string, TRAPS) {
 376   oop          obj    = java_string();
 377   typeArrayOop value  = java_lang_String::value(obj);
 378   int          offset = java_lang_String::offset(obj);
 379   int          length = java_lang_String::length(obj);
 380   jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(offset);
 381   Symbol* sym = SymbolTable::lookup_unicode(base, length, THREAD);
 382   return sym;
 383 }
 384 
 385 Symbol* java_lang_String::as_symbol_or_null(oop java_string) {
 386   typeArrayOop value  = java_lang_String::value(java_string);
 387   int          offset = java_lang_String::offset(java_string);
 388   int          length = java_lang_String::length(java_string);
 389   jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(offset);
 390   return SymbolTable::probe_unicode(base, length);
 391 }
 392 
 393 
 394 int java_lang_String::utf8_length(oop java_string) {
 395   typeArrayOop value  = java_lang_String::value(java_string);
 396   int          offset = java_lang_String::offset(java_string);
 397   int          length = java_lang_String::length(java_string);
 398   jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(offset);
 399   return UNICODE::utf8_length(position, length);
 400 }
 401 
 402 char* java_lang_String::as_utf8_string(oop java_string) {
 403   typeArrayOop value  = java_lang_String::value(java_string);
 404   int          offset = java_lang_String::offset(java_string);
 405   int          length = java_lang_String::length(java_string);
 406   jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(offset);
 407   return UNICODE::as_utf8(position, length);
 408 }
 409 
 410 char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {
 411   typeArrayOop value  = java_lang_String::value(java_string);
 412   int          offset = java_lang_String::offset(java_string);
 413   int          length = java_lang_String::length(java_string);
 414   jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(offset);
 415   return UNICODE::as_utf8(position, length, buf, buflen);
 416 }
 417 
 418 char* java_lang_String::as_utf8_string(oop java_string, int start, int len) {
 419   typeArrayOop value  = java_lang_String::value(java_string);
 420   int          offset = java_lang_String::offset(java_string);
 421   int          length = java_lang_String::length(java_string);
 422   assert(start + len &lt;= length, "just checking");
 423   jchar* position = value-&gt;char_at_addr(offset + start);
 424   return UNICODE::as_utf8(position, len);
 425 }
 426 
 427 bool java_lang_String::equals(oop java_string, jchar* chars, int len) {
 428   assert(java_string-&gt;klass() == SystemDictionary::String_klass(),
 429          "must be java_string");
 430   typeArrayOop value  = java_lang_String::value(java_string);
 431   int          offset = java_lang_String::offset(java_string);
 432   int          length = java_lang_String::length(java_string);
 433   if (length != len) {
 434     return false;
 435   }
 436   for (int i = 0; i &lt; len; i++) {
 437     if (value-&gt;char_at(i + offset) != chars[i]) {
 438       return false;
 439     }
 440   }
 441   return true;
 442 }
 443 
 444 bool java_lang_String::equals(oop str1, oop str2) {
 445   assert(str1-&gt;klass() == SystemDictionary::String_klass(),
 446          "must be java String");
 447   assert(str2-&gt;klass() == SystemDictionary::String_klass(),
 448          "must be java String");
 449   typeArrayOop value1  = java_lang_String::value(str1);
 450   int          offset1 = java_lang_String::offset(str1);
 451   int          length1 = java_lang_String::length(str1);
 452   typeArrayOop value2  = java_lang_String::value(str2);
 453   int          offset2 = java_lang_String::offset(str2);
 454   int          length2 = java_lang_String::length(str2);
 455 
 456   if (length1 != length2) {
 457     return false;
 458   }
 459   for (int i = 0; i &lt; length1; i++) {
 460     if (value1-&gt;char_at(i + offset1) != value2-&gt;char_at(i + offset2)) {
 461       return false;
 462     }
 463   }
 464   return true;
 465 }
 466 
 467 void java_lang_String::print(oop java_string, outputStream* st) {
 468   assert(java_string-&gt;klass() == SystemDictionary::String_klass(), "must be java_string");
 469   typeArrayOop value  = java_lang_String::value(java_string);
 470   int          offset = java_lang_String::offset(java_string);
 471   int          length = java_lang_String::length(java_string);
 472 
 473   int end = MIN2(length, 100);
 474   if (value == NULL) {
 475     // This can happen if, e.g., printing a String
 476     // object before its initializer has been called
 477     st-&gt;print_cr("NULL");
 478   } else {
 479     st-&gt;print("\"");
 480     for (int index = 0; index &lt; length; index++) {
 481       st-&gt;print("%c", value-&gt;char_at(index + offset));
 482     }
 483     st-&gt;print("\"");
 484   }
 485 }
 486 
 487 
 488 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 489   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), "just checking");
 490   if (fd-&gt;has_initial_value()) {
 491     BasicType t = fd-&gt;field_type();
 492     switch (t) {
 493       case T_BYTE:
 494         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 495               break;
 496       case T_BOOLEAN:
 497         mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 498               break;
 499       case T_CHAR:
 500         mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 501               break;
 502       case T_SHORT:
 503         mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 504               break;
 505       case T_INT:
 506         mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 507         break;
 508       case T_FLOAT:
 509         mirror()-&gt;float_field_put(fd-&gt;offset(), fd-&gt;float_initial_value());
 510         break;
 511       case T_DOUBLE:
 512         mirror()-&gt;double_field_put(fd-&gt;offset(), fd-&gt;double_initial_value());
 513         break;
 514       case T_LONG:
 515         mirror()-&gt;long_field_put(fd-&gt;offset(), fd-&gt;long_initial_value());
 516         break;
 517       case T_OBJECT:
 518         {
 519           #ifdef ASSERT
 520           TempNewSymbol sym = SymbolTable::new_symbol("Ljava/lang/String;", CHECK);
 521           assert(fd-&gt;signature() == sym, "just checking");
 522           #endif
 523           oop string = fd-&gt;string_initial_value(CHECK);
 524           mirror()-&gt;obj_field_put(fd-&gt;offset(), string);
 525         }
 526         break;
 527       default:
 528         THROW_MSG(vmSymbols::java_lang_ClassFormatError(),
 529                   "Illegal ConstantValue attribute in class file");
 530     }
 531   }
 532 }
 533 
 534 
 535 void java_lang_Class::fixup_mirror(KlassHandle k, TRAPS) {
 536   assert(InstanceMirrorKlass::offset_of_static_fields() != 0, "must have been computed already");
 537 
 538   // If the offset was read from the shared archive, it was fixed up already
 539   if (!k-&gt;is_shared()) {
 540     if (k-&gt;oop_is_instance()) {
 541       // During bootstrap, java.lang.Class wasn't loaded so static field
 542       // offsets were computed without the size added it.  Go back and
 543       // update all the static field offsets to included the size.
 544         for (JavaFieldStream fs(InstanceKlass::cast(k())); !fs.done(); fs.next()) {
 545         if (fs.access_flags().is_static()) {
 546           int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();
 547           fs.set_offset(real_offset);
 548         }
 549       }
 550     }
 551   }
 552   create_mirror(k, Handle(NULL), Handle(NULL), CHECK);
 553 }
 554 
 555 void java_lang_Class::initialize_mirror_fields(KlassHandle k,
 556                                                Handle mirror,
 557                                                Handle protection_domain,
 558                                                TRAPS) {
 559   // Allocate a simple java object for a lock.
 560   // This needs to be a java object because during class initialization
 561   // it can be held across a java call.
 562   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 563   set_init_lock(mirror(), r);
 564 
 565   // Set protection domain also
 566   set_protection_domain(mirror(), protection_domain());
 567 
 568   // Initialize static fields
 569   InstanceKlass::cast(k())-&gt;do_local_static_fields(&amp;initialize_static_field, mirror, CHECK);
 570 }
 571 
 572 void java_lang_Class::create_mirror(KlassHandle k, Handle class_loader,
 573                                     Handle protection_domain, TRAPS) {
 574   assert(k-&gt;java_mirror() == NULL, "should only assign mirror once");
 575   // Use this moment of initialization to cache modifier_flags also,
 576   // to support Class.getModifiers().  Instance classes recalculate
 577   // the cached flags after the class file is parsed, but before the
 578   // class is put into the system dictionary.
 579   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 580   k-&gt;set_modifier_flags(computed_modifiers);
 581   // Class_klass has to be loaded because it is used to allocate
 582   // the mirror.
 583   if (SystemDictionary::Class_klass_loaded()) {
 584     // Allocate mirror (java.lang.Class instance)
 585     Handle mirror = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 586 
 587     // Setup indirection from mirror-&gt;klass
 588     if (!k.is_null()) {
 589       java_lang_Class::set_klass(mirror(), k());
 590     }
 591 
 592     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 593     assert(oop_size(mirror()) == mk-&gt;instance_size(k), "should have been set");
 594 
 595     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 596 
 597     // It might also have a component mirror.  This mirror must already exist.
 598     if (k-&gt;oop_is_array()) {
 599       Handle comp_mirror;
 600       if (k-&gt;oop_is_typeArray()) {
 601         BasicType type = TypeArrayKlass::cast(k())-&gt;element_type();
 602         comp_mirror = Universe::java_mirror(type);
 603       } else {
 604         assert(k-&gt;oop_is_objArray(), "Must be");
 605         Klass* element_klass = ObjArrayKlass::cast(k())-&gt;element_klass();
 606         assert(element_klass != NULL, "Must have an element klass");
 607         comp_mirror = element_klass-&gt;java_mirror();
 608       }
 609       assert(comp_mirror.not_null(), "must have a mirror");
 610 
 611       // Two-way link between the array klass and its component mirror:
 612       ArrayKlass::cast(k())-&gt;set_component_mirror(comp_mirror());
 613       set_array_klass(comp_mirror(), k());
 614     } else {
 615       assert(k-&gt;oop_is_instance(), "Must be");
 616 
 617       initialize_mirror_fields(k, mirror, protection_domain, THREAD);
 618       if (HAS_PENDING_EXCEPTION) {
 619         // If any of the fields throws an exception like OOM remove the klass field
 620         // from the mirror so GC doesn't follow it after the klass has been deallocated.
 621         // This mirror looks like a primitive type, which logically it is because it
 622         // it represents no class.
 623         java_lang_Class::set_klass(mirror(), NULL);
 624         return;
 625       }
 626     }
 627 
 628     // set the classLoader field in the java_lang_Class instance
 629     assert(class_loader() == k-&gt;class_loader(), "should be same");
 630     set_class_loader(mirror(), class_loader());
 631 
 632     // Setup indirection from klass-&gt;mirror last
 633     // after any exceptions can happen during allocations.
 634     if (!k.is_null()) {
 635       k-&gt;set_java_mirror(mirror());
 636     }
 637   } else {
 638     if (fixup_mirror_list() == NULL) {
 639       GrowableArray&lt;Klass*&gt;* list =
 640        new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(40, true);
 641       set_fixup_mirror_list(list);
 642     }
 643     fixup_mirror_list()-&gt;push(k());
 644   }
 645 }
 646 
 647 
 648 int  java_lang_Class::oop_size(oop java_class) {
 649   assert(_oop_size_offset != 0, "must be set");
 650   return java_class-&gt;int_field(_oop_size_offset);
 651 }
 652 void java_lang_Class::set_oop_size(oop java_class, int size) {
 653   assert(_oop_size_offset != 0, "must be set");
 654   java_class-&gt;int_field_put(_oop_size_offset, size);
 655 }
 656 int  java_lang_Class::static_oop_field_count(oop java_class) {
 657   assert(_static_oop_field_count_offset != 0, "must be set");
 658   return java_class-&gt;int_field(_static_oop_field_count_offset);
 659 }
 660 void java_lang_Class::set_static_oop_field_count(oop java_class, int size) {
 661   assert(_static_oop_field_count_offset != 0, "must be set");
 662   java_class-&gt;int_field_put(_static_oop_field_count_offset, size);
 663 }
 664 
 665 oop java_lang_Class::protection_domain(oop java_class) {
 666   assert(_protection_domain_offset != 0, "must be set");
 667   return java_class-&gt;obj_field(_protection_domain_offset);
 668 }
 669 void java_lang_Class::set_protection_domain(oop java_class, oop pd) {
 670   assert(_protection_domain_offset != 0, "must be set");
 671   java_class-&gt;obj_field_put(_protection_domain_offset, pd);
 672 }
 673 
 674 oop java_lang_Class::init_lock(oop java_class) {
 675   assert(_init_lock_offset != 0, "must be set");
 676   return java_class-&gt;obj_field(_init_lock_offset);
 677 }
 678 void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {
 679   assert(_init_lock_offset != 0, "must be set");
 680   java_class-&gt;obj_field_put(_init_lock_offset, init_lock);
 681 }
 682 
 683 objArrayOop java_lang_Class::signers(oop java_class) {
 684   assert(_signers_offset != 0, "must be set");
 685   return (objArrayOop)java_class-&gt;obj_field(_signers_offset);
 686 }
 687 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
 688   assert(_signers_offset != 0, "must be set");
 689   java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
 690 }
 691 
 692 
 693 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
 694   // jdk7 runs Queens in bootstrapping and jdk8-9 has no coordinated pushes yet.
 695   if (_class_loader_offset != 0) {
 696     java_class-&gt;obj_field_put(_class_loader_offset, loader);
 697   }
 698 }
 699 
 700 oop java_lang_Class::class_loader(oop java_class) {
 701   assert(_class_loader_offset != 0, "must be set");
 702   return java_class-&gt;obj_field(_class_loader_offset);
 703 }
 704 
 705 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
 706   // This should be improved by adding a field at the Java level or by
 707   // introducing a new VM klass (see comment in ClassFileParser)
 708   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_0);
 709   if (type != T_VOID) {
 710     Klass* aklass = Universe::typeArrayKlassObj(type);
 711     assert(aklass != NULL, "correct bootstrap");
 712     set_array_klass(java_class, aklass);
 713   }
 714 #ifdef ASSERT
 715   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
 716   assert(java_lang_Class::static_oop_field_count(java_class) == 0, "should have been zeroed by allocation");
 717 #endif
 718   return java_class;
 719 }
 720 
 721 
 722 Klass* java_lang_Class::as_Klass(oop java_class) {
 723   //%note memory_2
 724   assert(java_lang_Class::is_instance(java_class), "must be a Class object");
 725   Klass* k = ((Klass*)java_class-&gt;metadata_field(_klass_offset));
 726   assert(k == NULL || k-&gt;is_klass(), "type check");
 727   return k;
 728 }
 729 
 730 
 731 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
 732   assert(java_lang_Class::is_instance(java_class), "must be a Class object");
 733   java_class-&gt;metadata_field_put(_klass_offset, klass);
 734 }
 735 
 736 
 737 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
 738   assert(java_lang_Class::is_instance(java_class), "must be a Class object");
 739   Symbol* name = NULL;
 740   bool is_instance = false;
 741   if (is_primitive(java_class)) {
 742     name = vmSymbols::type_signature(primitive_type(java_class));
 743   } else {
 744     Klass* k = as_Klass(java_class);
 745     is_instance = k-&gt;oop_is_instance();
 746     name = k-&gt;name();
 747   }
 748   if (name == NULL) {
 749     st-&gt;print("&lt;null&gt;");
 750     return;
 751   }
 752   if (is_instance)  st-&gt;print("L");
 753   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
 754   if (is_instance)  st-&gt;print(";");
 755 }
 756 
 757 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found, TRAPS) {
 758   assert(java_lang_Class::is_instance(java_class), "must be a Class object");
 759   Symbol* name;
 760   if (is_primitive(java_class)) {
 761     name = vmSymbols::type_signature(primitive_type(java_class));
 762     // Because this can create a new symbol, the caller has to decrement
 763     // the refcount, so make adjustment here and below for symbols returned
 764     // that are not created or incremented due to a successful lookup.
 765     name-&gt;increment_refcount();
 766   } else {
 767     Klass* k = as_Klass(java_class);
 768     if (!k-&gt;oop_is_instance()) {
 769       name = k-&gt;name();
 770       name-&gt;increment_refcount();
 771     } else {
 772       ResourceMark rm;
 773       const char* sigstr = k-&gt;signature_name();
 774       int         siglen = (int) strlen(sigstr);
 775       if (!intern_if_not_found) {
 776         name = SymbolTable::probe(sigstr, siglen);
 777       } else {
 778         name = SymbolTable::new_symbol(sigstr, siglen, THREAD);
 779       }
 780     }
 781   }
 782   return name;
 783 }
 784 
 785 
 786 Klass* java_lang_Class::array_klass(oop java_class) {
 787   Klass* k = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
 788   assert(k == NULL || k-&gt;is_klass() &amp;&amp; k-&gt;oop_is_array(), "should be array klass");
 789   return k;
 790 }
 791 
 792 
 793 void java_lang_Class::set_array_klass(oop java_class, Klass* klass) {
 794   assert(klass-&gt;is_klass() &amp;&amp; klass-&gt;oop_is_array(), "should be array klass");
 795   java_class-&gt;metadata_field_put(_array_klass_offset, klass);
 796 }
 797 
 798 
 799 bool java_lang_Class::is_primitive(oop java_class) {
 800   // should assert:
 801   //assert(java_lang_Class::is_instance(java_class), "must be a Class object");
 802   bool is_primitive = (java_class-&gt;metadata_field(_klass_offset) == NULL);
 803 
 804 #ifdef ASSERT
 805   if (is_primitive) {
 806     Klass* k = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
 807     assert(k == NULL || is_java_primitive(ArrayKlass::cast(k)-&gt;element_type()),
 808         "Should be either the T_VOID primitive or a java primitive");
 809   }
 810 #endif
 811 
 812   return is_primitive;
 813 }
 814 
 815 
 816 BasicType java_lang_Class::primitive_type(oop java_class) {
 817   assert(java_lang_Class::is_primitive(java_class), "just checking");
 818   Klass* ak = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
 819   BasicType type = T_VOID;
 820   if (ak != NULL) {
 821     // Note: create_basic_type_mirror above initializes ak to a non-null value.
 822     type = ArrayKlass::cast(ak)-&gt;element_type();
 823   } else {
 824     assert(java_class == Universe::void_mirror(), "only valid non-array primitive");
 825   }
 826   assert(Universe::java_mirror(type) == java_class, "must be consistent");
 827   return type;
 828 }
 829 
 830 BasicType java_lang_Class::as_BasicType(oop java_class, Klass** reference_klass) {
 831   assert(java_lang_Class::is_instance(java_class), "must be a Class object");
 832   if (is_primitive(java_class)) {
 833     if (reference_klass != NULL)
 834       (*reference_klass) = NULL;
 835     return primitive_type(java_class);
 836   } else {
 837     if (reference_klass != NULL)
 838       (*reference_klass) = as_Klass(java_class);
 839     return T_OBJECT;
 840   }
 841 }
 842 
 843 
 844 oop java_lang_Class::primitive_mirror(BasicType t) {
 845   oop mirror = Universe::java_mirror(t);
 846   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), "must be a Class");
 847   assert(java_lang_Class::is_primitive(mirror), "must be primitive");
 848   return mirror;
 849 }
 850 
 851 bool java_lang_Class::offsets_computed = false;
 852 int  java_lang_Class::classRedefinedCount_offset = -1;
 853 
 854 void java_lang_Class::compute_offsets() {
 855   assert(!offsets_computed, "offsets should be initialized only once");
 856   offsets_computed = true;
 857 
 858   Klass* klass_oop = SystemDictionary::Class_klass();
 859   // The classRedefinedCount field is only present starting in 1.5,
 860   // so don't go fatal.
 861   compute_optional_offset(classRedefinedCount_offset,
 862                           klass_oop, vmSymbols::classRedefinedCount_name(), vmSymbols::int_signature());
 863 
 864   // Needs to be optional because the old build runs Queens during bootstrapping
 865   // and jdk8-9 doesn't have coordinated pushes yet.
 866   compute_optional_offset(_class_loader_offset,
 867                  klass_oop, vmSymbols::classLoader_name(),
 868                  vmSymbols::classloader_signature());
 869 
 870   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
 871 }
 872 
 873 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
 874   if (!JDK_Version::is_gte_jdk15x_version()
 875       || classRedefinedCount_offset == -1) {
 876     // The classRedefinedCount field is only present starting in 1.5.
 877     // If we don't have an offset for it then just return -1 as a marker.
 878     return -1;
 879   }
 880 
 881   return the_class_mirror-&gt;int_field(classRedefinedCount_offset);
 882 }
 883 
 884 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
 885   if (!JDK_Version::is_gte_jdk15x_version()
 886       || classRedefinedCount_offset == -1) {
 887     // The classRedefinedCount field is only present starting in 1.5.
 888     // If we don't have an offset for it then nothing to set.
 889     return;
 890   }
 891 
 892   the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);
 893 }
 894 
 895 
 896 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
 897 //       platform thread structure, and a eetop offset which was used for thread
 898 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
 899 //       merged, so in the HotSpot VM we just use the eetop field for the thread
 900 //       instead of the privateInfo_offset.
 901 //
 902 // Note: The stackSize field is only present starting in 1.4.
 903 
 904 int java_lang_Thread::_name_offset = 0;
 905 int java_lang_Thread::_group_offset = 0;
 906 int java_lang_Thread::_contextClassLoader_offset = 0;
 907 int java_lang_Thread::_inheritedAccessControlContext_offset = 0;
 908 int java_lang_Thread::_priority_offset = 0;
 909 int java_lang_Thread::_eetop_offset = 0;
 910 int java_lang_Thread::_daemon_offset = 0;
 911 int java_lang_Thread::_stillborn_offset = 0;
 912 int java_lang_Thread::_stackSize_offset = 0;
 913 int java_lang_Thread::_tid_offset = 0;
 914 int java_lang_Thread::_thread_status_offset = 0;
 915 int java_lang_Thread::_park_blocker_offset = 0;
 916 int java_lang_Thread::_park_event_offset = 0 ;
 917 
 918 
 919 void java_lang_Thread::compute_offsets() {
 920   assert(_group_offset == 0, "offsets should be initialized only once");
 921 
 922   Klass* k = SystemDictionary::Thread_klass();
 923   compute_offset(_name_offset,      k, vmSymbols::name_name(),      vmSymbols::char_array_signature());
 924   compute_offset(_group_offset,     k, vmSymbols::group_name(),     vmSymbols::threadgroup_signature());
 925   compute_offset(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), vmSymbols::classloader_signature());
 926   compute_offset(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), vmSymbols::accesscontrolcontext_signature());
 927   compute_offset(_priority_offset,  k, vmSymbols::priority_name(),  vmSymbols::int_signature());
 928   compute_offset(_daemon_offset,    k, vmSymbols::daemon_name(),    vmSymbols::bool_signature());
 929   compute_offset(_eetop_offset,     k, vmSymbols::eetop_name(),     vmSymbols::long_signature());
 930   compute_offset(_stillborn_offset, k, vmSymbols::stillborn_name(), vmSymbols::bool_signature());
 931   // The stackSize field is only present starting in 1.4, so don't go fatal.
 932   compute_optional_offset(_stackSize_offset, k, vmSymbols::stackSize_name(), vmSymbols::long_signature());
 933   // The tid and thread_status fields are only present starting in 1.5, so don't go fatal.
 934   compute_optional_offset(_tid_offset, k, vmSymbols::thread_id_name(), vmSymbols::long_signature());
 935   compute_optional_offset(_thread_status_offset, k, vmSymbols::thread_status_name(), vmSymbols::int_signature());
 936   // The parkBlocker field is only present starting in 1.6, so don't go fatal.
 937   compute_optional_offset(_park_blocker_offset, k, vmSymbols::park_blocker_name(), vmSymbols::object_signature());
 938   compute_optional_offset(_park_event_offset, k, vmSymbols::park_event_name(),
 939  vmSymbols::long_signature());
 940 }
 941 
 942 
 943 JavaThread* java_lang_Thread::thread(oop java_thread) {
 944   return (JavaThread*)java_thread-&gt;address_field(_eetop_offset);
 945 }
 946 
 947 
 948 void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {
 949   java_thread-&gt;address_field_put(_eetop_offset, (address)thread);
 950 }
 951 
 952 
 953 typeArrayOop java_lang_Thread::name(oop java_thread) {
 954   oop name = java_thread-&gt;obj_field(_name_offset);
 955   assert(name == NULL || (name-&gt;is_typeArray() &amp;&amp; TypeArrayKlass::cast(name-&gt;klass())-&gt;element_type() == T_CHAR), "just checking");
 956   return typeArrayOop(name);
 957 }
 958 
 959 
 960 void java_lang_Thread::set_name(oop java_thread, typeArrayOop name) {
 961   assert(java_thread-&gt;obj_field(_name_offset) == NULL, "name should be NULL");
 962   java_thread-&gt;obj_field_put(_name_offset, name);
 963 }
 964 
 965 
 966 ThreadPriority java_lang_Thread::priority(oop java_thread) {
 967   return (ThreadPriority)java_thread-&gt;int_field(_priority_offset);
 968 }
 969 
 970 
 971 void java_lang_Thread::set_priority(oop java_thread, ThreadPriority priority) {
 972   java_thread-&gt;int_field_put(_priority_offset, priority);
 973 }
 974 
 975 
 976 oop java_lang_Thread::threadGroup(oop java_thread) {
 977   return java_thread-&gt;obj_field(_group_offset);
 978 }
 979 
 980 
 981 bool java_lang_Thread::is_stillborn(oop java_thread) {
 982   return java_thread-&gt;bool_field(_stillborn_offset) != 0;
 983 }
 984 
 985 
 986 // We never have reason to turn the stillborn bit off
 987 void java_lang_Thread::set_stillborn(oop java_thread) {
 988   java_thread-&gt;bool_field_put(_stillborn_offset, true);
 989 }
 990 
 991 
 992 bool java_lang_Thread::is_alive(oop java_thread) {
 993   JavaThread* thr = java_lang_Thread::thread(java_thread);
 994   return (thr != NULL);
 995 }
 996 
 997 
 998 bool java_lang_Thread::is_daemon(oop java_thread) {
 999   return java_thread-&gt;bool_field(_daemon_offset) != 0;
1000 }
1001 
1002 
1003 void java_lang_Thread::set_daemon(oop java_thread) {
1004   java_thread-&gt;bool_field_put(_daemon_offset, true);
1005 }
1006 
1007 oop java_lang_Thread::context_class_loader(oop java_thread) {
1008   return java_thread-&gt;obj_field(_contextClassLoader_offset);
1009 }
1010 
1011 oop java_lang_Thread::inherited_access_control_context(oop java_thread) {
1012   return java_thread-&gt;obj_field(_inheritedAccessControlContext_offset);
1013 }
1014 
1015 
1016 jlong java_lang_Thread::stackSize(oop java_thread) {
1017   // The stackSize field is only present starting in 1.4
1018   if (_stackSize_offset &gt; 0) {
1019     assert(JDK_Version::is_gte_jdk14x_version(), "sanity check");
1020     return java_thread-&gt;long_field(_stackSize_offset);
1021   } else {
1022     return 0;
1023   }
1024 }
1025 
1026 // Write the thread status value to threadStatus field in java.lang.Thread java class.
1027 void java_lang_Thread::set_thread_status(oop java_thread,
1028                                          java_lang_Thread::ThreadStatus status) {
1029   // The threadStatus is only present starting in 1.5
1030   if (_thread_status_offset &gt; 0) {
1031     java_thread-&gt;int_field_put(_thread_status_offset, status);
1032   }
1033 }
1034 
1035 // Read thread status value from threadStatus field in java.lang.Thread java class.
1036 java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {
1037   assert(Thread::current()-&gt;is_Watcher_thread() || Thread::current()-&gt;is_VM_thread() ||
1038          JavaThread::current()-&gt;thread_state() == _thread_in_vm,
1039          "Java Thread is not running in vm");
1040   // The threadStatus is only present starting in 1.5
1041   if (_thread_status_offset &gt; 0) {
1042     return (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1043   } else {
1044     // All we can easily figure out is if it is alive, but that is
1045     // enough info for a valid unknown status.
1046     // These aren't restricted to valid set ThreadStatus values, so
1047     // use JVMTI values and cast.
1048     JavaThread* thr = java_lang_Thread::thread(java_thread);
1049     if (thr == NULL) {
1050       // the thread hasn't run yet or is in the process of exiting
1051       return NEW;
1052     }
1053     return (java_lang_Thread::ThreadStatus)JVMTI_THREAD_STATE_ALIVE;
1054   }
1055 }
1056 
1057 
1058 jlong java_lang_Thread::thread_id(oop java_thread) {
1059   // The thread ID field is only present starting in 1.5
1060   if (_tid_offset &gt; 0) {
1061     return java_thread-&gt;long_field(_tid_offset);
1062   } else {
1063     return 0;
1064   }
1065 }
1066 
1067 oop java_lang_Thread::park_blocker(oop java_thread) {
1068   assert(JDK_Version::current().supports_thread_park_blocker() &amp;&amp;
1069          _park_blocker_offset != 0, "Must support parkBlocker field");
1070 
1071   if (_park_blocker_offset &gt; 0) {
1072     return java_thread-&gt;obj_field(_park_blocker_offset);
1073   }
1074 
1075   return NULL;
1076 }
1077 
1078 jlong java_lang_Thread::park_event(oop java_thread) {
1079   if (_park_event_offset &gt; 0) {
1080     return java_thread-&gt;long_field(_park_event_offset);
1081   }
1082   return 0;
1083 }
1084 
1085 bool java_lang_Thread::set_park_event(oop java_thread, jlong ptr) {
1086   if (_park_event_offset &gt; 0) {
1087     java_thread-&gt;long_field_put(_park_event_offset, ptr);
1088     return true;
1089   }
1090   return false;
1091 }
1092 
1093 
1094 const char* java_lang_Thread::thread_status_name(oop java_thread) {
1095   assert(JDK_Version::is_gte_jdk15x_version() &amp;&amp; _thread_status_offset != 0, "Must have thread status");
1096   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1097   switch (status) {
1098     case NEW                      : return "NEW";
1099     case RUNNABLE                 : return "RUNNABLE";
1100     case SLEEPING                 : return "TIMED_WAITING (sleeping)";
1101     case IN_OBJECT_WAIT           : return "WAITING (on object monitor)";
1102     case IN_OBJECT_WAIT_TIMED     : return "TIMED_WAITING (on object monitor)";
1103     case PARKED                   : return "WAITING (parking)";
1104     case PARKED_TIMED             : return "TIMED_WAITING (parking)";
1105     case BLOCKED_ON_MONITOR_ENTER : return "BLOCKED (on object monitor)";
1106     case TERMINATED               : return "TERMINATED";
1107     default                       : return "UNKNOWN";
1108   };
1109 }
1110 int java_lang_ThreadGroup::_parent_offset = 0;
1111 int java_lang_ThreadGroup::_name_offset = 0;
1112 int java_lang_ThreadGroup::_threads_offset = 0;
1113 int java_lang_ThreadGroup::_groups_offset = 0;
1114 int java_lang_ThreadGroup::_maxPriority_offset = 0;
1115 int java_lang_ThreadGroup::_destroyed_offset = 0;
1116 int java_lang_ThreadGroup::_daemon_offset = 0;
1117 int java_lang_ThreadGroup::_vmAllowSuspension_offset = 0;
1118 int java_lang_ThreadGroup::_nthreads_offset = 0;
1119 int java_lang_ThreadGroup::_ngroups_offset = 0;
1120 
1121 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
1122   assert(java_thread_group-&gt;is_oop(), "thread group must be oop");
1123   return java_thread_group-&gt;obj_field(_parent_offset);
1124 }
1125 
1126 // ("name as oop" accessor is not necessary)
1127 
1128 typeArrayOop java_lang_ThreadGroup::name(oop java_thread_group) {
1129   oop name = java_thread_group-&gt;obj_field(_name_offset);
1130   // ThreadGroup.name can be null
1131   return name == NULL ? (typeArrayOop)NULL : java_lang_String::value(name);
1132 }
1133 
1134 int java_lang_ThreadGroup::nthreads(oop java_thread_group) {
1135   assert(java_thread_group-&gt;is_oop(), "thread group must be oop");
1136   return java_thread_group-&gt;int_field(_nthreads_offset);
1137 }
1138 
1139 objArrayOop java_lang_ThreadGroup::threads(oop java_thread_group) {
1140   oop threads = java_thread_group-&gt;obj_field(_threads_offset);
1141   assert(threads != NULL, "threadgroups should have threads");
1142   assert(threads-&gt;is_objArray(), "just checking"); // Todo: Add better type checking code
1143   return objArrayOop(threads);
1144 }
1145 
1146 int java_lang_ThreadGroup::ngroups(oop java_thread_group) {
1147   assert(java_thread_group-&gt;is_oop(), "thread group must be oop");
1148   return java_thread_group-&gt;int_field(_ngroups_offset);
1149 }
1150 
1151 objArrayOop java_lang_ThreadGroup::groups(oop java_thread_group) {
1152   oop groups = java_thread_group-&gt;obj_field(_groups_offset);
1153   assert(groups == NULL || groups-&gt;is_objArray(), "just checking"); // Todo: Add better type checking code
1154   return objArrayOop(groups);
1155 }
1156 
1157 ThreadPriority java_lang_ThreadGroup::maxPriority(oop java_thread_group) {
1158   assert(java_thread_group-&gt;is_oop(), "thread group must be oop");
1159   return (ThreadPriority) java_thread_group-&gt;int_field(_maxPriority_offset);
1160 }
1161 
1162 bool java_lang_ThreadGroup::is_destroyed(oop java_thread_group) {
1163   assert(java_thread_group-&gt;is_oop(), "thread group must be oop");
1164   return java_thread_group-&gt;bool_field(_destroyed_offset) != 0;
1165 }
1166 
1167 bool java_lang_ThreadGroup::is_daemon(oop java_thread_group) {
1168   assert(java_thread_group-&gt;is_oop(), "thread group must be oop");
1169   return java_thread_group-&gt;bool_field(_daemon_offset) != 0;
1170 }
1171 
1172 bool java_lang_ThreadGroup::is_vmAllowSuspension(oop java_thread_group) {
1173   assert(java_thread_group-&gt;is_oop(), "thread group must be oop");
1174   return java_thread_group-&gt;bool_field(_vmAllowSuspension_offset) != 0;
1175 }
1176 
1177 void java_lang_ThreadGroup::compute_offsets() {
1178   assert(_parent_offset == 0, "offsets should be initialized only once");
1179 
1180   Klass* k = SystemDictionary::ThreadGroup_klass();
1181 
1182   compute_offset(_parent_offset,      k, vmSymbols::parent_name(),      vmSymbols::threadgroup_signature());
1183   compute_offset(_name_offset,        k, vmSymbols::name_name(),        vmSymbols::string_signature());
1184   compute_offset(_threads_offset,     k, vmSymbols::threads_name(),     vmSymbols::thread_array_signature());
1185   compute_offset(_groups_offset,      k, vmSymbols::groups_name(),      vmSymbols::threadgroup_array_signature());
1186   compute_offset(_maxPriority_offset, k, vmSymbols::maxPriority_name(), vmSymbols::int_signature());
1187   compute_offset(_destroyed_offset,   k, vmSymbols::destroyed_name(),   vmSymbols::bool_signature());
1188   compute_offset(_daemon_offset,      k, vmSymbols::daemon_name(),      vmSymbols::bool_signature());
1189   compute_offset(_vmAllowSuspension_offset, k, vmSymbols::vmAllowSuspension_name(), vmSymbols::bool_signature());
1190   compute_offset(_nthreads_offset,    k, vmSymbols::nthreads_name(),    vmSymbols::int_signature());
1191   compute_offset(_ngroups_offset,     k, vmSymbols::ngroups_name(),     vmSymbols::int_signature());
1192 }
1193 
1194 oop java_lang_Throwable::unassigned_stacktrace() {
1195   InstanceKlass* ik = InstanceKlass::cast(SystemDictionary::Throwable_klass());
1196   address addr = ik-&gt;static_field_addr(static_unassigned_stacktrace_offset);
1197   if (UseCompressedOops) {
1198     return oopDesc::load_decode_heap_oop((narrowOop *)addr);
1199   } else {
1200     return oopDesc::load_decode_heap_oop((oop*)addr);
1201   }
1202 }
1203 
1204 oop java_lang_Throwable::backtrace(oop throwable) {
1205   return throwable-&gt;obj_field_acquire(backtrace_offset);
1206 }
1207 
1208 
1209 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
1210   throwable-&gt;release_obj_field_put(backtrace_offset, value);
1211 }
1212 
1213 
1214 oop java_lang_Throwable::message(oop throwable) {
1215   return throwable-&gt;obj_field(detailMessage_offset);
1216 }
1217 
1218 
1219 oop java_lang_Throwable::message(Handle throwable) {
1220   return throwable-&gt;obj_field(detailMessage_offset);
1221 }
1222 
1223 
1224 void java_lang_Throwable::set_message(oop throwable, oop value) {
1225   throwable-&gt;obj_field_put(detailMessage_offset, value);
1226 }
1227 
1228 
1229 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
1230   throwable-&gt;obj_field_put(stackTrace_offset, st_element_array);
1231 }
1232 
1233 void java_lang_Throwable::clear_stacktrace(oop throwable) {
1234   assert(JDK_Version::is_gte_jdk14x_version(), "should only be called in &gt;= 1.4");
1235   set_stacktrace(throwable, NULL);
1236 }
1237 
1238 
1239 void java_lang_Throwable::print(oop throwable, outputStream* st) {
1240   ResourceMark rm;
1241   Klass* k = throwable-&gt;klass();
1242   assert(k != NULL, "just checking");
1243   st-&gt;print("%s", InstanceKlass::cast(k)-&gt;external_name());
1244   oop msg = message(throwable);
1245   if (msg != NULL) {
1246     st-&gt;print(": %s", java_lang_String::as_utf8_string(msg));
1247   }
1248 }
1249 
1250 
1251 void java_lang_Throwable::print(Handle throwable, outputStream* st) {
1252   ResourceMark rm;
1253   Klass* k = throwable-&gt;klass();
1254   assert(k != NULL, "just checking");
1255   st-&gt;print("%s", InstanceKlass::cast(k)-&gt;external_name());
1256   oop msg = message(throwable);
1257   if (msg != NULL) {
1258     st-&gt;print(": %s", java_lang_String::as_utf8_string(msg));
1259   }
1260 }
1261 
1262 // After this many redefines, the stack trace is unreliable.
1263 const int MAX_VERSION = USHRT_MAX;
1264 
1265 // Helper backtrace functions to store bci|version together.
1266 static inline int merge_bci_and_version(int bci, int version) {
1267   // only store u2 for version, checking for overflow.
1268   if (version &gt; USHRT_MAX || version &lt; 0) version = MAX_VERSION;
1269   assert((jushort)bci == bci, "bci should be short");
1270   return build_int_from_shorts(version, bci);
1271 }
1272 
1273 static inline int bci_at(unsigned int merged) {
1274   return extract_high_short_from_int(merged);
1275 }
1276 static inline int version_at(unsigned int merged) {
1277   return extract_low_short_from_int(merged);
1278 }
1279 
1280 static inline bool version_matches(Method* method, int version) {
1281   assert(version &lt; MAX_VERSION, "version is too big");
1282   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
1283 }
1284 
1285 static inline int get_line_number(Method* method, int bci) {
1286   int line_number = 0;
1287   if (method-&gt;is_native()) {
1288     // Negative value different from -1 below, enabling Java code in
1289     // class java.lang.StackTraceElement to distinguish "native" from
1290     // "no LineNumberTable".  JDK tests for -2.
1291     line_number = -2;
1292   } else {
1293     // Returns -1 if no LineNumberTable, and otherwise actual line number
1294     line_number = method-&gt;line_number_from_bci(bci);
1295     if (line_number == -1 &amp;&amp; ShowHiddenFrames) {
1296       line_number = bci + 1000000;
1297     }
1298   }
1299   return line_number;
1300 }
1301 
1302 // This class provides a simple wrapper over the internal structure of
1303 // exception backtrace to insulate users of the backtrace from needing
1304 // to know what it looks like.
1305 class BacktraceBuilder: public StackObj {
1306  private:
1307   Handle          _backtrace;
1308   objArrayOop     _head;
1309   typeArrayOop    _methods;
1310   typeArrayOop    _bcis;
1311   objArrayOop     _mirrors;
1312   typeArrayOop    _cprefs; // needed to insulate method name against redefinition
1313   int             _index;
1314   No_Safepoint_Verifier _nsv;
1315 
1316  public:
1317 
1318   enum {
1319     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
1320     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
1321     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
1322     trace_cprefs_offset  = java_lang_Throwable::trace_cprefs_offset,
1323     trace_next_offset    = java_lang_Throwable::trace_next_offset,
1324     trace_size           = java_lang_Throwable::trace_size,
1325     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
1326   };
1327 
1328   // get info out of chunks
1329   static typeArrayOop get_methods(objArrayHandle chunk) {
1330     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
1331     assert(methods != NULL, "method array should be initialized in backtrace");
1332     return methods;
1333   }
1334   static typeArrayOop get_bcis(objArrayHandle chunk) {
1335     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
1336     assert(bcis != NULL, "bci array should be initialized in backtrace");
1337     return bcis;
1338   }
1339   static objArrayOop get_mirrors(objArrayHandle chunk) {
1340     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
1341     assert(mirrors != NULL, "mirror array should be initialized in backtrace");
1342     return mirrors;
1343   }
1344   static typeArrayOop get_cprefs(objArrayHandle chunk) {
1345     typeArrayOop cprefs = typeArrayOop(chunk-&gt;obj_at(trace_cprefs_offset));
1346     assert(cprefs != NULL, "cprefs array should be initialized in backtrace");
1347     return cprefs;
1348   }
1349 
1350   // constructor for new backtrace
1351   BacktraceBuilder(TRAPS): _methods(NULL), _bcis(NULL), _head(NULL), _mirrors(NULL), _cprefs(NULL) {
1352     expand(CHECK);
1353     _backtrace = _head;
1354     _index = 0;
1355   }
1356 
1357   BacktraceBuilder(objArrayHandle backtrace) {
1358     _methods = get_methods(backtrace);
1359     _bcis = get_bcis(backtrace);
1360     _mirrors = get_mirrors(backtrace);
1361     _cprefs = get_cprefs(backtrace);
1362     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
1363            _methods-&gt;length() == _mirrors-&gt;length(),
1364            "method and source information arrays should match");
1365 
1366     // head is the preallocated backtrace
1367     _backtrace = _head = backtrace();
1368     _index = 0;
1369   }
1370 
1371   void expand(TRAPS) {
1372     objArrayHandle old_head(THREAD, _head);
1373     Pause_No_Safepoint_Verifier pnsv(&amp;_nsv);
1374 
1375     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
1376     objArrayHandle new_head(THREAD, head);
1377 
1378     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
1379     typeArrayHandle new_methods(THREAD, methods);
1380 
1381     typeArrayOop bcis = oopFactory::new_intArray(trace_chunk_size, CHECK);
1382     typeArrayHandle new_bcis(THREAD, bcis);
1383 
1384     objArrayOop mirrors = oopFactory::new_objectArray(trace_chunk_size, CHECK);
1385     objArrayHandle new_mirrors(THREAD, mirrors);
1386 
1387     typeArrayOop cprefs = oopFactory::new_shortArray(trace_chunk_size, CHECK);
1388     typeArrayHandle new_cprefs(THREAD, cprefs);
1389 
1390     if (!old_head.is_null()) {
1391       old_head-&gt;obj_at_put(trace_next_offset, new_head());
1392     }
1393     new_head-&gt;obj_at_put(trace_methods_offset, new_methods());
1394     new_head-&gt;obj_at_put(trace_bcis_offset, new_bcis());
1395     new_head-&gt;obj_at_put(trace_mirrors_offset, new_mirrors());
1396     new_head-&gt;obj_at_put(trace_cprefs_offset, new_cprefs());
1397 
1398     _head    = new_head();
1399     _methods = new_methods();
1400     _bcis = new_bcis();
1401     _mirrors = new_mirrors();
1402     _cprefs  = new_cprefs();
1403     _index = 0;
1404   }
1405 
1406   oop backtrace() {
1407     return _backtrace();
1408   }
1409 
1410   inline void push(Method* method, int bci, TRAPS) {
1411     // Smear the -1 bci to 0 since the array only holds unsigned
1412     // shorts.  The later line number lookup would just smear the -1
1413     // to a 0 even if it could be recorded.
1414     if (bci == SynchronizationEntryBCI) bci = 0;
1415 
1416     if (_index &gt;= trace_chunk_size) {
1417       methodHandle mhandle(THREAD, method);
1418       expand(CHECK);
1419       method = mhandle();
1420     }
1421 
1422     _methods-&gt;short_at_put(_index, method-&gt;orig_method_idnum());
1423     _bcis-&gt;int_at_put(_index, merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
1424     _cprefs-&gt;short_at_put(_index, method-&gt;name_index());
1425 
1426     // We need to save the mirrors in the backtrace to keep the class
1427     // from being unloaded while we still have this stack trace.
1428     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, "never push null for mirror");
1429     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
1430     _index++;
1431   }
1432 
1433 };
1434 
1435 // Print stack trace element to resource allocated buffer
1436 char* java_lang_Throwable::print_stack_element_to_buffer(Handle mirror,
1437                                   int method_id, int version, int bci, int cpref) {
1438 
1439   // Get strings and string lengths
1440   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(mirror()));
1441   const char* klass_name  = holder-&gt;external_name();
1442   int buf_len = (int)strlen(klass_name);
1443 
1444   Method* method = holder-&gt;method_with_orig_idnum(method_id, version);
1445 
1446   // The method can be NULL if the requested class version is gone
1447   Symbol* sym = (method != NULL) ? method-&gt;name() : holder-&gt;constants()-&gt;symbol_at(cpref);
1448   char* method_name = sym-&gt;as_C_string();
1449   buf_len += (int)strlen(method_name);
1450 
1451   // Use a specific ik version as a holder since the mirror might
1452   // refer to a version that is now obsolete and no longer accessible
1453   // via the previous versions list.
1454   holder = holder-&gt;get_klass_version(version);
1455   char* source_file_name = NULL;
1456   if (holder != NULL) {
1457     Symbol* source = holder-&gt;source_file_name();
1458     if (source != NULL) {
1459       source_file_name = source-&gt;as_C_string();
1460       buf_len += (int)strlen(source_file_name);
1461     }
1462   }
1463 
1464   // Allocate temporary buffer with extra space for formatting and line number
1465   char* buf = NEW_RESOURCE_ARRAY(char, buf_len + 64);
1466 
1467   // Print stack trace line in buffer
1468   sprintf(buf, "\tat %s.%s", klass_name, method_name);
1469 
1470   if (!version_matches(method, version)) {
1471     strcat(buf, "(Redefined)");
1472   } else {
1473     int line_number = get_line_number(method, bci);
1474     if (line_number == -2) {
1475       strcat(buf, "(Native Method)");
1476     } else {
1477       if (source_file_name != NULL &amp;&amp; (line_number != -1)) {
1478         // Sourcename and linenumber
1479         sprintf(buf + (int)strlen(buf), "(%s:%d)", source_file_name, line_number);
1480       } else if (source_file_name != NULL) {
1481         // Just sourcename
1482         sprintf(buf + (int)strlen(buf), "(%s)", source_file_name);
1483       } else {
1484         // Neither sourcename nor linenumber
1485         sprintf(buf + (int)strlen(buf), "(Unknown Source)");
1486       }
1487       nmethod* nm = method-&gt;code();
1488       if (WizardMode &amp;&amp; nm != NULL) {
1489         sprintf(buf + (int)strlen(buf), "(nmethod " INTPTR_FORMAT ")", (intptr_t)nm);
1490       }
1491     }
1492   }
1493 
1494   return buf;
1495 }
1496 
1497 void java_lang_Throwable::print_stack_element(outputStream *st, Handle mirror,
1498                                               int method_id, int version, int bci, int cpref) {
1499   ResourceMark rm;
1500   char* buf = print_stack_element_to_buffer(mirror, method_id, version, bci, cpref);
1501   st-&gt;print_cr("%s", buf);
1502 }
1503 
1504 void java_lang_Throwable::print_stack_element(outputStream *st, methodHandle method, int bci) {
1505   Handle mirror = method-&gt;method_holder()-&gt;java_mirror();
1506   int method_id = method-&gt;orig_method_idnum();
1507   int version = method-&gt;constants()-&gt;version();
1508   int cpref = method-&gt;name_index();
1509   print_stack_element(st, mirror, method_id, version, bci, cpref);
1510 }
1511 
1512 const char* java_lang_Throwable::no_stack_trace_message() {
1513   return "\t&lt;&lt;no stack trace available&gt;&gt;";
1514 }
1515 
1516 
1517 // Currently used only for exceptions occurring during startup
1518 void java_lang_Throwable::print_stack_trace(oop throwable, outputStream* st) {
1519   Thread *THREAD = Thread::current();
1520   Handle h_throwable(THREAD, throwable);
1521   while (h_throwable.not_null()) {
1522     objArrayHandle result (THREAD, objArrayOop(backtrace(h_throwable())));
1523     if (result.is_null()) {
1524       st-&gt;print_cr("%s", no_stack_trace_message());
1525       return;
1526     }
1527 
1528     while (result.not_null()) {
1529 
1530       // Get method id, bci, version and mirror from chunk
1531       typeArrayHandle methods (THREAD, BacktraceBuilder::get_methods(result));
1532       typeArrayHandle bcis (THREAD, BacktraceBuilder::get_bcis(result));
1533       objArrayHandle mirrors (THREAD, BacktraceBuilder::get_mirrors(result));
1534       typeArrayHandle cprefs (THREAD, BacktraceBuilder::get_cprefs(result));
1535 
1536       int length = methods()-&gt;length();
1537       for (int index = 0; index &lt; length; index++) {
1538         Handle mirror(THREAD, mirrors-&gt;obj_at(index));
1539         // NULL mirror means end of stack trace
1540         if (mirror.is_null()) goto handle_cause;
1541         int method = methods-&gt;short_at(index);
1542         int version = version_at(bcis-&gt;int_at(index));
1543         int bci = bci_at(bcis-&gt;int_at(index));
1544         int cpref = cprefs-&gt;short_at(index);
1545         print_stack_element(st, mirror, method, version, bci, cpref);
1546       }
1547       result = objArrayHandle(THREAD, objArrayOop(result-&gt;obj_at(trace_next_offset)));
1548     }
1549   handle_cause:
1550     {
1551       EXCEPTION_MARK;
1552       JavaValue cause(T_OBJECT);
1553       JavaCalls::call_virtual(&amp;cause,
1554                               h_throwable,
1555                               KlassHandle(THREAD, h_throwable-&gt;klass()),
1556                               vmSymbols::getCause_name(),
1557                               vmSymbols::void_throwable_signature(),
1558                               THREAD);
1559       // Ignore any exceptions. we are in the middle of exception handling. Same as classic VM.
1560       if (HAS_PENDING_EXCEPTION) {
1561         CLEAR_PENDING_EXCEPTION;
1562         h_throwable = Handle();
1563       } else {
1564         h_throwable = Handle(THREAD, (oop) cause.get_jobject());
1565         if (h_throwable.not_null()) {
1566           st-&gt;print("Caused by: ");
1567           print(h_throwable, st);
1568           st-&gt;cr();
1569         }
1570       }
1571     }
1572   }
1573 }
1574 
1575 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, methodHandle method, TRAPS) {
1576   if (!StackTraceInThrowable) return;
1577   ResourceMark rm(THREAD);
1578 
1579   // Start out by clearing the backtrace for this object, in case the VM
1580   // runs out of memory while allocating the stack trace
1581   set_backtrace(throwable(), NULL);
1582   if (JDK_Version::is_gte_jdk14x_version()) {
1583     // New since 1.4, clear lazily constructed Java level stacktrace if
1584     // refilling occurs
1585     // This is unnecessary in 1.7+ but harmless
1586     clear_stacktrace(throwable());
1587   }
1588 
1589   int max_depth = MaxJavaStackTraceDepth;
1590   JavaThread* thread = (JavaThread*)THREAD;
1591   BacktraceBuilder bt(CHECK);
1592 
1593   // If there is no Java frame just return the method that was being called
1594   // with bci 0
1595   if (!thread-&gt;has_last_Java_frame()) {
1596     if (max_depth &gt;= 1 &amp;&amp; method() != NULL) {
1597       bt.push(method(), 0, CHECK);
1598       set_backtrace(throwable(), bt.backtrace());
1599     }
1600     return;
1601   }
1602 
1603   // Instead of using vframe directly, this version of fill_in_stack_trace
1604   // basically handles everything by hand. This significantly improved the
1605   // speed of this method call up to 28.5% on Solaris sparc. 27.1% on Windows.
1606   // See bug 6333838 for  more details.
1607   // The "ASSERT" here is to verify this method generates the exactly same stack
1608   // trace as utilizing vframe.
1609 #ifdef ASSERT
1610   vframeStream st(thread);
1611   methodHandle st_method(THREAD, st.method());
1612 #endif
1613   int total_count = 0;
1614   RegisterMap map(thread, false);
1615   int decode_offset = 0;
1616   nmethod* nm = NULL;
1617   bool skip_fillInStackTrace_check = false;
1618   bool skip_throwableInit_check = false;
1619   bool skip_hidden = !ShowHiddenFrames;
1620 
1621   for (frame fr = thread-&gt;last_frame(); max_depth != total_count;) {
1622     Method* method = NULL;
1623     int bci = 0;
1624 
1625     // Compiled java method case.
1626     if (decode_offset != 0) {
1627       DebugInfoReadStream stream(nm, decode_offset);
1628       decode_offset = stream.read_int();
1629       method = (Method*)nm-&gt;metadata_at(stream.read_int());
1630       bci = stream.read_bci();
1631     } else {
1632       if (fr.is_first_frame()) break;
1633       address pc = fr.pc();
1634       if (fr.is_interpreted_frame()) {
1635         intptr_t bcx = fr.interpreter_frame_bcx();
1636         method = fr.interpreter_frame_method();
1637         bci =  fr.is_bci(bcx) ? bcx : method-&gt;bci_from((address)bcx);
1638         fr = fr.sender(&amp;map);
1639       } else {
1640         CodeBlob* cb = fr.cb();
1641         // HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL
1642         // but non nmethod
1643         fr = fr.sender(&amp;map);
1644         if (cb == NULL || !cb-&gt;is_nmethod()) {
1645           continue;
1646         }
1647         nm = (nmethod*)cb;
1648         if (nm-&gt;method()-&gt;is_native()) {
1649           method = nm-&gt;method();
1650           bci = 0;
1651         } else {
1652           PcDesc* pd = nm-&gt;pc_desc_at(pc);
1653           decode_offset = pd-&gt;scope_decode_offset();
1654           // if decode_offset is not equal to 0, it will execute the
1655           // "compiled java method case" at the beginning of the loop.
1656           continue;
1657         }
1658       }
1659     }
1660 #ifdef ASSERT
1661     assert(st_method() == method &amp;&amp; st.bci() == bci,
1662            "Wrong stack trace");
1663     st.next();
1664     // vframeStream::method isn't GC-safe so store off a copy
1665     // of the Method* in case we GC.
1666     if (!st.at_end()) {
1667       st_method = st.method();
1668     }
1669 #endif
1670 
1671     // the format of the stacktrace will be:
1672     // - 1 or more fillInStackTrace frames for the exception class (skipped)
1673     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
1674     // - rest of the stack
1675 
1676     if (!skip_fillInStackTrace_check) {
1677       if ((method-&gt;name() == vmSymbols::fillInStackTrace_name() ||
1678            method-&gt;name() == vmSymbols::fillInStackTrace0_name()) &amp;&amp;
1679           throwable-&gt;is_a(method-&gt;method_holder())) {
1680         continue;
1681       }
1682       else {
1683         skip_fillInStackTrace_check = true; // gone past them all
1684       }
1685     }
1686     if (!skip_throwableInit_check) {
1687       assert(skip_fillInStackTrace_check, "logic error in backtrace filtering");
1688 
1689       // skip &lt;init&gt; methods of the exception class and superclasses
1690       // This is simlar to classic VM.
1691       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
1692           throwable-&gt;is_a(method-&gt;method_holder())) {
1693         continue;
1694       } else {
1695         // there are none or we've seen them all - either way stop checking
1696         skip_throwableInit_check = true;
1697       }
1698     }
1699     if (method-&gt;is_hidden()) {
1700       if (skip_hidden)  continue;
1701     }
1702     bt.push(method, bci, CHECK);
1703     total_count++;
1704   }
1705 
1706   // Put completed stack trace into throwable object
1707   set_backtrace(throwable(), bt.backtrace());
1708 }
1709 
1710 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, methodHandle method) {
1711   // No-op if stack trace is disabled
1712   if (!StackTraceInThrowable) {
1713     return;
1714   }
1715 
1716   // Disable stack traces for some preallocated out of memory errors
1717   if (!Universe::should_fill_in_stack_trace(throwable)) {
1718     return;
1719   }
1720 
1721   PRESERVE_EXCEPTION_MARK;
1722 
1723   JavaThread* thread = JavaThread::active();
1724   fill_in_stack_trace(throwable, method, thread);
1725   // ignore exceptions thrown during stack trace filling
1726   CLEAR_PENDING_EXCEPTION;
1727 }
1728 
1729 void java_lang_Throwable::allocate_backtrace(Handle throwable, TRAPS) {
1730   // Allocate stack trace - backtrace is created but not filled in
1731 
1732   // No-op if stack trace is disabled
1733   if (!StackTraceInThrowable) return;
1734   BacktraceBuilder bt(CHECK);   // creates a backtrace
1735   set_backtrace(throwable(), bt.backtrace());
1736 }
1737 
1738 
1739 void java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(Handle throwable) {
1740   // Fill in stack trace into preallocated backtrace (no GC)
1741 
1742   // No-op if stack trace is disabled
1743   if (!StackTraceInThrowable) return;
1744 
1745   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), "sanity check");
1746 
1747   JavaThread* THREAD = JavaThread::current();
1748 
1749   objArrayHandle backtrace (THREAD, (objArrayOop)java_lang_Throwable::backtrace(throwable()));
1750   assert(backtrace.not_null(), "backtrace should have been preallocated");
1751 
1752   ResourceMark rm(THREAD);
1753   vframeStream st(THREAD);
1754 
1755   BacktraceBuilder bt(backtrace);
1756 
1757   // Unlike fill_in_stack_trace we do not skip fillInStackTrace or throwable init
1758   // methods as preallocated errors aren't created by "java" code.
1759 
1760   // fill in as much stack trace as possible
1761   typeArrayOop methods = BacktraceBuilder::get_methods(backtrace);
1762   int max_chunks = MIN2(methods-&gt;length(), (int)MaxJavaStackTraceDepth);
1763   int chunk_count = 0;
1764 
1765   for (;!st.at_end(); st.next()) {
1766     bt.push(st.method(), st.bci(), CHECK);
1767     chunk_count++;
1768 
1769     // Bail-out for deep stacks
1770     if (chunk_count &gt;= max_chunks) break;
1771   }
1772 
1773   // For Java 7+ we support the Throwable immutability protocol defined for Java 7. This support
1774   // was missing in 7u0 so in 7u0 there is a workaround in the Throwable class. That workaround
1775   // can be removed in a JDK using this JVM version
1776   if (JDK_Version::is_gte_jdk17x_version()) {
1777       java_lang_Throwable::set_stacktrace(throwable(), java_lang_Throwable::unassigned_stacktrace());
1778       assert(java_lang_Throwable::unassigned_stacktrace() != NULL, "not initialized");
1779   }
1780 }
1781 
1782 
1783 int java_lang_Throwable::get_stack_trace_depth(oop throwable, TRAPS) {
1784   if (throwable == NULL) {
1785     THROW_0(vmSymbols::java_lang_NullPointerException());
1786   }
1787   objArrayOop chunk = objArrayOop(backtrace(throwable));
1788   int depth = 0;
1789   if (chunk != NULL) {
1790     // Iterate over chunks and count full ones
1791     while (true) {
1792       objArrayOop next = objArrayOop(chunk-&gt;obj_at(trace_next_offset));
1793       if (next == NULL) break;
1794       depth += trace_chunk_size;
1795       chunk = next;
1796     }
1797     assert(chunk != NULL &amp;&amp; chunk-&gt;obj_at(trace_next_offset) == NULL, "sanity check");
1798     // Count element in remaining partial chunk.  NULL value for mirror
1799     // marks the end of the stack trace elements that are saved.
1800     objArrayOop mirrors = BacktraceBuilder::get_mirrors(chunk);
1801     assert(mirrors != NULL, "sanity check");
1802     for (int i = 0; i &lt; mirrors-&gt;length(); i++) {
1803       if (mirrors-&gt;obj_at(i) == NULL) break;
1804       depth++;
1805     }
1806   }
1807   return depth;
1808 }
1809 
1810 
1811 oop java_lang_Throwable::get_stack_trace_element(oop throwable, int index, TRAPS) {
1812   if (throwable == NULL) {
1813     THROW_0(vmSymbols::java_lang_NullPointerException());
1814   }
1815   if (index &lt; 0) {
1816     THROW_(vmSymbols::java_lang_IndexOutOfBoundsException(), NULL);
1817   }
1818   // Compute how many chunks to skip and index into actual chunk
1819   objArrayOop chunk = objArrayOop(backtrace(throwable));
1820   int skip_chunks = index / trace_chunk_size;
1821   int chunk_index = index % trace_chunk_size;
1822   while (chunk != NULL &amp;&amp; skip_chunks &gt; 0) {
1823     chunk = objArrayOop(chunk-&gt;obj_at(trace_next_offset));
1824         skip_chunks--;
1825   }
1826   if (chunk == NULL) {
1827     THROW_(vmSymbols::java_lang_IndexOutOfBoundsException(), NULL);
1828   }
1829   // Get method id, bci, version, mirror and cpref from chunk
1830   typeArrayOop methods = BacktraceBuilder::get_methods(chunk);
1831   typeArrayOop bcis = BacktraceBuilder::get_bcis(chunk);
1832   objArrayOop mirrors = BacktraceBuilder::get_mirrors(chunk);
1833   typeArrayOop cprefs = BacktraceBuilder::get_cprefs(chunk);
1834 
1835   assert(methods != NULL &amp;&amp; bcis != NULL &amp;&amp; mirrors != NULL, "sanity check");
1836 
1837   int method = methods-&gt;short_at(chunk_index);
1838   int version = version_at(bcis-&gt;int_at(chunk_index));
1839   int bci = bci_at(bcis-&gt;int_at(chunk_index));
1840   int cpref = cprefs-&gt;short_at(chunk_index);
1841   Handle mirror(THREAD, mirrors-&gt;obj_at(chunk_index));
1842 
1843   // Chunk can be partial full
1844   if (mirror.is_null()) {
1845     THROW_(vmSymbols::java_lang_IndexOutOfBoundsException(), NULL);
1846   }
1847   oop element = java_lang_StackTraceElement::create(mirror, method, version, bci, cpref, CHECK_0);
1848   return element;
1849 }
1850 
1851 oop java_lang_StackTraceElement::create(Handle mirror, int method_id,
1852                                         int version, int bci, int cpref, TRAPS) {
1853   // Allocate java.lang.StackTraceElement instance
1854   Klass* k = SystemDictionary::StackTraceElement_klass();
1855   assert(k != NULL, "must be loaded in 1.4+");
1856   instanceKlassHandle ik (THREAD, k);
1857   if (ik-&gt;should_be_initialized()) {
1858     ik-&gt;initialize(CHECK_0);
1859   }
1860 
1861   Handle element = ik-&gt;allocate_instance_handle(CHECK_0);
1862   // Fill in class name
1863   ResourceMark rm(THREAD);
1864   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(mirror()));
1865   const char* str = holder-&gt;external_name();
1866   oop classname = StringTable::intern((char*) str, CHECK_0);
1867   java_lang_StackTraceElement::set_declaringClass(element(), classname);
1868 
1869   Method* method = holder-&gt;method_with_orig_idnum(method_id, version);
1870 
1871   // The method can be NULL if the requested class version is gone
1872   Symbol* sym = (method != NULL) ? method-&gt;name() : holder-&gt;constants()-&gt;symbol_at(cpref);
1873 
1874   // Fill in method name
1875   oop methodname = StringTable::intern(sym, CHECK_0);
1876   java_lang_StackTraceElement::set_methodName(element(), methodname);
1877 
1878   if (!version_matches(method, version)) {
1879     // The method was redefined, accurate line number information isn't available
1880     java_lang_StackTraceElement::set_fileName(element(), NULL);
1881     java_lang_StackTraceElement::set_lineNumber(element(), -1);
1882   } else {
1883     // Fill in source file name and line number.
1884     // Use a specific ik version as a holder since the mirror might
1885     // refer to a version that is now obsolete and no longer accessible
1886     // via the previous versions list.
1887     holder = holder-&gt;get_klass_version(version);
1888     assert(holder != NULL, "sanity check");
1889     Symbol* source = holder-&gt;source_file_name();
1890     if (ShowHiddenFrames &amp;&amp; source == NULL)
1891       source = vmSymbols::unknown_class_name();
1892     oop filename = StringTable::intern(source, CHECK_0);
1893     java_lang_StackTraceElement::set_fileName(element(), filename);
1894 
1895     int line_number = get_line_number(method, bci);
1896     java_lang_StackTraceElement::set_lineNumber(element(), line_number);
1897   }
1898   return element();
1899 }
1900 
1901 oop java_lang_StackTraceElement::create(methodHandle method, int bci, TRAPS) {
1902   Handle mirror (THREAD, method-&gt;method_holder()-&gt;java_mirror());
1903   int method_id = method-&gt;orig_method_idnum();
1904   int cpref = method-&gt;name_index();
1905   return create(mirror, method_id, method-&gt;constants()-&gt;version(), bci, cpref, THREAD);
1906 }
1907 
1908 void java_lang_reflect_AccessibleObject::compute_offsets() {
1909   Klass* k = SystemDictionary::reflect_AccessibleObject_klass();
1910   compute_offset(override_offset, k, vmSymbols::override_name(), vmSymbols::bool_signature());
1911 }
1912 
1913 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
1914   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
1915   return (jboolean) reflect-&gt;bool_field(override_offset);
1916 }
1917 
1918 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
1919   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
1920   reflect-&gt;bool_field_put(override_offset, (int) value);
1921 }
1922 
1923 void java_lang_reflect_Method::compute_offsets() {
1924   Klass* k = SystemDictionary::reflect_Method_klass();
1925   compute_offset(clazz_offset,          k, vmSymbols::clazz_name(),          vmSymbols::class_signature());
1926   compute_offset(name_offset,           k, vmSymbols::name_name(),           vmSymbols::string_signature());
1927   compute_offset(returnType_offset,     k, vmSymbols::returnType_name(),     vmSymbols::class_signature());
1928   compute_offset(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), vmSymbols::class_array_signature());
1929   compute_offset(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), vmSymbols::class_array_signature());
1930   compute_offset(slot_offset,           k, vmSymbols::slot_name(),           vmSymbols::int_signature());
1931   compute_offset(modifiers_offset,      k, vmSymbols::modifiers_name(),      vmSymbols::int_signature());
1932   // The generic signature and annotations fields are only present in 1.5
1933   signature_offset = -1;
1934   annotations_offset = -1;
1935   parameter_annotations_offset = -1;
1936   annotation_default_offset = -1;
1937   type_annotations_offset = -1;
1938   compute_optional_offset(signature_offset,             k, vmSymbols::signature_name(),             vmSymbols::string_signature());
1939   compute_optional_offset(annotations_offset,           k, vmSymbols::annotations_name(),           vmSymbols::byte_array_signature());
1940   compute_optional_offset(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), vmSymbols::byte_array_signature());
1941   compute_optional_offset(annotation_default_offset,    k, vmSymbols::annotation_default_name(),    vmSymbols::byte_array_signature());
1942   compute_optional_offset(type_annotations_offset,      k, vmSymbols::type_annotations_name(),      vmSymbols::byte_array_signature());
1943 }
1944 
1945 Handle java_lang_reflect_Method::create(TRAPS) {
1946   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
1947   Klass* klass = SystemDictionary::reflect_Method_klass();
1948   // This class is eagerly initialized during VM initialization, since we keep a refence
1949   // to one of the methods
1950   assert(InstanceKlass::cast(klass)-&gt;is_initialized(), "must be initialized");
1951   return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(CHECK_NH);
1952 }
1953 
1954 oop java_lang_reflect_Method::clazz(oop reflect) {
1955   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
1956   return reflect-&gt;obj_field(clazz_offset);
1957 }
1958 
1959 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
1960   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
1961    reflect-&gt;obj_field_put(clazz_offset, value);
1962 }
1963 
1964 int java_lang_reflect_Method::slot(oop reflect) {
1965   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
1966   return reflect-&gt;int_field(slot_offset);
1967 }
1968 
1969 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
1970   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
1971   reflect-&gt;int_field_put(slot_offset, value);
1972 }
1973 
1974 oop java_lang_reflect_Method::name(oop method) {
1975   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
1976   return method-&gt;obj_field(name_offset);
1977 }
1978 
1979 void java_lang_reflect_Method::set_name(oop method, oop value) {
1980   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
1981   method-&gt;obj_field_put(name_offset, value);
1982 }
1983 
1984 oop java_lang_reflect_Method::return_type(oop method) {
1985   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
1986   return method-&gt;obj_field(returnType_offset);
1987 }
1988 
1989 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
1990   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
1991   method-&gt;obj_field_put(returnType_offset, value);
1992 }
1993 
1994 oop java_lang_reflect_Method::parameter_types(oop method) {
1995   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
1996   return method-&gt;obj_field(parameterTypes_offset);
1997 }
1998 
1999 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
2000   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2001   method-&gt;obj_field_put(parameterTypes_offset, value);
2002 }
2003 
2004 oop java_lang_reflect_Method::exception_types(oop method) {
2005   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2006   return method-&gt;obj_field(exceptionTypes_offset);
2007 }
2008 
2009 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
2010   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2011   method-&gt;obj_field_put(exceptionTypes_offset, value);
2012 }
2013 
2014 int java_lang_reflect_Method::modifiers(oop method) {
2015   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2016   return method-&gt;int_field(modifiers_offset);
2017 }
2018 
2019 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
2020   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2021   method-&gt;int_field_put(modifiers_offset, value);
2022 }
2023 
2024 bool java_lang_reflect_Method::has_signature_field() {
2025   return (signature_offset &gt;= 0);
2026 }
2027 
2028 oop java_lang_reflect_Method::signature(oop method) {
2029   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2030   assert(has_signature_field(), "signature field must be present");
2031   return method-&gt;obj_field(signature_offset);
2032 }
2033 
2034 void java_lang_reflect_Method::set_signature(oop method, oop value) {
2035   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2036   assert(has_signature_field(), "signature field must be present");
2037   method-&gt;obj_field_put(signature_offset, value);
2038 }
2039 
2040 bool java_lang_reflect_Method::has_annotations_field() {
2041   return (annotations_offset &gt;= 0);
2042 }
2043 
2044 oop java_lang_reflect_Method::annotations(oop method) {
2045   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2046   assert(has_annotations_field(), "annotations field must be present");
2047   return method-&gt;obj_field(annotations_offset);
2048 }
2049 
2050 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
2051   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2052   assert(has_annotations_field(), "annotations field must be present");
2053   method-&gt;obj_field_put(annotations_offset, value);
2054 }
2055 
2056 bool java_lang_reflect_Method::has_parameter_annotations_field() {
2057   return (parameter_annotations_offset &gt;= 0);
2058 }
2059 
2060 oop java_lang_reflect_Method::parameter_annotations(oop method) {
2061   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2062   assert(has_parameter_annotations_field(), "parameter annotations field must be present");
2063   return method-&gt;obj_field(parameter_annotations_offset);
2064 }
2065 
2066 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
2067   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2068   assert(has_parameter_annotations_field(), "parameter annotations field must be present");
2069   method-&gt;obj_field_put(parameter_annotations_offset, value);
2070 }
2071 
2072 bool java_lang_reflect_Method::has_annotation_default_field() {
2073   return (annotation_default_offset &gt;= 0);
2074 }
2075 
2076 oop java_lang_reflect_Method::annotation_default(oop method) {
2077   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2078   assert(has_annotation_default_field(), "annotation default field must be present");
2079   return method-&gt;obj_field(annotation_default_offset);
2080 }
2081 
2082 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
2083   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2084   assert(has_annotation_default_field(), "annotation default field must be present");
2085   method-&gt;obj_field_put(annotation_default_offset, value);
2086 }
2087 
2088 bool java_lang_reflect_Method::has_type_annotations_field() {
2089   return (type_annotations_offset &gt;= 0);
2090 }
2091 
2092 oop java_lang_reflect_Method::type_annotations(oop method) {
2093   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2094   assert(has_type_annotations_field(), "type_annotations field must be present");
2095   return method-&gt;obj_field(type_annotations_offset);
2096 }
2097 
2098 void java_lang_reflect_Method::set_type_annotations(oop method, oop value) {
2099   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2100   assert(has_type_annotations_field(), "type_annotations field must be present");
2101   method-&gt;obj_field_put(type_annotations_offset, value);
2102 }
2103 
2104 void java_lang_reflect_Constructor::compute_offsets() {
2105   Klass* k = SystemDictionary::reflect_Constructor_klass();
2106   compute_offset(clazz_offset,          k, vmSymbols::clazz_name(),          vmSymbols::class_signature());
2107   compute_offset(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), vmSymbols::class_array_signature());
2108   compute_offset(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), vmSymbols::class_array_signature());
2109   compute_offset(slot_offset,           k, vmSymbols::slot_name(),           vmSymbols::int_signature());
2110   compute_offset(modifiers_offset,      k, vmSymbols::modifiers_name(),      vmSymbols::int_signature());
2111   // The generic signature and annotations fields are only present in 1.5
2112   signature_offset = -1;
2113   annotations_offset = -1;
2114   parameter_annotations_offset = -1;
2115   type_annotations_offset = -1;
2116   compute_optional_offset(signature_offset,             k, vmSymbols::signature_name(),             vmSymbols::string_signature());
2117   compute_optional_offset(annotations_offset,           k, vmSymbols::annotations_name(),           vmSymbols::byte_array_signature());
2118   compute_optional_offset(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), vmSymbols::byte_array_signature());
2119   compute_optional_offset(type_annotations_offset,      k, vmSymbols::type_annotations_name(),      vmSymbols::byte_array_signature());
2120 }
2121 
2122 Handle java_lang_reflect_Constructor::create(TRAPS) {
2123   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2124   Symbol* name = vmSymbols::java_lang_reflect_Constructor();
2125   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
2126   instanceKlassHandle klass (THREAD, k);
2127   // Ensure it is initialized
2128   klass-&gt;initialize(CHECK_NH);
2129   return klass-&gt;allocate_instance_handle(CHECK_NH);
2130 }
2131 
2132 oop java_lang_reflect_Constructor::clazz(oop reflect) {
2133   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2134   return reflect-&gt;obj_field(clazz_offset);
2135 }
2136 
2137 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
2138   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2139    reflect-&gt;obj_field_put(clazz_offset, value);
2140 }
2141 
2142 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
2143   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2144   return constructor-&gt;obj_field(parameterTypes_offset);
2145 }
2146 
2147 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
2148   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2149   constructor-&gt;obj_field_put(parameterTypes_offset, value);
2150 }
2151 
2152 oop java_lang_reflect_Constructor::exception_types(oop constructor) {
2153   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2154   return constructor-&gt;obj_field(exceptionTypes_offset);
2155 }
2156 
2157 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
2158   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2159   constructor-&gt;obj_field_put(exceptionTypes_offset, value);
2160 }
2161 
2162 int java_lang_reflect_Constructor::slot(oop reflect) {
2163   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2164   return reflect-&gt;int_field(slot_offset);
2165 }
2166 
2167 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
2168   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2169   reflect-&gt;int_field_put(slot_offset, value);
2170 }
2171 
2172 int java_lang_reflect_Constructor::modifiers(oop constructor) {
2173   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2174   return constructor-&gt;int_field(modifiers_offset);
2175 }
2176 
2177 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
2178   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2179   constructor-&gt;int_field_put(modifiers_offset, value);
2180 }
2181 
2182 bool java_lang_reflect_Constructor::has_signature_field() {
2183   return (signature_offset &gt;= 0);
2184 }
2185 
2186 oop java_lang_reflect_Constructor::signature(oop constructor) {
2187   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2188   assert(has_signature_field(), "signature field must be present");
2189   return constructor-&gt;obj_field(signature_offset);
2190 }
2191 
2192 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
2193   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2194   assert(has_signature_field(), "signature field must be present");
2195   constructor-&gt;obj_field_put(signature_offset, value);
2196 }
2197 
2198 bool java_lang_reflect_Constructor::has_annotations_field() {
2199   return (annotations_offset &gt;= 0);
2200 }
2201 
2202 oop java_lang_reflect_Constructor::annotations(oop constructor) {
2203   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2204   assert(has_annotations_field(), "annotations field must be present");
2205   return constructor-&gt;obj_field(annotations_offset);
2206 }
2207 
2208 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
2209   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2210   assert(has_annotations_field(), "annotations field must be present");
2211   constructor-&gt;obj_field_put(annotations_offset, value);
2212 }
2213 
2214 bool java_lang_reflect_Constructor::has_parameter_annotations_field() {
2215   return (parameter_annotations_offset &gt;= 0);
2216 }
2217 
2218 oop java_lang_reflect_Constructor::parameter_annotations(oop method) {
2219   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2220   assert(has_parameter_annotations_field(), "parameter annotations field must be present");
2221   return method-&gt;obj_field(parameter_annotations_offset);
2222 }
2223 
2224 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
2225   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2226   assert(has_parameter_annotations_field(), "parameter annotations field must be present");
2227   method-&gt;obj_field_put(parameter_annotations_offset, value);
2228 }
2229 
2230 bool java_lang_reflect_Constructor::has_type_annotations_field() {
2231   return (type_annotations_offset &gt;= 0);
2232 }
2233 
2234 oop java_lang_reflect_Constructor::type_annotations(oop constructor) {
2235   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2236   assert(has_type_annotations_field(), "type_annotations field must be present");
2237   return constructor-&gt;obj_field(type_annotations_offset);
2238 }
2239 
2240 void java_lang_reflect_Constructor::set_type_annotations(oop constructor, oop value) {
2241   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2242   assert(has_type_annotations_field(), "type_annotations field must be present");
2243   constructor-&gt;obj_field_put(type_annotations_offset, value);
2244 }
2245 
2246 void java_lang_reflect_Field::compute_offsets() {
2247   Klass* k = SystemDictionary::reflect_Field_klass();
2248   compute_offset(clazz_offset,     k, vmSymbols::clazz_name(),     vmSymbols::class_signature());
2249   compute_offset(name_offset,      k, vmSymbols::name_name(),      vmSymbols::string_signature());
2250   compute_offset(type_offset,      k, vmSymbols::type_name(),      vmSymbols::class_signature());
2251   compute_offset(slot_offset,      k, vmSymbols::slot_name(),      vmSymbols::int_signature());
2252   compute_offset(modifiers_offset, k, vmSymbols::modifiers_name(), vmSymbols::int_signature());
2253   // The generic signature and annotations fields are only present in 1.5
2254   signature_offset = -1;
2255   annotations_offset = -1;
2256   type_annotations_offset = -1;
2257   compute_optional_offset(signature_offset, k, vmSymbols::signature_name(), vmSymbols::string_signature());
2258   compute_optional_offset(annotations_offset,  k, vmSymbols::annotations_name(),  vmSymbols::byte_array_signature());
2259   compute_optional_offset(type_annotations_offset,  k, vmSymbols::type_annotations_name(),  vmSymbols::byte_array_signature());
2260 }
2261 
2262 Handle java_lang_reflect_Field::create(TRAPS) {
2263   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2264   Symbol* name = vmSymbols::java_lang_reflect_Field();
2265   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
2266   instanceKlassHandle klass (THREAD, k);
2267   // Ensure it is initialized
2268   klass-&gt;initialize(CHECK_NH);
2269   return klass-&gt;allocate_instance_handle(CHECK_NH);
2270 }
2271 
2272 oop java_lang_reflect_Field::clazz(oop reflect) {
2273   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2274   return reflect-&gt;obj_field(clazz_offset);
2275 }
2276 
2277 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
2278   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2279    reflect-&gt;obj_field_put(clazz_offset, value);
2280 }
2281 
2282 oop java_lang_reflect_Field::name(oop field) {
2283   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2284   return field-&gt;obj_field(name_offset);
2285 }
2286 
2287 void java_lang_reflect_Field::set_name(oop field, oop value) {
2288   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2289   field-&gt;obj_field_put(name_offset, value);
2290 }
2291 
2292 oop java_lang_reflect_Field::type(oop field) {
2293   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2294   return field-&gt;obj_field(type_offset);
2295 }
2296 
2297 void java_lang_reflect_Field::set_type(oop field, oop value) {
2298   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2299   field-&gt;obj_field_put(type_offset, value);
2300 }
2301 
2302 int java_lang_reflect_Field::slot(oop reflect) {
2303   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2304   return reflect-&gt;int_field(slot_offset);
2305 }
2306 
2307 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
2308   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2309   reflect-&gt;int_field_put(slot_offset, value);
2310 }
2311 
2312 int java_lang_reflect_Field::modifiers(oop field) {
2313   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2314   return field-&gt;int_field(modifiers_offset);
2315 }
2316 
2317 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
2318   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2319   field-&gt;int_field_put(modifiers_offset, value);
2320 }
2321 
2322 bool java_lang_reflect_Field::has_signature_field() {
2323   return (signature_offset &gt;= 0);
2324 }
2325 
2326 oop java_lang_reflect_Field::signature(oop field) {
2327   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2328   assert(has_signature_field(), "signature field must be present");
2329   return field-&gt;obj_field(signature_offset);
2330 }
2331 
2332 void java_lang_reflect_Field::set_signature(oop field, oop value) {
2333   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2334   assert(has_signature_field(), "signature field must be present");
2335   field-&gt;obj_field_put(signature_offset, value);
2336 }
2337 
2338 bool java_lang_reflect_Field::has_annotations_field() {
2339   return (annotations_offset &gt;= 0);
2340 }
2341 
2342 oop java_lang_reflect_Field::annotations(oop field) {
2343   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2344   assert(has_annotations_field(), "annotations field must be present");
2345   return field-&gt;obj_field(annotations_offset);
2346 }
2347 
2348 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
2349   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2350   assert(has_annotations_field(), "annotations field must be present");
2351   field-&gt;obj_field_put(annotations_offset, value);
2352 }
2353 
2354 bool java_lang_reflect_Field::has_type_annotations_field() {
2355   return (type_annotations_offset &gt;= 0);
2356 }
2357 
2358 oop java_lang_reflect_Field::type_annotations(oop field) {
2359   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2360   assert(has_type_annotations_field(), "type_annotations field must be present");
2361   return field-&gt;obj_field(type_annotations_offset);
2362 }
2363 
2364 void java_lang_reflect_Field::set_type_annotations(oop field, oop value) {
2365   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2366   assert(has_type_annotations_field(), "type_annotations field must be present");
2367   field-&gt;obj_field_put(type_annotations_offset, value);
2368 }
2369 
2370 void sun_reflect_ConstantPool::compute_offsets() {
2371   Klass* k = SystemDictionary::reflect_ConstantPool_klass();
2372   // This null test can be removed post beta
2373   if (k != NULL) {
2374     // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
2375     compute_offset(_oop_offset, k, vmSymbols::ConstantPool_name(), vmSymbols::object_signature());
2376   }
2377 }
2378 
2379 void java_lang_reflect_Parameter::compute_offsets() {
2380   Klass* k = SystemDictionary::reflect_Parameter_klass();
2381   if(NULL != k) {
2382     compute_offset(name_offset,        k, vmSymbols::name_name(),        vmSymbols::string_signature());
2383     compute_offset(modifiers_offset,   k, vmSymbols::modifiers_name(),   vmSymbols::int_signature());
2384     compute_offset(index_offset,       k, vmSymbols::index_name(),       vmSymbols::int_signature());
2385     compute_offset(executable_offset,  k, vmSymbols::executable_name(),  vmSymbols::executable_signature());
2386   }
2387 }
2388 
2389 Handle java_lang_reflect_Parameter::create(TRAPS) {
2390   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2391   Symbol* name = vmSymbols::java_lang_reflect_Parameter();
2392   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
2393   instanceKlassHandle klass (THREAD, k);
2394   // Ensure it is initialized
2395   klass-&gt;initialize(CHECK_NH);
2396   return klass-&gt;allocate_instance_handle(CHECK_NH);
2397 }
2398 
2399 oop java_lang_reflect_Parameter::name(oop param) {
2400   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2401   return param-&gt;obj_field(name_offset);
2402 }
2403 
2404 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
2405   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2406   param-&gt;obj_field_put(name_offset, value);
2407 }
2408 
2409 int java_lang_reflect_Parameter::modifiers(oop param) {
2410   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2411   return param-&gt;int_field(modifiers_offset);
2412 }
2413 
2414 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
2415   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2416   param-&gt;int_field_put(modifiers_offset, value);
2417 }
2418 
2419 int java_lang_reflect_Parameter::index(oop param) {
2420   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2421   return param-&gt;int_field(index_offset);
2422 }
2423 
2424 void java_lang_reflect_Parameter::set_index(oop param, int value) {
2425   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2426   param-&gt;int_field_put(index_offset, value);
2427 }
2428 
2429 oop java_lang_reflect_Parameter::executable(oop param) {
2430   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2431   return param-&gt;obj_field(executable_offset);
2432 }
2433 
2434 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
2435   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2436   param-&gt;obj_field_put(executable_offset, value);
2437 }
2438 
2439 
2440 Handle sun_reflect_ConstantPool::create(TRAPS) {
2441   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2442   Klass* k = SystemDictionary::reflect_ConstantPool_klass();
2443   instanceKlassHandle klass (THREAD, k);
2444   // Ensure it is initialized
2445   klass-&gt;initialize(CHECK_NH);
2446   return klass-&gt;allocate_instance_handle(CHECK_NH);
2447 }
2448 
2449 
2450 void sun_reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {
2451   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2452   oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
2453   // Save the mirror to get back the constant pool.
2454   reflect-&gt;obj_field_put(_oop_offset, mirror);
2455 }
2456 
2457 ConstantPool* sun_reflect_ConstantPool::get_cp(oop reflect) {
2458   assert(Universe::is_fully_initialized(), "Need to find another solution to the reflection problem");
2459 
2460   oop mirror = reflect-&gt;obj_field(_oop_offset);
2461   Klass* k = java_lang_Class::as_Klass(mirror);
2462   assert(k-&gt;oop_is_instance(), "Must be");
2463 
2464   // Get the constant pool back from the klass.  Since class redefinition
2465   // merges the new constant pool into the old, this is essentially the
2466   // same constant pool as the original.  If constant pool merging is
2467   // no longer done in the future, this will have to change to save
2468   // the original.
2469   return InstanceKlass::cast(k)-&gt;constants();
2470 }
2471 
2472 void sun_reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
2473   Klass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
2474   // This null test can be removed post beta
2475   if (k != NULL) {
2476     compute_offset(_base_offset, k,
2477                    vmSymbols::base_name(), vmSymbols::object_signature());
2478   }
2479 }
2480 
2481 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
2482   Klass* k = SystemDictionary::box_klass(type);
2483   if (k == NULL)  return NULL;
2484   instanceKlassHandle h (THREAD, k);
2485   if (!h-&gt;is_initialized())  h-&gt;initialize(CHECK_0);
2486   return h-&gt;allocate_instance(THREAD);
2487 }
2488 
2489 
2490 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
2491   oop box = initialize_and_allocate(type, CHECK_0);
2492   if (box == NULL)  return NULL;
2493   switch (type) {
2494     case T_BOOLEAN:
2495       box-&gt;bool_field_put(value_offset, value-&gt;z);
2496       break;
2497     case T_CHAR:
2498       box-&gt;char_field_put(value_offset, value-&gt;c);
2499       break;
2500     case T_FLOAT:
2501       box-&gt;float_field_put(value_offset, value-&gt;f);
2502       break;
2503     case T_DOUBLE:
2504       box-&gt;double_field_put(long_value_offset, value-&gt;d);
2505       break;
2506     case T_BYTE:
2507       box-&gt;byte_field_put(value_offset, value-&gt;b);
2508       break;
2509     case T_SHORT:
2510       box-&gt;short_field_put(value_offset, value-&gt;s);
2511       break;
2512     case T_INT:
2513       box-&gt;int_field_put(value_offset, value-&gt;i);
2514       break;
2515     case T_LONG:
2516       box-&gt;long_field_put(long_value_offset, value-&gt;j);
2517       break;
2518     default:
2519       return NULL;
2520   }
2521   return box;
2522 }
2523 
2524 
2525 BasicType java_lang_boxing_object::basic_type(oop box) {
2526   if (box == NULL)  return T_ILLEGAL;
2527   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
2528   if (type == T_OBJECT)         // 'unknown' value returned by SD::bkt
2529     return T_ILLEGAL;
2530   return type;
2531 }
2532 
2533 
2534 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
2535   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
2536   switch (type) {
2537   case T_BOOLEAN:
2538     value-&gt;z = box-&gt;bool_field(value_offset);
2539     break;
2540   case T_CHAR:
2541     value-&gt;c = box-&gt;char_field(value_offset);
2542     break;
2543   case T_FLOAT:
2544     value-&gt;f = box-&gt;float_field(value_offset);
2545     break;
2546   case T_DOUBLE:
2547     value-&gt;d = box-&gt;double_field(long_value_offset);
2548     break;
2549   case T_BYTE:
2550     value-&gt;b = box-&gt;byte_field(value_offset);
2551     break;
2552   case T_SHORT:
2553     value-&gt;s = box-&gt;short_field(value_offset);
2554     break;
2555   case T_INT:
2556     value-&gt;i = box-&gt;int_field(value_offset);
2557     break;
2558   case T_LONG:
2559     value-&gt;j = box-&gt;long_field(long_value_offset);
2560     break;
2561   default:
2562     return T_ILLEGAL;
2563   } // end switch
2564   return type;
2565 }
2566 
2567 
2568 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
2569   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
2570   switch (type) {
2571   case T_BOOLEAN:
2572     box-&gt;bool_field_put(value_offset, value-&gt;z);
2573     break;
2574   case T_CHAR:
2575     box-&gt;char_field_put(value_offset, value-&gt;c);
2576     break;
2577   case T_FLOAT:
2578     box-&gt;float_field_put(value_offset, value-&gt;f);
2579     break;
2580   case T_DOUBLE:
2581     box-&gt;double_field_put(long_value_offset, value-&gt;d);
2582     break;
2583   case T_BYTE:
2584     box-&gt;byte_field_put(value_offset, value-&gt;b);
2585     break;
2586   case T_SHORT:
2587     box-&gt;short_field_put(value_offset, value-&gt;s);
2588     break;
2589   case T_INT:
2590     box-&gt;int_field_put(value_offset, value-&gt;i);
2591     break;
2592   case T_LONG:
2593     box-&gt;long_field_put(long_value_offset, value-&gt;j);
2594     break;
2595   default:
2596     return T_ILLEGAL;
2597   } // end switch
2598   return type;
2599 }
2600 
2601 
2602 void java_lang_boxing_object::print(BasicType type, jvalue* value, outputStream* st) {
2603   switch (type) {
2604   case T_BOOLEAN:   st-&gt;print("%s", value-&gt;z ? "true" : "false");   break;
2605   case T_CHAR:      st-&gt;print("%d", value-&gt;c);                      break;
2606   case T_BYTE:      st-&gt;print("%d", value-&gt;b);                      break;
2607   case T_SHORT:     st-&gt;print("%d", value-&gt;s);                      break;
2608   case T_INT:       st-&gt;print("%d", value-&gt;i);                      break;
2609   case T_LONG:      st-&gt;print(INT64_FORMAT, value-&gt;j);              break;
2610   case T_FLOAT:     st-&gt;print("%f", value-&gt;f);                      break;
2611   case T_DOUBLE:    st-&gt;print("%lf", value-&gt;d);                     break;
2612   default:          st-&gt;print("type %d?", type);                    break;
2613   }
2614 }
2615 
2616 
2617 // Support for java_lang_ref_Reference
2618 HeapWord *java_lang_ref_Reference::pending_list_lock_addr() {
2619   InstanceKlass* ik = InstanceKlass::cast(SystemDictionary::Reference_klass());
2620   address addr = ik-&gt;static_field_addr(static_lock_offset);
2621   return (HeapWord*) addr;
2622 }
2623 
2624 oop java_lang_ref_Reference::pending_list_lock() {
2625   InstanceKlass* ik = InstanceKlass::cast(SystemDictionary::Reference_klass());
2626   address addr = ik-&gt;static_field_addr(static_lock_offset);
2627   if (UseCompressedOops) {
2628     return oopDesc::load_decode_heap_oop((narrowOop *)addr);
2629   } else {
2630     return oopDesc::load_decode_heap_oop((oop*)addr);
2631   }
2632 }
2633 
2634 HeapWord *java_lang_ref_Reference::pending_list_addr() {
2635   InstanceKlass* ik = InstanceKlass::cast(SystemDictionary::Reference_klass());
2636   address addr = ik-&gt;static_field_addr(static_pending_offset);
2637   // XXX This might not be HeapWord aligned, almost rather be char *.
2638   return (HeapWord*)addr;
2639 }
2640 
2641 oop java_lang_ref_Reference::pending_list() {
2642   char *addr = (char *)pending_list_addr();
2643   if (UseCompressedOops) {
2644     return oopDesc::load_decode_heap_oop((narrowOop *)addr);
2645   } else {
2646     return oopDesc::load_decode_heap_oop((oop*)addr);
2647   }
2648 }
2649 
2650 
2651 // Support for java_lang_ref_SoftReference
2652 
2653 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
2654   return ref-&gt;long_field(timestamp_offset);
2655 }
2656 
2657 jlong java_lang_ref_SoftReference::clock() {
2658   InstanceKlass* ik = InstanceKlass::cast(SystemDictionary::SoftReference_klass());
2659   jlong* offset = (jlong*)ik-&gt;static_field_addr(static_clock_offset);
2660   return *offset;
2661 }
2662 
2663 void java_lang_ref_SoftReference::set_clock(jlong value) {
2664   InstanceKlass* ik = InstanceKlass::cast(SystemDictionary::SoftReference_klass());
2665   jlong* offset = (jlong*)ik-&gt;static_field_addr(static_clock_offset);
2666   *offset = value;
2667 }
2668 
2669 // Support for java_lang_invoke_DirectMethodHandle
2670 
2671 int java_lang_invoke_DirectMethodHandle::_member_offset;
2672 
2673 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
2674   oop member_name = NULL;
2675   bool is_dmh = dmh-&gt;is_oop() &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh);
2676   assert(is_dmh, "a DirectMethodHandle oop is expected");
2677   if (is_dmh) {
2678     member_name = dmh-&gt;obj_field(member_offset_in_bytes());
2679   }
2680   return member_name;
2681 }
2682 
2683 void java_lang_invoke_DirectMethodHandle::compute_offsets() {
2684   Klass* klass_oop = SystemDictionary::DirectMethodHandle_klass();
2685   if (klass_oop != NULL &amp;&amp; EnableInvokeDynamic) {
2686     compute_offset(_member_offset, klass_oop, vmSymbols::member_name(), vmSymbols::java_lang_invoke_MemberName_signature());
2687   }
2688 }
2689 
2690 // Support for java_lang_invoke_MethodHandle
2691 
2692 int java_lang_invoke_MethodHandle::_type_offset;
2693 int java_lang_invoke_MethodHandle::_form_offset;
2694 
2695 int java_lang_invoke_MemberName::_clazz_offset;
2696 int java_lang_invoke_MemberName::_name_offset;
2697 int java_lang_invoke_MemberName::_type_offset;
2698 int java_lang_invoke_MemberName::_flags_offset;
2699 int java_lang_invoke_MemberName::_vmtarget_offset;
2700 int java_lang_invoke_MemberName::_vmloader_offset;
2701 int java_lang_invoke_MemberName::_vmindex_offset;
2702 
2703 int java_lang_invoke_LambdaForm::_vmentry_offset;
2704 
2705 void java_lang_invoke_MethodHandle::compute_offsets() {
2706   Klass* klass_oop = SystemDictionary::MethodHandle_klass();
2707   if (klass_oop != NULL &amp;&amp; EnableInvokeDynamic) {
2708     compute_offset(_type_offset, klass_oop, vmSymbols::type_name(), vmSymbols::java_lang_invoke_MethodType_signature());
2709     compute_optional_offset(_form_offset, klass_oop, vmSymbols::form_name(), vmSymbols::java_lang_invoke_LambdaForm_signature());
2710     if (_form_offset == 0) {
2711       EnableInvokeDynamic = false;
2712     }
2713   }
2714 }
2715 
2716 void java_lang_invoke_MemberName::compute_offsets() {
2717   Klass* klass_oop = SystemDictionary::MemberName_klass();
2718   if (klass_oop != NULL &amp;&amp; EnableInvokeDynamic) {
2719     compute_offset(_clazz_offset,     klass_oop, vmSymbols::clazz_name(),     vmSymbols::class_signature());
2720     compute_offset(_name_offset,      klass_oop, vmSymbols::name_name(),      vmSymbols::string_signature());
2721     compute_offset(_type_offset,      klass_oop, vmSymbols::type_name(),      vmSymbols::object_signature());
2722     compute_offset(_flags_offset,     klass_oop, vmSymbols::flags_name(),     vmSymbols::int_signature());
2723     MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
2724   }
2725 }
2726 
2727 void java_lang_invoke_LambdaForm::compute_offsets() {
2728   Klass* klass_oop = SystemDictionary::LambdaForm_klass();
2729   if (klass_oop != NULL &amp;&amp; EnableInvokeDynamic) {
2730     compute_offset(_vmentry_offset, klass_oop, vmSymbols::vmentry_name(), vmSymbols::java_lang_invoke_MemberName_signature());
2731   }
2732 }
2733 
2734 oop java_lang_invoke_MethodHandle::type(oop mh) {
2735   return mh-&gt;obj_field(_type_offset);
2736 }
2737 
2738 void java_lang_invoke_MethodHandle::set_type(oop mh, oop mtype) {
2739   mh-&gt;obj_field_put(_type_offset, mtype);
2740 }
2741 
2742 oop java_lang_invoke_MethodHandle::form(oop mh) {
2743   assert(_form_offset != 0, "");
2744   return mh-&gt;obj_field(_form_offset);
2745 }
2746 
2747 void java_lang_invoke_MethodHandle::set_form(oop mh, oop lform) {
2748   assert(_form_offset != 0, "");
2749   mh-&gt;obj_field_put(_form_offset, lform);
2750 }
2751 
2752 /// MemberName accessors
2753 
2754 oop java_lang_invoke_MemberName::clazz(oop mname) {
2755   assert(is_instance(mname), "wrong type");
2756   return mname-&gt;obj_field(_clazz_offset);
2757 }
2758 
2759 void java_lang_invoke_MemberName::set_clazz(oop mname, oop clazz) {
2760   assert(is_instance(mname), "wrong type");
2761   mname-&gt;obj_field_put(_clazz_offset, clazz);
2762 }
2763 
2764 oop java_lang_invoke_MemberName::name(oop mname) {
2765   assert(is_instance(mname), "wrong type");
2766   return mname-&gt;obj_field(_name_offset);
2767 }
2768 
2769 void java_lang_invoke_MemberName::set_name(oop mname, oop name) {
2770   assert(is_instance(mname), "wrong type");
2771   mname-&gt;obj_field_put(_name_offset, name);
2772 }
2773 
2774 oop java_lang_invoke_MemberName::type(oop mname) {
2775   assert(is_instance(mname), "wrong type");
2776   return mname-&gt;obj_field(_type_offset);
2777 }
2778 
2779 void java_lang_invoke_MemberName::set_type(oop mname, oop type) {
2780   assert(is_instance(mname), "wrong type");
2781   mname-&gt;obj_field_put(_type_offset, type);
2782 }
2783 
2784 int java_lang_invoke_MemberName::flags(oop mname) {
2785   assert(is_instance(mname), "wrong type");
2786   return mname-&gt;int_field(_flags_offset);
2787 }
2788 
2789 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
2790   assert(is_instance(mname), "wrong type");
2791   mname-&gt;int_field_put(_flags_offset, flags);
2792 }
2793 
2794 Metadata* java_lang_invoke_MemberName::vmtarget(oop mname) {
2795   assert(is_instance(mname), "wrong type");
2796   return (Metadata*)mname-&gt;address_field(_vmtarget_offset);
2797 }
2798 
2799 bool java_lang_invoke_MemberName::is_method(oop mname) {
2800   assert(is_instance(mname), "must be MemberName");
2801   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) &gt; 0;
2802 }
2803 
2804 void java_lang_invoke_MemberName::set_vmtarget(oop mname, Metadata* ref) {
2805   assert(is_instance(mname), "wrong type");
2806   // check the type of the vmtarget
2807   oop dependency = NULL;
2808   if (ref != NULL) {
2809     switch (flags(mname) &amp; (MN_IS_METHOD |
2810                             MN_IS_CONSTRUCTOR |
2811                             MN_IS_FIELD)) {
2812     case MN_IS_METHOD:
2813     case MN_IS_CONSTRUCTOR:
2814       assert(ref-&gt;is_method(), "should be a method");
2815       dependency = ((Method*)ref)-&gt;method_holder()-&gt;java_mirror();
2816       break;
2817     case MN_IS_FIELD:
2818       assert(ref-&gt;is_klass(), "should be a class");
2819       dependency = ((Klass*)ref)-&gt;java_mirror();
2820       break;
2821     default:
2822       ShouldNotReachHere();
2823     }
2824   }
2825   mname-&gt;address_field_put(_vmtarget_offset, (address)ref);
2826   // Add a reference to the loader (actually mirror because anonymous classes will not have
2827   // distinct loaders) to ensure the metadata is kept alive
2828   // This mirror may be different than the one in clazz field.
2829   mname-&gt;obj_field_put(_vmloader_offset, dependency);
2830 }
2831 
2832 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
2833   assert(is_instance(mname), "wrong type");
2834   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
2835 }
2836 
2837 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
2838   assert(is_instance(mname), "wrong type");
2839   mname-&gt;address_field_put(_vmindex_offset, (address) index);
2840 }
2841 
2842 oop java_lang_invoke_LambdaForm::vmentry(oop lform) {
2843   assert(is_instance(lform), "wrong type");
2844   return lform-&gt;obj_field(_vmentry_offset);
2845 }
2846 
2847 
2848 // Support for java_lang_invoke_MethodType
2849 
2850 int java_lang_invoke_MethodType::_rtype_offset;
2851 int java_lang_invoke_MethodType::_ptypes_offset;
2852 
2853 void java_lang_invoke_MethodType::compute_offsets() {
2854   Klass* k = SystemDictionary::MethodType_klass();
2855   if (k != NULL) {
2856     compute_offset(_rtype_offset,  k, vmSymbols::rtype_name(),  vmSymbols::class_signature());
2857     compute_offset(_ptypes_offset, k, vmSymbols::ptypes_name(), vmSymbols::class_array_signature());
2858   }
2859 }
2860 
2861 void java_lang_invoke_MethodType::print_signature(oop mt, outputStream* st) {
2862   st-&gt;print("(");
2863   objArrayOop pts = ptypes(mt);
2864   for (int i = 0, limit = pts-&gt;length(); i &lt; limit; i++) {
2865     java_lang_Class::print_signature(pts-&gt;obj_at(i), st);
2866   }
2867   st-&gt;print(")");
2868   java_lang_Class::print_signature(rtype(mt), st);
2869 }
2870 
2871 Symbol* java_lang_invoke_MethodType::as_signature(oop mt, bool intern_if_not_found, TRAPS) {
2872   ResourceMark rm;
2873   stringStream buffer(128);
2874   print_signature(mt, &amp;buffer);
2875   const char* sigstr =       buffer.base();
2876   int         siglen = (int) buffer.size();
2877   Symbol *name;
2878   if (!intern_if_not_found) {
2879     name = SymbolTable::probe(sigstr, siglen);
2880   } else {
2881     name = SymbolTable::new_symbol(sigstr, siglen, THREAD);
2882   }
2883   return name;
2884 }
2885 
2886 bool java_lang_invoke_MethodType::equals(oop mt1, oop mt2) {
2887   if (mt1 == mt2)
2888     return true;
2889   if (rtype(mt1) != rtype(mt2))
2890     return false;
2891   if (ptype_count(mt1) != ptype_count(mt2))
2892     return false;
2893   for (int i = ptype_count(mt1) - 1; i &gt;= 0; i--) {
2894     if (ptype(mt1, i) != ptype(mt2, i))
2895       return false;
2896   }
2897   return true;
2898 }
2899 
2900 oop java_lang_invoke_MethodType::rtype(oop mt) {
2901   assert(is_instance(mt), "must be a MethodType");
2902   return mt-&gt;obj_field(_rtype_offset);
2903 }
2904 
2905 objArrayOop java_lang_invoke_MethodType::ptypes(oop mt) {
2906   assert(is_instance(mt), "must be a MethodType");
2907   return (objArrayOop) mt-&gt;obj_field(_ptypes_offset);
2908 }
2909 
2910 oop java_lang_invoke_MethodType::ptype(oop mt, int idx) {
2911   return ptypes(mt)-&gt;obj_at(idx);
2912 }
2913 
2914 int java_lang_invoke_MethodType::ptype_count(oop mt) {
2915   return ptypes(mt)-&gt;length();
2916 }
2917 
2918 int java_lang_invoke_MethodType::ptype_slot_count(oop mt) {
2919   objArrayOop pts = ptypes(mt);
2920   int count = pts-&gt;length();
2921   int slots = 0;
2922   for (int i = 0; i &lt; count; i++) {
2923     BasicType bt = java_lang_Class::as_BasicType(pts-&gt;obj_at(i));
2924     slots += type2size[bt];
2925   }
2926   return slots;
2927 }
2928 
2929 int java_lang_invoke_MethodType::rtype_slot_count(oop mt) {
2930   BasicType bt = java_lang_Class::as_BasicType(rtype(mt));
2931   return type2size[bt];
2932 }
2933 
2934 
2935 // Support for java_lang_invoke_CallSite
2936 
2937 int java_lang_invoke_CallSite::_target_offset;
2938 
2939 void java_lang_invoke_CallSite::compute_offsets() {
2940   if (!EnableInvokeDynamic)  return;
2941   Klass* k = SystemDictionary::CallSite_klass();
2942   if (k != NULL) {
2943     compute_offset(_target_offset, k, vmSymbols::target_name(), vmSymbols::java_lang_invoke_MethodHandle_signature());
2944   }
2945 }
2946 
2947 
2948 // Support for java_security_AccessControlContext
2949 
2950 int java_security_AccessControlContext::_context_offset = 0;
2951 int java_security_AccessControlContext::_privilegedContext_offset = 0;
2952 int java_security_AccessControlContext::_isPrivileged_offset = 0;
2953 int java_security_AccessControlContext::_isAuthorized_offset = -1;
2954 
2955 void java_security_AccessControlContext::compute_offsets() {
2956   assert(_isPrivileged_offset == 0, "offsets should be initialized only once");
2957   fieldDescriptor fd;
2958   InstanceKlass* ik = InstanceKlass::cast(SystemDictionary::AccessControlContext_klass());
2959 
2960   if (!ik-&gt;find_local_field(vmSymbols::context_name(), vmSymbols::protectiondomain_signature(), &amp;fd)) {
2961     fatal("Invalid layout of java.security.AccessControlContext");
2962   }
2963   _context_offset = fd.offset();
2964 
2965   if (!ik-&gt;find_local_field(vmSymbols::privilegedContext_name(), vmSymbols::accesscontrolcontext_signature(), &amp;fd)) {
2966     fatal("Invalid layout of java.security.AccessControlContext");
2967   }
2968   _privilegedContext_offset = fd.offset();
2969 
2970   if (!ik-&gt;find_local_field(vmSymbols::isPrivileged_name(), vmSymbols::bool_signature(), &amp;fd)) {
2971     fatal("Invalid layout of java.security.AccessControlContext");
2972   }
2973   _isPrivileged_offset = fd.offset();
2974 
2975   // The offset may not be present for bootstrapping with older JDK.
2976   if (ik-&gt;find_local_field(vmSymbols::isAuthorized_name(), vmSymbols::bool_signature(), &amp;fd)) {
2977     _isAuthorized_offset = fd.offset();
2978   }
2979 }
2980 
2981 
2982 bool java_security_AccessControlContext::is_authorized(Handle context) {
2983   assert(context.not_null() &amp;&amp; context-&gt;klass() == SystemDictionary::AccessControlContext_klass(), "Invalid type");
2984   assert(_isAuthorized_offset != -1, "should be set");
2985   return context-&gt;bool_field(_isAuthorized_offset) != 0;
2986 }
2987 
2988 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
2989   assert(_isPrivileged_offset != 0, "offsets should have been initialized");
2990   // Ensure klass is initialized
2991   InstanceKlass::cast(SystemDictionary::AccessControlContext_klass())-&gt;initialize(CHECK_0);
2992   // Allocate result
2993   oop result = InstanceKlass::cast(SystemDictionary::AccessControlContext_klass())-&gt;allocate_instance(CHECK_0);
2994   // Fill in values
2995   result-&gt;obj_field_put(_context_offset, context());
2996   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
2997   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
2998   // whitelist AccessControlContexts created by the JVM if present
2999   if (_isAuthorized_offset != -1) {
3000     result-&gt;bool_field_put(_isAuthorized_offset, true);
3001   }
3002   return result;
3003 }
3004 
3005 
3006 // Support for java_lang_ClassLoader
3007 
3008 bool java_lang_ClassLoader::offsets_computed = false;
3009 int  java_lang_ClassLoader::_loader_data_offset = -1;
3010 int  java_lang_ClassLoader::parallelCapable_offset = -1;
3011 
3012 ClassLoaderData** java_lang_ClassLoader::loader_data_addr(oop loader) {
3013     assert(loader != NULL &amp;&amp; loader-&gt;is_oop(), "loader must be oop");
3014     return (ClassLoaderData**) loader-&gt;address_field_addr(_loader_data_offset);
3015 }
3016 
3017 ClassLoaderData* java_lang_ClassLoader::loader_data(oop loader) {
3018   return *java_lang_ClassLoader::loader_data_addr(loader);
3019 }
3020 
3021 void java_lang_ClassLoader::compute_offsets() {
3022   assert(!offsets_computed, "offsets should be initialized only once");
3023   offsets_computed = true;
3024 
3025   // The field indicating parallelCapable (parallelLockMap) is only present starting in 7,
3026   Klass* k1 = SystemDictionary::ClassLoader_klass();
3027   compute_optional_offset(parallelCapable_offset,
3028     k1, vmSymbols::parallelCapable_name(), vmSymbols::concurrenthashmap_signature());
3029 
3030   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3031 }
3032 
3033 oop java_lang_ClassLoader::parent(oop loader) {
3034   assert(is_instance(loader), "loader must be oop");
3035   return loader-&gt;obj_field(parent_offset);
3036 }
3037 
3038 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
3039   assert(is_instance(loader), "loader must be oop");
3040   assert(cl == NULL || is_instance(cl), "cl argument must be oop");
3041   oop acl = loader;
3042   debug_only(jint loop_count = 0);
3043   // This loop taken verbatim from ClassLoader.java:
3044   do {
3045     acl = parent(acl);
3046     if (cl == acl) {
3047       return true;
3048     }
3049     assert(++loop_count &gt; 0, "loop_count overflow");
3050   } while (acl != NULL);
3051   return false;
3052 }
3053 
3054 
3055 // For class loader classes, parallelCapable defined
3056 // based on non-null field
3057 // Written to by java.lang.ClassLoader, vm only reads this field, doesn't set it
3058 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
3059   if (!JDK_Version::is_gte_jdk17x_version()
3060      || parallelCapable_offset == -1) {
3061      // Default for backward compatibility is false
3062      return false;
3063   }
3064   return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);
3065 }
3066 
3067 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
3068   // Fix for 4474172; see evaluation for more details
3069   loader = non_reflection_class_loader(loader);
3070 
3071   oop cl = SystemDictionary::java_system_loader();
3072   while(cl != NULL) {
3073     if (cl == loader) return true;
3074     cl = parent(cl);
3075   }
3076   return false;
3077 }
3078 
3079 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
3080   if (loader != NULL) {
3081     // See whether this is one of the class loaders associated with
3082     // the generated bytecodes for reflection, and if so, "magically"
3083     // delegate to its parent to prevent class loading from occurring
3084     // in places where applications using reflection didn't expect it.
3085     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
3086     // This might be null in non-1.4 JDKs
3087     if (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class)) {
3088       return parent(loader);
3089     }
3090   }
3091   return loader;
3092 }
3093 
3094 
3095 // Support for java_lang_System
3096 int java_lang_System::in_offset_in_bytes() {
3097   return (InstanceMirrorKlass::offset_of_static_fields() + static_in_offset);
3098 }
3099 
3100 
3101 int java_lang_System::out_offset_in_bytes() {
3102   return (InstanceMirrorKlass::offset_of_static_fields() + static_out_offset);
3103 }
3104 
3105 
3106 int java_lang_System::err_offset_in_bytes() {
3107   return (InstanceMirrorKlass::offset_of_static_fields() + static_err_offset);
3108 }
3109 
3110 
3111 bool java_lang_System::has_security_manager() {
3112   InstanceKlass* ik = InstanceKlass::cast(SystemDictionary::System_klass());
3113   address addr = ik-&gt;static_field_addr(static_security_offset);
3114   if (UseCompressedOops) {
3115     return oopDesc::load_decode_heap_oop((narrowOop *)addr) != NULL;
3116   } else {
3117     return oopDesc::load_decode_heap_oop((oop*)addr) != NULL;
3118   }
3119 }
3120 
3121 int java_lang_Class::_klass_offset;
3122 int java_lang_Class::_array_klass_offset;
3123 int java_lang_Class::_oop_size_offset;
3124 int java_lang_Class::_static_oop_field_count_offset;
3125 int java_lang_Class::_class_loader_offset;
3126 int java_lang_Class::_protection_domain_offset;
3127 int java_lang_Class::_init_lock_offset;
3128 int java_lang_Class::_signers_offset;
3129 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
3130 int java_lang_Throwable::backtrace_offset;
3131 int java_lang_Throwable::detailMessage_offset;
3132 int java_lang_Throwable::cause_offset;
3133 int java_lang_Throwable::stackTrace_offset;
3134 int java_lang_Throwable::static_unassigned_stacktrace_offset;
3135 int java_lang_reflect_AccessibleObject::override_offset;
3136 int java_lang_reflect_Method::clazz_offset;
3137 int java_lang_reflect_Method::name_offset;
3138 int java_lang_reflect_Method::returnType_offset;
3139 int java_lang_reflect_Method::parameterTypes_offset;
3140 int java_lang_reflect_Method::exceptionTypes_offset;
3141 int java_lang_reflect_Method::slot_offset;
3142 int java_lang_reflect_Method::modifiers_offset;
3143 int java_lang_reflect_Method::signature_offset;
3144 int java_lang_reflect_Method::annotations_offset;
3145 int java_lang_reflect_Method::parameter_annotations_offset;
3146 int java_lang_reflect_Method::annotation_default_offset;
3147 int java_lang_reflect_Method::type_annotations_offset;
3148 int java_lang_reflect_Constructor::clazz_offset;
3149 int java_lang_reflect_Constructor::parameterTypes_offset;
3150 int java_lang_reflect_Constructor::exceptionTypes_offset;
3151 int java_lang_reflect_Constructor::slot_offset;
3152 int java_lang_reflect_Constructor::modifiers_offset;
3153 int java_lang_reflect_Constructor::signature_offset;
3154 int java_lang_reflect_Constructor::annotations_offset;
3155 int java_lang_reflect_Constructor::parameter_annotations_offset;
3156 int java_lang_reflect_Constructor::type_annotations_offset;
3157 int java_lang_reflect_Field::clazz_offset;
3158 int java_lang_reflect_Field::name_offset;
3159 int java_lang_reflect_Field::type_offset;
3160 int java_lang_reflect_Field::slot_offset;
3161 int java_lang_reflect_Field::modifiers_offset;
3162 int java_lang_reflect_Field::signature_offset;
3163 int java_lang_reflect_Field::annotations_offset;
3164 int java_lang_reflect_Field::type_annotations_offset;
3165 int java_lang_reflect_Parameter::name_offset;
3166 int java_lang_reflect_Parameter::modifiers_offset;
3167 int java_lang_reflect_Parameter::index_offset;
3168 int java_lang_reflect_Parameter::executable_offset;
3169 int java_lang_boxing_object::value_offset;
3170 int java_lang_boxing_object::long_value_offset;
3171 int java_lang_ref_Reference::referent_offset;
3172 int java_lang_ref_Reference::queue_offset;
3173 int java_lang_ref_Reference::next_offset;
3174 int java_lang_ref_Reference::discovered_offset;
3175 int java_lang_ref_Reference::static_lock_offset;
3176 int java_lang_ref_Reference::static_pending_offset;
3177 int java_lang_ref_Reference::number_of_fake_oop_fields;
3178 int java_lang_ref_SoftReference::timestamp_offset;
3179 int java_lang_ref_SoftReference::static_clock_offset;
3180 int java_lang_ClassLoader::parent_offset;
3181 int java_lang_System::static_in_offset;
3182 int java_lang_System::static_out_offset;
3183 int java_lang_System::static_err_offset;
3184 int java_lang_System::static_security_offset;
3185 int java_lang_StackTraceElement::declaringClass_offset;
3186 int java_lang_StackTraceElement::methodName_offset;
3187 int java_lang_StackTraceElement::fileName_offset;
3188 int java_lang_StackTraceElement::lineNumber_offset;
3189 int java_lang_AssertionStatusDirectives::classes_offset;
3190 int java_lang_AssertionStatusDirectives::classEnabled_offset;
3191 int java_lang_AssertionStatusDirectives::packages_offset;
3192 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
3193 int java_lang_AssertionStatusDirectives::deflt_offset;
3194 int java_nio_Buffer::_limit_offset;
3195 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset = 0;
3196 int sun_reflect_ConstantPool::_oop_offset;
3197 int sun_reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
3198 
3199 
3200 // Support for java_lang_StackTraceElement
3201 
3202 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
3203   element-&gt;obj_field_put(fileName_offset, value);
3204 }
3205 
3206 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
3207   element-&gt;obj_field_put(declaringClass_offset, value);
3208 }
3209 
3210 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
3211   element-&gt;obj_field_put(methodName_offset, value);
3212 }
3213 
3214 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
3215   element-&gt;int_field_put(lineNumber_offset, value);
3216 }
3217 
3218 
3219 // Support for java Assertions - java_lang_AssertionStatusDirectives.
3220 
3221 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
3222   o-&gt;obj_field_put(classes_offset, val);
3223 }
3224 
3225 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
3226   o-&gt;obj_field_put(classEnabled_offset, val);
3227 }
3228 
3229 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
3230   o-&gt;obj_field_put(packages_offset, val);
3231 }
3232 
3233 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
3234   o-&gt;obj_field_put(packageEnabled_offset, val);
3235 }
3236 
3237 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
3238   o-&gt;bool_field_put(deflt_offset, val);
3239 }
3240 
3241 
3242 // Support for intrinsification of java.nio.Buffer.checkIndex
3243 int java_nio_Buffer::limit_offset() {
3244   return _limit_offset;
3245 }
3246 
3247 
3248 void java_nio_Buffer::compute_offsets() {
3249   Klass* k = SystemDictionary::nio_Buffer_klass();
3250   assert(k != NULL, "must be loaded in 1.4+");
3251   compute_offset(_limit_offset, k, vmSymbols::limit_name(), vmSymbols::int_signature());
3252 }
3253 
3254 void java_util_concurrent_locks_AbstractOwnableSynchronizer::initialize(TRAPS) {
3255   if (_owner_offset != 0) return;
3256 
3257   assert(JDK_Version::is_gte_jdk16x_version(), "Must be JDK 1.6 or later");
3258   SystemDictionary::load_abstract_ownable_synchronizer_klass(CHECK);
3259   Klass* k = SystemDictionary::abstract_ownable_synchronizer_klass();
3260   compute_offset(_owner_offset, k,
3261                  vmSymbols::exclusive_owner_thread_name(), vmSymbols::thread_signature());
3262 }
3263 
3264 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
3265   assert(_owner_offset != 0, "Must be initialized");
3266   return obj-&gt;obj_field(_owner_offset);
3267 }
3268 
3269 // Compute hard-coded offsets
3270 // Invoked before SystemDictionary::initialize, so pre-loaded classes
3271 // are not available to determine the offset_of_static_fields.
3272 void JavaClasses::compute_hard_coded_offsets() {
3273   const int x = heapOopSize;
3274   const int header = instanceOopDesc::base_offset_in_bytes();
3275 
3276   // Throwable Class
3277   java_lang_Throwable::backtrace_offset  = java_lang_Throwable::hc_backtrace_offset  * x + header;
3278   java_lang_Throwable::detailMessage_offset = java_lang_Throwable::hc_detailMessage_offset * x + header;
3279   java_lang_Throwable::cause_offset      = java_lang_Throwable::hc_cause_offset      * x + header;
3280   java_lang_Throwable::stackTrace_offset = java_lang_Throwable::hc_stackTrace_offset * x + header;
3281   java_lang_Throwable::static_unassigned_stacktrace_offset = java_lang_Throwable::hc_static_unassigned_stacktrace_offset *  x;
3282 
3283   // java_lang_boxing_object
3284   java_lang_boxing_object::value_offset = java_lang_boxing_object::hc_value_offset + header;
3285   java_lang_boxing_object::long_value_offset = align_size_up((java_lang_boxing_object::hc_value_offset + header), BytesPerLong);
3286 
3287   // java_lang_ref_Reference:
3288   java_lang_ref_Reference::referent_offset = java_lang_ref_Reference::hc_referent_offset * x + header;
3289   java_lang_ref_Reference::queue_offset = java_lang_ref_Reference::hc_queue_offset * x + header;
3290   java_lang_ref_Reference::next_offset  = java_lang_ref_Reference::hc_next_offset * x + header;
3291   java_lang_ref_Reference::discovered_offset  = java_lang_ref_Reference::hc_discovered_offset * x + header;
3292   java_lang_ref_Reference::static_lock_offset = java_lang_ref_Reference::hc_static_lock_offset *  x;
3293   java_lang_ref_Reference::static_pending_offset = java_lang_ref_Reference::hc_static_pending_offset * x;
3294   // Artificial fields for java_lang_ref_Reference
3295   // The first field is for the discovered field added in 1.4
3296   java_lang_ref_Reference::number_of_fake_oop_fields = 1;
3297 
3298   // java_lang_ref_SoftReference Class
3299   java_lang_ref_SoftReference::timestamp_offset = align_size_up((java_lang_ref_SoftReference::hc_timestamp_offset * x + header), BytesPerLong);
3300   // Don't multiply static fields because they are always in wordSize units
3301   java_lang_ref_SoftReference::static_clock_offset = java_lang_ref_SoftReference::hc_static_clock_offset * x;
3302 
3303   // java_lang_ClassLoader
3304   java_lang_ClassLoader::parent_offset = java_lang_ClassLoader::hc_parent_offset * x + header;
3305 
3306   // java_lang_System
3307   java_lang_System::static_in_offset  = java_lang_System::hc_static_in_offset  * x;
3308   java_lang_System::static_out_offset = java_lang_System::hc_static_out_offset * x;
3309   java_lang_System::static_err_offset = java_lang_System::hc_static_err_offset * x;
3310   java_lang_System::static_security_offset = java_lang_System::hc_static_security_offset * x;
3311 
3312   // java_lang_StackTraceElement
3313   java_lang_StackTraceElement::declaringClass_offset = java_lang_StackTraceElement::hc_declaringClass_offset  * x + header;
3314   java_lang_StackTraceElement::methodName_offset = java_lang_StackTraceElement::hc_methodName_offset * x + header;
3315   java_lang_StackTraceElement::fileName_offset   = java_lang_StackTraceElement::hc_fileName_offset   * x + header;
3316   java_lang_StackTraceElement::lineNumber_offset = java_lang_StackTraceElement::hc_lineNumber_offset * x + header;
3317   java_lang_AssertionStatusDirectives::classes_offset = java_lang_AssertionStatusDirectives::hc_classes_offset * x + header;
3318   java_lang_AssertionStatusDirectives::classEnabled_offset = java_lang_AssertionStatusDirectives::hc_classEnabled_offset * x + header;
3319   java_lang_AssertionStatusDirectives::packages_offset = java_lang_AssertionStatusDirectives::hc_packages_offset * x + header;
3320   java_lang_AssertionStatusDirectives::packageEnabled_offset = java_lang_AssertionStatusDirectives::hc_packageEnabled_offset * x + header;
3321   java_lang_AssertionStatusDirectives::deflt_offset = java_lang_AssertionStatusDirectives::hc_deflt_offset * x + header;
3322 
3323 }
3324 
3325 
3326 // Compute non-hard-coded field offsets of all the classes in this file
3327 void JavaClasses::compute_offsets() {
3328   // java_lang_Class::compute_offsets was called earlier in bootstrap
3329   java_lang_ClassLoader::compute_offsets();
3330   java_lang_Thread::compute_offsets();
3331   java_lang_ThreadGroup::compute_offsets();
3332   if (EnableInvokeDynamic) {
3333     java_lang_invoke_MethodHandle::compute_offsets();
3334     java_lang_invoke_DirectMethodHandle::compute_offsets();
3335     java_lang_invoke_MemberName::compute_offsets();
3336     java_lang_invoke_LambdaForm::compute_offsets();
3337     java_lang_invoke_MethodType::compute_offsets();
3338     java_lang_invoke_CallSite::compute_offsets();
3339   }
3340   java_security_AccessControlContext::compute_offsets();
3341   // Initialize reflection classes. The layouts of these classes
3342   // changed with the new reflection implementation in JDK 1.4, and
3343   // since the Universe doesn't know what JDK version it is until this
3344   // point we defer computation of these offsets until now.
3345   java_lang_reflect_AccessibleObject::compute_offsets();
3346   java_lang_reflect_Method::compute_offsets();
3347   java_lang_reflect_Constructor::compute_offsets();
3348   java_lang_reflect_Field::compute_offsets();
3349   if (JDK_Version::is_gte_jdk14x_version()) {
3350     java_nio_Buffer::compute_offsets();
3351   }
3352   if (JDK_Version::is_gte_jdk15x_version()) {
3353     sun_reflect_ConstantPool::compute_offsets();
3354     sun_reflect_UnsafeStaticFieldAccessorImpl::compute_offsets();
3355   }
3356   if (JDK_Version::is_jdk18x_version())
3357     java_lang_reflect_Parameter::compute_offsets();
3358 
3359   // generated interpreter code wants to know about the offsets we just computed:
3360   AbstractAssembler::update_delayed_values();
3361 }
3362 
3363 #ifndef PRODUCT
3364 
3365 // These functions exist to assert the validity of hard-coded field offsets to guard
3366 // against changes in the class files
3367 
3368 bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {
3369   EXCEPTION_MARK;
3370   fieldDescriptor fd;
3371   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name, CATCH);
3372   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
3373   instanceKlassHandle h_klass (THREAD, k);
3374   TempNewSymbol f_name = SymbolTable::new_symbol(field_name, CATCH);
3375   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig, CATCH);
3376   if (!h_klass-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
3377     tty-&gt;print_cr("Nonstatic field %s.%s not found", klass_name, field_name);
3378     return false;
3379   }
3380   if (fd.is_static()) {
3381     tty-&gt;print_cr("Nonstatic field %s.%s appears to be static", klass_name, field_name);
3382     return false;
3383   }
3384   if (fd.offset() == hardcoded_offset ) {
3385     return true;
3386   } else {
3387     tty-&gt;print_cr("Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.",
3388                   klass_name, field_name, hardcoded_offset, fd.offset());
3389     return false;
3390   }
3391 }
3392 
3393 
3394 bool JavaClasses::check_static_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {
3395   EXCEPTION_MARK;
3396   fieldDescriptor fd;
3397   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name, CATCH);
3398   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
3399   instanceKlassHandle h_klass (THREAD, k);
3400   TempNewSymbol f_name = SymbolTable::new_symbol(field_name, CATCH);
3401   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig, CATCH);
3402   if (!h_klass-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
3403     tty-&gt;print_cr("Static field %s.%s not found", klass_name, field_name);
3404     return false;
3405   }
3406   if (!fd.is_static()) {
3407     tty-&gt;print_cr("Static field %s.%s appears to be nonstatic", klass_name, field_name);
3408     return false;
3409   }
3410   if (fd.offset() == hardcoded_offset + InstanceMirrorKlass::offset_of_static_fields()) {
3411     return true;
3412   } else {
3413     tty-&gt;print_cr("Offset of static field %s.%s is hardcoded as %d but should really be %d.", klass_name, field_name, hardcoded_offset, fd.offset() - InstanceMirrorKlass::offset_of_static_fields());
3414     return false;
3415   }
3416 }
3417 
3418 
3419 bool JavaClasses::check_constant(const char *klass_name, int hardcoded_constant, const char *field_name, const char* field_sig) {
3420   EXCEPTION_MARK;
3421   fieldDescriptor fd;
3422   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name, CATCH);
3423   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
3424   instanceKlassHandle h_klass (THREAD, k);
3425   TempNewSymbol f_name = SymbolTable::new_symbol(field_name, CATCH);
3426   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig, CATCH);
3427   if (!h_klass-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
3428     tty-&gt;print_cr("Static field %s.%s not found", klass_name, field_name);
3429     return false;
3430   }
3431   if (!fd.is_static() || !fd.has_initial_value()) {
3432     tty-&gt;print_cr("Static field %s.%s appears to be non-constant", klass_name, field_name);
3433     return false;
3434   }
3435   if (!fd.initial_value_tag().is_int()) {
3436     tty-&gt;print_cr("Static field %s.%s is not an int", klass_name, field_name);
3437     return false;
3438   }
3439   jint field_value = fd.int_initial_value();
3440   if (field_value == hardcoded_constant) {
3441     return true;
3442   } else {
3443     tty-&gt;print_cr("Constant value of static field %s.%s is hardcoded as %d but should really be %d.", klass_name, field_name, hardcoded_constant, field_value);
3444     return false;
3445   }
3446 }
3447 
3448 
3449 // Check the hard-coded field offsets of all the classes in this file
3450 
3451 void JavaClasses::check_offsets() {
3452   bool valid = true;
3453   HandleMark hm;
3454 
3455 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
3456   valid &amp;= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)
3457 
3458 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
3459   valid &amp;= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)
3460 
3461 #define CHECK_STATIC_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
3462   valid &amp;= check_static_offset(klass_name, cpp_klass_name :: static_ ## field_name ## _offset, #field_name, field_sig)
3463 
3464 #define CHECK_CONSTANT(klass_name, cpp_klass_name, field_name, field_sig) \
3465   valid &amp;= check_constant(klass_name, cpp_klass_name :: field_name, #field_name, field_sig)
3466 
3467   // java.lang.String
3468 
3469   CHECK_OFFSET("java/lang/String", java_lang_String, value, "[C");
3470   if (java_lang_String::has_offset_field()) {
3471     CHECK_OFFSET("java/lang/String", java_lang_String, offset, "I");
3472     CHECK_OFFSET("java/lang/String", java_lang_String, count, "I");
3473   }
3474   if (java_lang_String::has_hash_field()) {
3475     CHECK_OFFSET("java/lang/String", java_lang_String, hash, "I");
3476   }
3477 
3478   // java.lang.Class
3479 
3480   // Fake fields
3481   // CHECK_OFFSET("java/lang/Class", java_lang_Class, klass); // %%% this needs to be checked
3482   // CHECK_OFFSET("java/lang/Class", java_lang_Class, array_klass); // %%% this needs to be checked
3483 
3484   // java.lang.Throwable
3485 
3486   CHECK_OFFSET("java/lang/Throwable", java_lang_Throwable, backtrace, "Ljava/lang/Object;");
3487   CHECK_OFFSET("java/lang/Throwable", java_lang_Throwable, detailMessage, "Ljava/lang/String;");
3488   CHECK_OFFSET("java/lang/Throwable", java_lang_Throwable, cause, "Ljava/lang/Throwable;");
3489   CHECK_OFFSET("java/lang/Throwable", java_lang_Throwable, stackTrace, "[Ljava/lang/StackTraceElement;");
3490 
3491   // Boxed primitive objects (java_lang_boxing_object)
3492 
3493   CHECK_OFFSET("java/lang/Boolean",   java_lang_boxing_object, value, "Z");
3494   CHECK_OFFSET("java/lang/Character", java_lang_boxing_object, value, "C");
3495   CHECK_OFFSET("java/lang/Float",     java_lang_boxing_object, value, "F");
3496   CHECK_LONG_OFFSET("java/lang/Double", java_lang_boxing_object, value, "D");
3497   CHECK_OFFSET("java/lang/Byte",      java_lang_boxing_object, value, "B");
3498   CHECK_OFFSET("java/lang/Short",     java_lang_boxing_object, value, "S");
3499   CHECK_OFFSET("java/lang/Integer",   java_lang_boxing_object, value, "I");
3500   CHECK_LONG_OFFSET("java/lang/Long", java_lang_boxing_object, value, "J");
3501 
3502   // java.lang.ClassLoader
3503 
3504   CHECK_OFFSET("java/lang/ClassLoader", java_lang_ClassLoader, parent,      "Ljava/lang/ClassLoader;");
3505 
3506   // java.lang.System
3507 
3508   CHECK_STATIC_OFFSET("java/lang/System", java_lang_System,  in, "Ljava/io/InputStream;");
3509   CHECK_STATIC_OFFSET("java/lang/System", java_lang_System, out, "Ljava/io/PrintStream;");
3510   CHECK_STATIC_OFFSET("java/lang/System", java_lang_System, err, "Ljava/io/PrintStream;");
3511   CHECK_STATIC_OFFSET("java/lang/System", java_lang_System, security, "Ljava/lang/SecurityManager;");
3512 
3513   // java.lang.StackTraceElement
3514 
3515   CHECK_OFFSET("java/lang/StackTraceElement", java_lang_StackTraceElement, declaringClass, "Ljava/lang/String;");
3516   CHECK_OFFSET("java/lang/StackTraceElement", java_lang_StackTraceElement, methodName, "Ljava/lang/String;");
3517   CHECK_OFFSET("java/lang/StackTraceElement", java_lang_StackTraceElement,   fileName, "Ljava/lang/String;");
3518   CHECK_OFFSET("java/lang/StackTraceElement", java_lang_StackTraceElement, lineNumber, "I");
3519 
3520   // java.lang.ref.Reference
3521 
3522   CHECK_OFFSET("java/lang/ref/Reference", java_lang_ref_Reference, referent, "Ljava/lang/Object;");
3523   CHECK_OFFSET("java/lang/ref/Reference", java_lang_ref_Reference, queue, "Ljava/lang/ref/ReferenceQueue;");
3524   CHECK_OFFSET("java/lang/ref/Reference", java_lang_ref_Reference, next, "Ljava/lang/ref/Reference;");
3525   // Fake field
3526   //CHECK_OFFSET("java/lang/ref/Reference", java_lang_ref_Reference, discovered, "Ljava/lang/ref/Reference;");
3527   CHECK_STATIC_OFFSET("java/lang/ref/Reference", java_lang_ref_Reference, lock, "Ljava/lang/ref/Reference$Lock;");
3528   CHECK_STATIC_OFFSET("java/lang/ref/Reference", java_lang_ref_Reference, pending, "Ljava/lang/ref/Reference;");
3529 
3530   // java.lang.ref.SoftReference
3531 
3532   CHECK_OFFSET("java/lang/ref/SoftReference", java_lang_ref_SoftReference, timestamp, "J");
3533   CHECK_STATIC_OFFSET("java/lang/ref/SoftReference", java_lang_ref_SoftReference, clock, "J");
3534 
3535   // java.lang.AssertionStatusDirectives
3536   //
3537   // The CheckAssertionStatusDirectives boolean can be removed from here and
3538   // globals.hpp after the AssertionStatusDirectives class has been integrated
3539   // into merlin "for some time."  Without it, the vm will fail with early
3540   // merlin builds.
3541 
3542   if (CheckAssertionStatusDirectives &amp;&amp; JDK_Version::is_gte_jdk14x_version()) {
3543     const char* nm = "java/lang/AssertionStatusDirectives";
3544     const char* sig = "[Ljava/lang/String;";
3545     CHECK_OFFSET(nm, java_lang_AssertionStatusDirectives, classes, sig);
3546     CHECK_OFFSET(nm, java_lang_AssertionStatusDirectives, classEnabled, "[Z");
3547     CHECK_OFFSET(nm, java_lang_AssertionStatusDirectives, packages, sig);
3548     CHECK_OFFSET(nm, java_lang_AssertionStatusDirectives, packageEnabled, "[Z");
3549     CHECK_OFFSET(nm, java_lang_AssertionStatusDirectives, deflt, "Z");
3550   }
3551 
3552   if (!valid) vm_exit_during_initialization("Hard-coded field offset verification failed");
3553 }
3554 
3555 #endif // PRODUCT
3556 
3557 int InjectedField::compute_offset() {
3558   Klass* klass_oop = klass();
3559   for (AllFieldStream fs(InstanceKlass::cast(klass_oop)); !fs.done(); fs.next()) {
3560     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
3561       // Only look at injected fields
3562       continue;
3563     }
3564     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
3565       return fs.offset();
3566     }
3567   }
3568   ResourceMark rm;
3569   tty-&gt;print_cr("Invalid layout of %s at %s/%s%s", InstanceKlass::cast(klass_oop)-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? " (may_be_java)" : "");
3570 #ifndef PRODUCT
3571   klass_oop-&gt;print();
3572   tty-&gt;print_cr("all fields:");
3573   for (AllFieldStream fs(InstanceKlass::cast(klass_oop)); !fs.done(); fs.next()) {
3574     tty-&gt;print_cr("  name: %s, sig: %s, flags: %08x", fs.name()-&gt;as_C_string(), fs.signature()-&gt;as_C_string(), fs.access_flags().as_int());
3575   }
3576 #endif //PRODUCT
3577   vm_exit_during_initialization("Invalid layout of preloaded class: use -XX:+TraceClassLoading to see the origin of the problem class");
3578   return -1;
3579 }
3580 
3581 void javaClasses_init() {
3582   JavaClasses::compute_offsets();
3583   JavaClasses::check_offsets();
3584   FilteredFieldsMap::initialize();  // must be done after computing offsets.
3585 }
</pre></body></html>
