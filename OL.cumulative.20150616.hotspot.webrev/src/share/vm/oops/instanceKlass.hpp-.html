<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/share/vm/oops/instanceKlass.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_VM_OOPS_INSTANCEKLASS_HPP
  26 #define SHARE_VM_OOPS_INSTANCEKLASS_HPP
  27 
  28 #include "classfile/classLoaderData.hpp"
  29 #include "memory/referenceType.hpp"
  30 #include "oops/annotations.hpp"
  31 #include "oops/constMethod.hpp"
  32 #include "oops/fieldInfo.hpp"
  33 #include "oops/instanceOop.hpp"
  34 #include "oops/klassVtable.hpp"
  35 #include "runtime/atomic.hpp"
  36 #include "runtime/handles.hpp"
  37 #include "runtime/os.hpp"
  38 #include "utilities/accessFlags.hpp"
  39 #include "utilities/bitMap.inline.hpp"
  40 #include "utilities/macros.hpp"
  41 #include "trace/traceMacros.hpp"
  42 
  43 // An InstanceKlass is the VM level representation of a Java class.
  44 // It contains all information needed for at class at execution runtime.
  45 
  46 //  InstanceKlass layout:
  47 //    [C++ vtbl pointer           ] Klass
  48 //    [subtype cache              ] Klass
  49 //    [instance size              ] Klass
  50 //    [java mirror                ] Klass
  51 //    [super                      ] Klass
  52 //    [access_flags               ] Klass
  53 //    [name                       ] Klass
  54 //    [first subklass             ] Klass
  55 //    [next sibling               ] Klass
  56 //    [array klasses              ]
  57 //    [methods                    ]
  58 //    [local interfaces           ]
  59 //    [transitive interfaces      ]
  60 //    [fields                     ]
  61 //    [constants                  ]
  62 //    [class loader               ]
  63 //    [source file name           ]
  64 //    [inner classes              ]
  65 //    [static field size          ]
  66 //    [nonstatic field size       ]
  67 //    [static oop fields size     ]
  68 //    [nonstatic oop maps size    ]
  69 //    [has finalize method        ]
  70 //    [deoptimization mark bit    ]
  71 //    [initialization state       ]
  72 //    [initializing thread        ]
  73 //    [Java vtable length         ]
  74 //    [oop map cache (stack maps) ]
  75 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  76 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  77 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  78 //      indicating where oops are located in instances of this klass.
  79 //    [EMBEDDED implementor of the interface] only exist for interface
  80 //    [EMBEDDED host klass        ] only exist for an anonymous class (JSR 292 enabled)
  81 
  82 
  83 // forward declaration for class -- see below for definition
  84 class SuperTypeClosure;
  85 class JNIid;
  86 class jniIdMapBase;
  87 class BreakpointInfo;
  88 class fieldDescriptor;
  89 class DepChange;
  90 class nmethodBucket;
  91 class PreviousVersionNode;
  92 class JvmtiCachedClassFieldMap;
  93 class MemberNameTable;
  94 
  95 // This is used in iterators below.
  96 class FieldClosure: public StackObj {
  97 public:
  98   virtual void do_field(fieldDescriptor* fd) = 0;
  99 };
 100 
 101 #ifndef PRODUCT
 102 // Print fields.
 103 // If "obj" argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
 104 class FieldPrinter: public FieldClosure {
 105    oop _obj;
 106    outputStream* _st;
 107  public:
 108    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
 109    void do_field(fieldDescriptor* fd);
 110 };
 111 #endif  // !PRODUCT
 112 
 113 // ValueObjs embedded in klass. Describes where oops are located in instances of
 114 // this klass.
 115 class OopMapBlock VALUE_OBJ_CLASS_SPEC {
 116  public:
 117   // Byte offset of the first oop mapped by this block.
 118   int offset() const          { return _offset; }
 119   void set_offset(int offset) { _offset = offset; }
 120 
 121   // Number of oops in this block.
 122   uint count() const         { return _count; }
 123   void set_count(uint count) { _count = count; }
 124 
 125   // sizeof(OopMapBlock) in HeapWords.
 126   static const int size_in_words() {
 127     return align_size_up(int(sizeof(OopMapBlock)), HeapWordSize) &gt;&gt;
 128       LogHeapWordSize;
 129   }
 130 
 131  private:
 132   int  _offset;
 133   uint _count;
 134 };
 135 
 136 struct JvmtiCachedClassFileData;
 137 
 138 class InstanceKlass: public Klass {
 139   friend class VMStructs;
 140   friend class ClassFileParser;
 141   friend class CompileReplay;
 142 
 143  protected:
 144   // Constructor
 145   InstanceKlass(int vtable_len,
 146                 int itable_len,
 147                 int static_field_size,
 148                 int nonstatic_oop_map_size,
 149                 ReferenceType rt,
 150                 AccessFlags access_flags,
 151                 bool is_anonymous);
 152  public:
 153   static InstanceKlass* allocate_instance_klass(
 154                                           ClassLoaderData* loader_data,
 155                                           int vtable_len,
 156                                           int itable_len,
 157                                           int static_field_size,
 158                                           int nonstatic_oop_map_size,
 159                                           ReferenceType rt,
 160                                           AccessFlags access_flags,
 161                                           Symbol* name,
 162                                           Klass* super_klass,
 163                                           bool is_anonymous,
 164                                           TRAPS);
 165 
 166   InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, "only for CDS"); }
 167 
 168   // See "The Java Virtual Machine Specification" section 2.16.2-5 for a detailed description
 169   // of the class loading &amp; initialization procedure, and the use of the states.
 170   enum ClassState {
 171     allocated,                          // allocated (but not yet linked)
 172     loaded,                             // loaded and inserted in class hierarchy (but not linked yet)
 173     linked,                             // successfully linked/verified (but not initialized yet)
 174     being_initialized,                  // currently running class initializer
 175     fully_initialized,                  // initialized (successfull final state)
 176     initialization_error                // error happened during initialization
 177   };
 178 
 179   static int number_of_instance_classes() { return _total_instanceKlass_count; }
 180 
 181  private:
 182   static volatile int _total_instanceKlass_count;
 183 
 184  protected:
 185   // Annotations for this class
 186   Annotations*    _annotations;
 187   // Array classes holding elements of this class.
 188   Klass*          _array_klasses;
 189   // Constant pool for this class.
 190   ConstantPool* _constants;
 191   // The InnerClasses attribute and EnclosingMethod attribute. The
 192   // _inner_classes is an array of shorts. If the class has InnerClasses
 193   // attribute, then the _inner_classes array begins with 4-tuples of shorts
 194   // [inner_class_info_index, outer_class_info_index,
 195   // inner_name_index, inner_class_access_flags] for the InnerClasses
 196   // attribute. If the EnclosingMethod attribute exists, it occupies the
 197   // last two shorts [class_index, method_index] of the array. If only
 198   // the InnerClasses attribute exists, the _inner_classes array length is
 199   // number_of_inner_classes * 4. If the class has both InnerClasses
 200   // and EnclosingMethod attributes the _inner_classes array length is
 201   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 202   Array&lt;jushort&gt;* _inner_classes;
 203 
 204   // the source debug extension for this klass, NULL if not specified.
 205   // Specified as UTF-8 string without terminating zero byte in the classfile,
 206   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 207   char*           _source_debug_extension;
 208   // Array name derived from this class which needs unreferencing
 209   // if this class is unloaded.
 210   Symbol*         _array_name;
 211 
 212   // Number of heapOopSize words used by non-static fields in this klass
 213   // (including inherited fields but after header_size()).
 214   int             _nonstatic_field_size;
 215   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 216   // Constant pool index to the utf8 entry of the Generic signature,
 217   // or 0 if none.
 218   u2              _generic_signature_index;
 219   // Constant pool index to the utf8 entry for the name of source file
 220   // containing this klass, 0 if not specified.
 221   u2              _source_file_name_index;
 222   u2              _static_oop_field_count;// number of static oop fields in this klass
 223   u2              _java_fields_count;    // The number of declared Java fields
 224   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 225 
 226   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 227   // _misc_flags.
 228   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 229   bool            _has_unloaded_dependent;
 230 
 231   enum {
 232     _misc_rewritten                = 1 &lt;&lt; 0, // methods rewritten.
 233     _misc_has_nonstatic_fields     = 1 &lt;&lt; 1, // for sizing with UseCompressedOops
 234     _misc_should_verify_class      = 1 &lt;&lt; 2, // allow caching of preverification
 235     _misc_is_anonymous             = 1 &lt;&lt; 3, // has embedded _host_klass field
 236     _misc_is_contended             = 1 &lt;&lt; 4, // marked with contended annotation
 237     _misc_has_default_methods      = 1 &lt;&lt; 5, // class/superclass/implemented interfaces has default methods
 238     _misc_declares_default_methods = 1 &lt;&lt; 6  // directly declares default methods (any access)
 239   };
 240   u2              _misc_flags;
 241   u2              _minor_version;        // minor version number of class file
 242   u2              _major_version;        // major version number of class file
 243   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recusive initialization)
 244   int             _vtable_len;           // length of Java vtable (in words)
 245   int             _itable_len;           // length of Java itable (in words)
 246   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 247   MemberNameTable* _member_names;        // Member names
 248   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 249   jmethodID*      _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 250   nmethodBucket*  _dependencies;         // list of dependent nmethods
 251   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 252   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 253   // Array of interesting part(s) of the previous version(s) of this
 254   // InstanceKlass. See PreviousVersionWalker below.
 255   GrowableArray&lt;PreviousVersionNode *&gt;* _previous_versions;
 256   // JVMTI fields can be moved to their own structure - see 6315920
 257   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 258   JvmtiCachedClassFileData* _cached_class_file;
 259 
 260   volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don't change
 261 
 262   // Class states are defined as ClassState (see above).
 263   // Place the _init_state here to utilize the unused 2-byte after
 264   // _idnum_allocated_count.
 265   u1              _init_state;                    // state of class
 266   u1              _reference_type;                // reference type
 267 
 268   JvmtiCachedClassFieldMap* _jvmti_cached_class_field_map;  // JVMTI: used during heap iteration
 269 
 270   NOT_PRODUCT(int _verify_count;)  // to avoid redundant verifies
 271 
 272   // Method array.
 273   Array&lt;Method*&gt;* _methods;
 274   // Default Method Array, concrete methods inherited from interfaces
 275   Array&lt;Method*&gt;* _default_methods;
 276   // Interface (Klass*s) this class declares locally to implement.
 277   Array&lt;Klass*&gt;* _local_interfaces;
 278   // Interface (Klass*s) this class implements transitively.
 279   Array&lt;Klass*&gt;* _transitive_interfaces;
 280   // Int array containing the original order of method in the class file (for JVMTI).
 281   Array&lt;int&gt;*     _method_ordering;
 282   // Int array containing the vtable_indices for default_methods
 283   // offset matches _default_methods offset
 284   Array&lt;int&gt;*     _default_vtable_indices;
 285 
 286   // Instance and static variable information, starts with 6-tuples of shorts
 287   // [access, name index, sig index, initval index, low_offset, high_offset]
 288   // for all fields, followed by the generic signature data at the end of
 289   // the array. Only fields with generic signature attributes have the generic
 290   // signature data set in the array. The fields array looks like following:
 291   //
 292   // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
 293   // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
 294   //      ...
 295   // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
 296   //     [generic signature index]
 297   //     [generic signature index]
 298   //     ...
 299   Array&lt;u2&gt;*      _fields;
 300 
 301   // embedded Java vtable follows here
 302   // embedded Java itables follows here
 303   // embedded static fields follows here
 304   // embedded nonstatic oop-map blocks follows here
 305   // embedded implementor of this interface follows here
 306   //   The embedded implementor only exists if the current klass is an
 307   //   iterface. The possible values of the implementor fall into following
 308   //   three cases:
 309   //     NULL: no implementor.
 310   //     A Klass* that's not itself: one implementor.
 311   //     Itself: more than one implementors.
 312   // embedded host klass follows here
 313   //   The embedded host klass only exists in an anonymous class for
 314   //   dynamic language support (JSR 292 enabled). The host class grants
 315   //   its access privileges to this class also. The host class is either
 316   //   named, or a previously loaded anonymous class. A non-anonymous class
 317   //   or an anonymous class loaded through normal classloading does not
 318   //   have this embedded field.
 319   //
 320 
 321   friend class SystemDictionary;
 322 
 323  public:
 324   bool has_nonstatic_fields() const        {
 325     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 326   }
 327   void set_has_nonstatic_fields(bool b)    {
 328     if (b) {
 329       _misc_flags |= _misc_has_nonstatic_fields;
 330     } else {
 331       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 332     }
 333   }
 334 
 335   // field sizes
 336   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 337   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 338 
 339   int static_field_size() const            { return _static_field_size; }
 340   void set_static_field_size(int size)     { _static_field_size = size; }
 341 
 342   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
 343   void set_static_oop_field_count(u2 size) { _static_oop_field_count = size; }
 344 
 345   // Java vtable
 346   int  vtable_length() const               { return _vtable_len; }
 347   void set_vtable_length(int len)          { _vtable_len = len; }
 348 
 349   // Java itable
 350   int  itable_length() const               { return _itable_len; }
 351   void set_itable_length(int len)          { _itable_len = len; }
 352 
 353   // array klasses
 354   Klass* array_klasses() const             { return _array_klasses; }
 355   void set_array_klasses(Klass* k)         { _array_klasses = k; }
 356 
 357   // methods
 358   Array&lt;Method*&gt;* methods() const          { return _methods; }
 359   void set_methods(Array&lt;Method*&gt;* a)      { _methods = a; }
 360   Method* method_with_idnum(int idnum);
 361   Method* method_with_orig_idnum(int idnum);
 362   Method* method_with_orig_idnum(int idnum, int version);
 363 
 364   // method ordering
 365   Array&lt;int&gt;* method_ordering() const     { return _method_ordering; }
 366   void set_method_ordering(Array&lt;int&gt;* m) { _method_ordering = m; }
 367   void copy_method_ordering(intArray* m, TRAPS);
 368 
 369   // default_methods
 370   Array&lt;Method*&gt;* default_methods() const  { return _default_methods; }
 371   void set_default_methods(Array&lt;Method*&gt;* a) { _default_methods = a; }
 372 
 373   // default method vtable_indices
 374   Array&lt;int&gt;* default_vtable_indices() const { return _default_vtable_indices; }
 375   void set_default_vtable_indices(Array&lt;int&gt;* v) { _default_vtable_indices = v; }
 376   Array&lt;int&gt;* create_new_default_vtable_indices(int len, TRAPS);
 377 
 378   // interfaces
 379   Array&lt;Klass*&gt;* local_interfaces() const          { return _local_interfaces; }
 380   void set_local_interfaces(Array&lt;Klass*&gt;* a)      {
 381     guarantee(_local_interfaces == NULL || a == NULL, "Just checking");
 382     _local_interfaces = a; }
 383 
 384   Array&lt;Klass*&gt;* transitive_interfaces() const     { return _transitive_interfaces; }
 385   void set_transitive_interfaces(Array&lt;Klass*&gt;* a) {
 386     guarantee(_transitive_interfaces == NULL || a == NULL, "Just checking");
 387     _transitive_interfaces = a;
 388   }
 389 
 390  private:
 391   friend class fieldDescriptor;
 392   FieldInfo* field(int index) const { return FieldInfo::from_field_array(_fields, index); }
 393 
 394  public:
 395   int     field_offset      (int index) const { return field(index)-&gt;offset(); }
 396   int     field_access_flags(int index) const { return field(index)-&gt;access_flags(); }
 397   Symbol* field_name        (int index) const { return field(index)-&gt;name(constants()); }
 398   Symbol* field_signature   (int index) const { return field(index)-&gt;signature(constants()); }
 399 
 400   // Number of Java declared fields
 401   int java_fields_count() const           { return (int)_java_fields_count; }
 402 
 403   Array&lt;u2&gt;* fields() const            { return _fields; }
 404   void set_fields(Array&lt;u2&gt;* f, u2 java_fields_count) {
 405     guarantee(_fields == NULL || f == NULL, "Just checking");
 406     _fields = f;
 407     _java_fields_count = java_fields_count;
 408   }
 409 
 410   // inner classes
 411   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 412   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 413 
 414   enum InnerClassAttributeOffset {
 415     // From http://mirror.eng/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc10.html#18814
 416     inner_class_inner_class_info_offset = 0,
 417     inner_class_outer_class_info_offset = 1,
 418     inner_class_inner_name_offset = 2,
 419     inner_class_access_flags_offset = 3,
 420     inner_class_next_offset = 4
 421   };
 422 
 423   enum EnclosingMethodAttributeOffset {
 424     enclosing_method_class_index_offset = 0,
 425     enclosing_method_method_index_offset = 1,
 426     enclosing_method_attribute_size = 2
 427   };
 428 
 429   // method override check
 430   bool is_override(methodHandle super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS);
 431 
 432   // package
 433   bool is_same_class_package(Klass* class2);
 434   bool is_same_class_package(oop classloader2, Symbol* classname2);
 435   static bool is_same_class_package(oop class_loader1, Symbol* class_name1, oop class_loader2, Symbol* class_name2);
 436 
 437   // find an enclosing class (defined where original code was, in jvm.cpp!)
 438   Klass* compute_enclosing_class(bool* inner_is_member, TRAPS) {
 439     instanceKlassHandle self(THREAD, this);
 440     return compute_enclosing_class_impl(self, inner_is_member, THREAD);
 441   }
 442   static Klass* compute_enclosing_class_impl(instanceKlassHandle self,
 443                                                bool* inner_is_member, TRAPS);
 444 
 445   // tell if two classes have the same enclosing class (at package level)
 446   bool is_same_package_member(Klass* class2, TRAPS) {
 447     instanceKlassHandle self(THREAD, this);
 448     return is_same_package_member_impl(self, class2, THREAD);
 449   }
 450   static bool is_same_package_member_impl(instanceKlassHandle self,
 451                                           Klass* class2, TRAPS);
 452 
 453   // initialization state
 454   bool is_loaded() const                   { return _init_state &gt;= loaded; }
 455   bool is_linked() const                   { return _init_state &gt;= linked; }
 456   bool is_initialized() const              { return _init_state == fully_initialized; }
 457   bool is_not_initialized() const          { return _init_state &lt;  being_initialized; }
 458   bool is_being_initialized() const        { return _init_state == being_initialized; }
 459   bool is_in_error_state() const           { return _init_state == initialization_error; }
 460   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 461   ClassState  init_state()                 { return (ClassState)_init_state; }
 462   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 463 
 464   // defineClass specified verification
 465   bool should_verify_class() const         {
 466     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 467   }
 468   void set_should_verify_class(bool value) {
 469     if (value) {
 470       _misc_flags |= _misc_should_verify_class;
 471     } else {
 472       _misc_flags &amp;= ~_misc_should_verify_class;
 473     }
 474   }
 475 
 476   // marking
 477   bool is_marked_dependent() const         { return _is_marked_dependent; }
 478   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 479 
 480   bool has_unloaded_dependent() const         { return _has_unloaded_dependent; }
 481   void set_has_unloaded_dependent(bool value) { _has_unloaded_dependent = value; }
 482 
 483   // initialization (virtuals from Klass)
 484   bool should_be_initialized() const;  // means that initialize should be called
 485   void initialize(TRAPS);
 486   void link_class(TRAPS);
 487   bool link_class_or_fail(TRAPS); // returns false on failure
 488   void unlink_class();
 489   void rewrite_class(TRAPS);
 490   void link_methods(TRAPS);
 491   Method* class_initializer();
 492 
 493   // set the class to initialized if no static initializer is present
 494   void eager_initialize(Thread *thread);
 495 
 496   // reference type
 497   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 498   void set_reference_type(ReferenceType t) {
 499     assert(t == (u1)t, "overflow");
 500     _reference_type = (u1)t;
 501   }
 502 
 503   static ByteSize reference_type_offset() { return in_ByteSize(offset_of(InstanceKlass, _reference_type)); }
 504 
 505   // find local field, returns true if found
 506   bool find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 507   // find field in direct superinterfaces, returns the interface in which the field is defined
 508   Klass* find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 509   // find field according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 510   Klass* find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 511   // find instance or static fields according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 512   Klass* find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const;
 513 
 514   // find a non-static or static field given its offset within the class.
 515   bool contains_field_offset(int offset) {
 516     return instanceOopDesc::contains_field_offset(offset, nonstatic_field_size());
 517   }
 518 
 519   bool find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 520   bool find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 521 
 522   // find a local method (returns NULL if not found)
 523   Method* find_method(Symbol* name, Symbol* signature) const;
 524   static Method* find_method(Array&lt;Method*&gt;* methods, Symbol* name, Symbol* signature);
 525 
 526   // find a local method, but skip static methods
 527   Method* find_instance_method(Symbol* name, Symbol* signature);
 528   static Method* find_instance_method(Array&lt;Method*&gt;* methods, Symbol* name, Symbol* signature);
 529 
 530   // true if method matches signature and conforms to skipping_X conditions.
 531   static bool method_matches(Method* m, Symbol* signature, bool skipping_overpass, bool skipping_static);
 532 
 533   // find a local method index in default_methods (returns -1 if not found)
 534   static int find_method_index(Array&lt;Method*&gt;* methods, Symbol* name, Symbol* signature, bool skipping_overpass, bool skipping_static);
 535 
 536   // lookup operation (returns NULL if not found)
 537   Method* uncached_lookup_method(Symbol* name, Symbol* signature, MethodLookupMode mode) const;
 538 
 539   // lookup a method in all the interfaces that this class implements
 540   // (returns NULL if not found)
 541   Method* lookup_method_in_all_interfaces(Symbol* name, Symbol* signature, MethodLookupMode mode) const;
 542 
 543   // lookup a method in local defaults then in all interfaces
 544   // (returns NULL if not found)
 545   Method* lookup_method_in_ordered_interfaces(Symbol* name, Symbol* signature) const;
 546 
 547   // Find method indices by name.  If a method with the specified name is
 548   // found the index to the first method is returned, and 'end' is filled in
 549   // with the index of first non-name-matching method.  If no method is found
 550   // -1 is returned.
 551   int find_method_by_name(Symbol* name, int* end);
 552   static int find_method_by_name(Array&lt;Method*&gt;* methods, Symbol* name, int* end);
 553 
 554   // constant pool
 555   ConstantPool* constants() const        { return _constants; }
 556   void set_constants(ConstantPool* c)    { _constants = c; }
 557 
 558   // protection domain
 559   oop protection_domain() const;
 560 
 561   // signers
 562   objArrayOop signers() const;
 563 
 564   // host class
 565   Klass* host_klass() const              {
 566     Klass** hk = (Klass**)adr_host_klass();
 567     if (hk == NULL) {
 568       return NULL;
 569     } else {
 570       assert(*hk != NULL, "host klass should always be set if the address is not null");
 571       return *hk;
 572     }
 573   }
 574   void set_host_klass(Klass* host)            {
 575     assert(is_anonymous(), "not anonymous");
 576     Klass** addr = (Klass**)adr_host_klass();
 577     assert(addr != NULL, "no reversed space");
 578     if (addr != NULL) {
 579       *addr = host;
 580     }
 581   }
 582   bool is_anonymous() const                {
 583     return (_misc_flags &amp; _misc_is_anonymous) != 0;
 584   }
 585   void set_is_anonymous(bool value)        {
 586     if (value) {
 587       _misc_flags |= _misc_is_anonymous;
 588     } else {
 589       _misc_flags &amp;= ~_misc_is_anonymous;
 590     }
 591   }
 592 
 593   // Oop that keeps the metadata for this class from being unloaded
 594   // in places where the metadata is stored in other places, like nmethods
 595   oop klass_holder() const {
 596     return is_anonymous() ? java_mirror() : class_loader();
 597   }
 598 
 599   bool is_contended() const                {
 600     return (_misc_flags &amp; _misc_is_contended) != 0;
 601   }
 602   void set_is_contended(bool value)        {
 603     if (value) {
 604       _misc_flags |= _misc_is_contended;
 605     } else {
 606       _misc_flags &amp;= ~_misc_is_contended;
 607     }
 608   }
 609 
 610   // source file name
 611   Symbol* source_file_name() const               {
 612     return (_source_file_name_index == 0) ?
 613       (Symbol*)NULL : _constants-&gt;symbol_at(_source_file_name_index);
 614   }
 615   u2 source_file_name_index() const              {
 616     return _source_file_name_index;
 617   }
 618   void set_source_file_name_index(u2 sourcefile_index) {
 619     _source_file_name_index = sourcefile_index;
 620   }
 621 
 622   // minor and major version numbers of class file
 623   u2 minor_version() const                 { return _minor_version; }
 624   void set_minor_version(u2 minor_version) { _minor_version = minor_version; }
 625   u2 major_version() const                 { return _major_version; }
 626   void set_major_version(u2 major_version) { _major_version = major_version; }
 627 
 628   // source debug extension
 629   char* source_debug_extension() const     { return _source_debug_extension; }
 630   void set_source_debug_extension(char* array, int length);
 631 
 632   // symbol unloading support (refcount already added)
 633   Symbol* array_name()                     { return _array_name; }
 634   void set_array_name(Symbol* name)        { assert(_array_name == NULL  || name == NULL, "name already created"); _array_name = name; }
 635 
 636   // nonstatic oop-map blocks
 637   static int nonstatic_oop_map_size(unsigned int oop_map_count) {
 638     return oop_map_count * OopMapBlock::size_in_words();
 639   }
 640   unsigned int nonstatic_oop_map_count() const {
 641     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 642   }
 643   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 644   void set_nonstatic_oop_map_size(int words) {
 645     _nonstatic_oop_map_size = words;
 646   }
 647 
 648   // RedefineClasses() support for previous versions:
 649   void add_previous_version(instanceKlassHandle ikh, BitMap *emcp_methods,
 650          int emcp_method_count);
 651   // If the _previous_versions array is non-NULL, then this klass
 652   // has been redefined at least once even if we aren't currently
 653   // tracking a previous version.
 654   bool has_been_redefined() const { return _previous_versions != NULL; }
 655   bool has_previous_version() const;
 656   void init_previous_versions() {
 657     _previous_versions = NULL;
 658   }
 659   GrowableArray&lt;PreviousVersionNode *&gt;* previous_versions() const {
 660     return _previous_versions;
 661   }
 662 
 663   InstanceKlass* get_klass_version(int version);
 664   static void purge_previous_versions(InstanceKlass* ik);
 665 
 666   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
 667   void set_cached_class_file(JvmtiCachedClassFileData *data) {
 668     _cached_class_file = data;
 669   }
 670   JvmtiCachedClassFileData * get_cached_class_file() { return _cached_class_file; }
 671   jint get_cached_class_file_len();
 672   unsigned char * get_cached_class_file_bytes();
 673 
 674   // JVMTI: Support for caching of field indices, types, and offsets
 675   void set_jvmti_cached_class_field_map(JvmtiCachedClassFieldMap* descriptor) {
 676     _jvmti_cached_class_field_map = descriptor;
 677   }
 678   JvmtiCachedClassFieldMap* jvmti_cached_class_field_map() const {
 679     return _jvmti_cached_class_field_map;
 680   }
 681 
 682   bool has_default_methods() const {
 683     return (_misc_flags &amp; _misc_has_default_methods) != 0;
 684   }
 685   void set_has_default_methods(bool b) {
 686     if (b) {
 687       _misc_flags |= _misc_has_default_methods;
 688     } else {
 689       _misc_flags &amp;= ~_misc_has_default_methods;
 690     }
 691   }
 692 
 693   bool declares_default_methods() const {
 694     return (_misc_flags &amp; _misc_declares_default_methods) != 0;
 695   }
 696   void set_declares_default_methods(bool b) {
 697     if (b) {
 698       _misc_flags |= _misc_declares_default_methods;
 699     } else {
 700       _misc_flags &amp;= ~_misc_declares_default_methods;
 701     }
 702   }
 703 
 704   // for adding methods, ConstMethod::UNSET_IDNUM means no more ids available
 705   inline u2 next_method_idnum();
 706   void set_initial_method_idnum(u2 value)             { _idnum_allocated_count = value; }
 707 
 708   // generics support
 709   Symbol* generic_signature() const                   {
 710     return (_generic_signature_index == 0) ?
 711       (Symbol*)NULL : _constants-&gt;symbol_at(_generic_signature_index);
 712   }
 713   u2 generic_signature_index() const                  {
 714     return _generic_signature_index;
 715   }
 716   void set_generic_signature_index(u2 sig_index)      {
 717     _generic_signature_index = sig_index;
 718   }
 719 
 720   u2 enclosing_method_data(int offset);
 721   u2 enclosing_method_class_index() {
 722     return enclosing_method_data(enclosing_method_class_index_offset);
 723   }
 724   u2 enclosing_method_method_index() {
 725     return enclosing_method_data(enclosing_method_method_index_offset);
 726   }
 727   void set_enclosing_method_indices(u2 class_index,
 728                                     u2 method_index);
 729 
 730   // jmethodID support
 731   static jmethodID get_jmethod_id(instanceKlassHandle ik_h,
 732                      methodHandle method_h);
 733   static jmethodID get_jmethod_id_fetch_or_update(instanceKlassHandle ik_h,
 734                      size_t idnum, jmethodID new_id, jmethodID* new_jmeths,
 735                      jmethodID* to_dealloc_id_p,
 736                      jmethodID** to_dealloc_jmeths_p);
 737   static void get_jmethod_id_length_value(jmethodID* cache, size_t idnum,
 738                 size_t *length_p, jmethodID* id_p);
 739   jmethodID jmethod_id_or_null(Method* method);
 740 
 741   // annotations support
 742   Annotations* annotations() const          { return _annotations; }
 743   void set_annotations(Annotations* anno)   { _annotations = anno; }
 744 
 745   AnnotationArray* class_annotations() const {
 746     return (_annotations != NULL) ? _annotations-&gt;class_annotations() : NULL;
 747   }
 748   Array&lt;AnnotationArray*&gt;* fields_annotations() const {
 749     return (_annotations != NULL) ? _annotations-&gt;fields_annotations() : NULL;
 750   }
 751   AnnotationArray* class_type_annotations() const {
 752     return (_annotations != NULL) ? _annotations-&gt;class_type_annotations() : NULL;
 753   }
 754   Array&lt;AnnotationArray*&gt;* fields_type_annotations() const {
 755     return (_annotations != NULL) ? _annotations-&gt;fields_type_annotations() : NULL;
 756   }
 757   // allocation
 758   instanceOop allocate_instance(TRAPS);
 759 
 760   // additional member function to return a handle
 761   instanceHandle allocate_instance_handle(TRAPS)      { return instanceHandle(THREAD, allocate_instance(THREAD)); }
 762 
 763   objArrayOop allocate_objArray(int n, int length, TRAPS);
 764   // Helper function
 765   static instanceOop register_finalizer(instanceOop i, TRAPS);
 766 
 767   // Check whether reflection/jni/jvm code is allowed to instantiate this class;
 768   // if not, throw either an Error or an Exception.
 769   virtual void check_valid_for_instantiation(bool throwError, TRAPS);
 770 
 771   // initialization
 772   void call_class_initializer(TRAPS);
 773   void set_initialization_state_and_notify(ClassState state, TRAPS);
 774 
 775   // OopMapCache support
 776   OopMapCache* oop_map_cache()               { return _oop_map_cache; }
 777   void set_oop_map_cache(OopMapCache *cache) { _oop_map_cache = cache; }
 778   void mask_for(methodHandle method, int bci, InterpreterOopMap* entry);
 779 
 780   // JNI identifier support (for static fields - for jni performance)
 781   JNIid* jni_ids()                               { return _jni_ids; }
 782   void set_jni_ids(JNIid* ids)                   { _jni_ids = ids; }
 783   JNIid* jni_id_for(int offset);
 784 
 785   // maintenance of deoptimization dependencies
 786   int mark_dependent_nmethods(DepChange&amp; changes);
 787   void add_dependent_nmethod(nmethod* nm);
 788   void remove_dependent_nmethod(nmethod* nm);
 789 
 790   // On-stack replacement support
 791   nmethod* osr_nmethods_head() const         { return _osr_nmethods_head; };
 792   void set_osr_nmethods_head(nmethod* h)     { _osr_nmethods_head = h; };
 793   void add_osr_nmethod(nmethod* n);
 794   void remove_osr_nmethod(nmethod* n);
 795   int mark_osr_nmethods(const Method* m);
 796   nmethod* lookup_osr_nmethod(const Method* m, int bci, int level, bool match_level) const;
 797 
 798   // Breakpoint support (see methods on Method* for details)
 799   BreakpointInfo* breakpoints() const       { return _breakpoints; };
 800   void set_breakpoints(BreakpointInfo* bps) { _breakpoints = bps; };
 801 
 802   // support for stub routines
 803   static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }
 804   TRACE_DEFINE_OFFSET;
 805   static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }
 806 
 807   // subclass/subinterface checks
 808   bool implements_interface(Klass* k) const;
 809   bool is_same_or_direct_interface(Klass* k) const;
 810 
 811   // Access to the implementor of an interface.
 812   Klass* implementor() const
 813   {
 814     Klass** k = adr_implementor();
 815     if (k == NULL) {
 816       return NULL;
 817     } else {
 818       return *k;
 819     }
 820   }
 821 
 822   void set_implementor(Klass* k) {
 823     assert(is_interface(), "not interface");
 824     Klass** addr = adr_implementor();
 825     assert(addr != NULL, "null addr");
 826     if (addr != NULL) {
 827       *addr = k;
 828     }
 829   }
 830 
 831   int  nof_implementors() const       {
 832     Klass* k = implementor();
 833     if (k == NULL) {
 834       return 0;
 835     } else if (k != this) {
 836       return 1;
 837     } else {
 838       return 2;
 839     }
 840   }
 841 
 842   void add_implementor(Klass* k);  // k is a new class that implements this interface
 843   void init_implementor();           // initialize
 844 
 845   // link this class into the implementors list of every interface it implements
 846   void process_interfaces(Thread *thread);
 847 
 848   // virtual operations from Klass
 849   bool is_leaf_class() const               { return _subklass == NULL; }
 850   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots);
 851   bool compute_is_subtype_of(Klass* k);
 852   bool can_be_primary_super_slow() const;
 853   int oop_size(oop obj)  const             { return size_helper(); }
 854   bool oop_is_instance_slow() const        { return true; }
 855 
 856   // Iterators
 857   void do_local_static_fields(FieldClosure* cl);
 858   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
 859   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
 860 
 861   void methods_do(void f(Method* method));
 862   void array_klasses_do(void f(Klass* k));
 863   void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);
 864   bool super_types_do(SuperTypeClosure* blk);
 865 
 866   // Casting from Klass*
 867   static InstanceKlass* cast(Klass* k) {
 868     assert(k-&gt;is_klass(), "must be");
 869     assert(k-&gt;oop_is_instance(), "cast to InstanceKlass");
 870     return (InstanceKlass*) k;
 871   }
 872 
 873   InstanceKlass* java_super() const {
 874     return (super() == NULL) ? NULL : cast(super());
 875   }
 876 
 877   // Sizing (in words)
 878   static int header_size()            { return align_object_offset(sizeof(InstanceKlass)/HeapWordSize); }
 879 
 880   static int size(int vtable_length, int itable_length,
 881                   int nonstatic_oop_map_size,
 882                   bool is_interface, bool is_anonymous) {
 883     return align_object_size(header_size() +
 884            align_object_offset(vtable_length) +
 885            align_object_offset(itable_length) +
 886            ((is_interface || is_anonymous) ?
 887              align_object_offset(nonstatic_oop_map_size) :
 888              nonstatic_oop_map_size) +
 889            (is_interface ? (int)sizeof(Klass*)/HeapWordSize : 0) +
 890            (is_anonymous ? (int)sizeof(Klass*)/HeapWordSize : 0));
 891   }
 892   int size() const                    { return size(vtable_length(),
 893                                                itable_length(),
 894                                                nonstatic_oop_map_size(),
 895                                                is_interface(),
 896                                                is_anonymous());
 897   }
 898 #if INCLUDE_SERVICES
 899   virtual void collect_statistics(KlassSizeStats *sz) const;
 900 #endif
 901 
 902   static int vtable_start_offset()    { return header_size(); }
 903   static int vtable_length_offset()   { return offset_of(InstanceKlass, _vtable_len) / HeapWordSize; }
 904 
 905   intptr_t* start_of_vtable() const        { return ((intptr_t*)this) + vtable_start_offset(); }
 906   intptr_t* start_of_itable() const        { return start_of_vtable() + align_object_offset(vtable_length()); }
 907   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
 908 
 909   intptr_t* end_of_itable() const          { return start_of_itable() + itable_length(); }
 910 
 911   address static_field_addr(int offset);
 912 
 913   OopMapBlock* start_of_nonstatic_oop_maps() const {
 914     return (OopMapBlock*)(start_of_itable() + align_object_offset(itable_length()));
 915   }
 916 
 917   Klass** end_of_nonstatic_oop_maps() const {
 918     return (Klass**)(start_of_nonstatic_oop_maps() +
 919                      nonstatic_oop_map_count());
 920   }
 921 
 922   Klass** adr_implementor() const {
 923     if (is_interface()) {
 924       return (Klass**)end_of_nonstatic_oop_maps();
 925     } else {
 926       return NULL;
 927     }
 928   };
 929 
 930   Klass** adr_host_klass() const {
 931     if (is_anonymous()) {
 932       Klass** adr_impl = adr_implementor();
 933       if (adr_impl != NULL) {
 934         return adr_impl + 1;
 935       } else {
 936         return end_of_nonstatic_oop_maps();
 937       }
 938     } else {
 939       return NULL;
 940     }
 941   }
 942 
 943   // Use this to return the size of an instance in heap words:
 944   int size_helper() const {
 945     return layout_helper_to_size_helper(layout_helper());
 946   }
 947 
 948   // This bit is initialized in classFileParser.cpp.
 949   // It is false under any of the following conditions:
 950   //  - the class is abstract (including any interface)
 951   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
 952   //  - the class size is larger than FastAllocateSizeLimit
 953   //  - the class is java/lang/Class, which cannot be allocated directly
 954   bool can_be_fastpath_allocated() const {
 955     return !layout_helper_needs_slow_path(layout_helper());
 956   }
 957 
 958   // Java vtable/itable
 959   klassVtable* vtable() const;        // return new klassVtable wrapper
 960   inline Method* method_at_vtable(int index);
 961   klassItable* itable() const;        // return new klassItable wrapper
 962   Method* method_at_itable(Klass* holder, int index, TRAPS);
 963 
 964 #if INCLUDE_JVMTI
 965   void adjust_default_methods(InstanceKlass* holder, bool* trace_name_printed);
 966 #endif // INCLUDE_JVMTI
 967 
 968   // Garbage collection
 969   void oop_follow_contents(oop obj);
 970   int  oop_adjust_pointers(oop obj);
 971 
 972   void clean_implementors_list(BoolObjectClosure* is_alive);
 973   void clean_method_data(BoolObjectClosure* is_alive);
 974   void clean_dependent_nmethods();
 975 
 976   // Explicit metaspace deallocation of fields
 977   // For RedefineClasses and class file parsing errors, we need to deallocate
 978   // instanceKlasses and the metadata they point to.
 979   void deallocate_contents(ClassLoaderData* loader_data);
 980   static void deallocate_methods(ClassLoaderData* loader_data,
 981                                  Array&lt;Method*&gt;* methods);
 982   void static deallocate_interfaces(ClassLoaderData* loader_data,
 983                                     Klass* super_klass,
 984                                     Array&lt;Klass*&gt;* local_interfaces,
 985                                     Array&lt;Klass*&gt;* transitive_interfaces);
 986 
 987   // The constant pool is on stack if any of the methods are executing or
 988   // referenced by handles.
 989   bool on_stack() const { return _constants-&gt;on_stack(); }
 990 
 991   // callbacks for actions during class unloading
 992   static void notify_unload_class(InstanceKlass* ik);
 993   static void release_C_heap_structures(InstanceKlass* ik);
 994 
 995   // Parallel Scavenge and Parallel Old
 996   PARALLEL_GC_DECLS
 997 
 998   // Naming
 999   const char* signature_name() const;
1000 
1001   // Iterators
1002   int oop_oop_iterate(oop obj, ExtendedOopClosure* blk) {
1003     return oop_oop_iterate_v(obj, blk);
1004   }
1005 
1006   int oop_oop_iterate_m(oop obj, ExtendedOopClosure* blk, MemRegion mr) {
1007     return oop_oop_iterate_v_m(obj, blk, mr);
1008   }
1009 
1010 #define InstanceKlass_OOP_OOP_ITERATE_DECL(OopClosureType, nv_suffix)      \
1011   int  oop_oop_iterate##nv_suffix(oop obj, OopClosureType* blk);           \
1012   int  oop_oop_iterate##nv_suffix##_m(oop obj, OopClosureType* blk,        \
1013                                       MemRegion mr);
1014 
1015   ALL_OOP_OOP_ITERATE_CLOSURES_1(InstanceKlass_OOP_OOP_ITERATE_DECL)
1016   ALL_OOP_OOP_ITERATE_CLOSURES_2(InstanceKlass_OOP_OOP_ITERATE_DECL)
1017 
1018 #if INCLUDE_ALL_GCS
1019 #define InstanceKlass_OOP_OOP_ITERATE_BACKWARDS_DECL(OopClosureType, nv_suffix) \
1020   int  oop_oop_iterate_backwards##nv_suffix(oop obj, OopClosureType* blk);
1021 
1022   ALL_OOP_OOP_ITERATE_CLOSURES_1(InstanceKlass_OOP_OOP_ITERATE_BACKWARDS_DECL)
1023   ALL_OOP_OOP_ITERATE_CLOSURES_2(InstanceKlass_OOP_OOP_ITERATE_BACKWARDS_DECL)
1024 #endif // INCLUDE_ALL_GCS
1025 
1026   u2 idnum_allocated_count() const      { return _idnum_allocated_count; }
1027 
1028 public:
1029   void set_in_error_state() {
1030     assert(DumpSharedSpaces, "only call this when dumping archive");
1031     _init_state = initialization_error;
1032   }
1033   bool check_sharing_error_state();
1034 
1035 private:
1036   // initialization state
1037 #ifdef ASSERT
1038   void set_init_state(ClassState state);
1039 #else
1040   void set_init_state(ClassState state) { _init_state = (u1)state; }
1041 #endif
1042   void set_rewritten()                  { _misc_flags |= _misc_rewritten; }
1043   void set_init_thread(Thread *thread)  { _init_thread = thread; }
1044 
1045   // The RedefineClasses() API can cause new method idnums to be needed
1046   // which will cause the caches to grow. Safety requires different
1047   // cache management logic if the caches can grow instead of just
1048   // going from NULL to non-NULL.
1049   bool idnum_can_increment() const      { return has_been_redefined(); }
1050   jmethodID* methods_jmethod_ids_acquire() const
1051          { return (jmethodID*)OrderAccess::load_ptr_acquire(&amp;_methods_jmethod_ids); }
1052   void release_set_methods_jmethod_ids(jmethodID* jmeths)
1053          { OrderAccess::release_store_ptr(&amp;_methods_jmethod_ids, jmeths); }
1054 
1055   // Lock during initialization
1056 public:
1057   // Lock for (1) initialization; (2) access to the ConstantPool of this class.
1058   // Must be one per class and it has to be a VM internal object so java code
1059   // cannot lock it (like the mirror).
1060   // It has to be an object not a Mutex because it's held through java calls.
1061   oop init_lock() const;
1062 private:
1063   void fence_and_clear_init_lock();
1064 
1065   // Static methods that are used to implement member methods where an exposed this pointer
1066   // is needed due to possible GCs
1067   static bool link_class_impl                           (instanceKlassHandle this_oop, bool throw_verifyerror, TRAPS);
1068   static bool verify_code                               (instanceKlassHandle this_oop, bool throw_verifyerror, TRAPS);
1069   static void initialize_impl                           (instanceKlassHandle this_oop, TRAPS);
1070   static void initialize_super_interfaces               (instanceKlassHandle this_oop, TRAPS);
1071   static void eager_initialize_impl                     (instanceKlassHandle this_oop);
1072   static void set_initialization_state_and_notify_impl  (instanceKlassHandle this_oop, ClassState state, TRAPS);
1073   static void call_class_initializer_impl               (instanceKlassHandle this_oop, TRAPS);
1074   static Klass* array_klass_impl                      (instanceKlassHandle this_oop, bool or_null, int n, TRAPS);
1075   static void do_local_static_fields_impl               (instanceKlassHandle this_oop, void f(fieldDescriptor* fd, Handle, TRAPS), Handle, TRAPS);
1076   /* jni_id_for_impl for jfieldID only */
1077   static JNIid* jni_id_for_impl                         (instanceKlassHandle this_oop, int offset);
1078 
1079   // Returns the array class for the n'th dimension
1080   Klass* array_klass_impl(bool or_null, int n, TRAPS);
1081 
1082   // Returns the array class with this class as element type
1083   Klass* array_klass_impl(bool or_null, TRAPS);
1084 
1085   // find a local method (returns NULL if not found)
1086   Method* find_method_impl(Symbol* name, Symbol* signature, bool skipping_overpass) const;
1087   static Method* find_method_impl(Array&lt;Method*&gt;* methods, Symbol* name, Symbol* signature, bool skipping_overpass, bool skipping_static);
1088 
1089   // Free CHeap allocated fields.
1090   void release_C_heap_structures();
1091 public:
1092   // CDS support - remove and restore oops from metadata. Oops are not shared.
1093   virtual void remove_unshareable_info();
1094   virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS);
1095 
1096   // jvm support
1097   jint compute_modifier_flags(TRAPS) const;
1098 
1099   // JSR-292 support
1100   MemberNameTable* member_names() { return _member_names; }
1101   void set_member_names(MemberNameTable* member_names) { _member_names = member_names; }
1102   bool add_member_name(Handle member_name);
1103 
1104 public:
1105   // JVMTI support
1106   jint jvmti_class_status() const;
1107 
1108  public:
1109   // Printing
1110 #ifndef PRODUCT
1111   void print_on(outputStream* st) const;
1112 #endif
1113   void print_value_on(outputStream* st) const;
1114 
1115   void oop_print_value_on(oop obj, outputStream* st);
1116 
1117 #ifndef PRODUCT
1118   void oop_print_on      (oop obj, outputStream* st);
1119 
1120   void print_dependent_nmethods(bool verbose = false);
1121   bool is_dependent_nmethod(nmethod* nm);
1122 #endif
1123 
1124   const char* internal_name() const;
1125 
1126   // Verification
1127   void verify_on(outputStream* st);
1128 
1129   void oop_verify_on(oop obj, outputStream* st);
1130 };
1131 
1132 inline Method* InstanceKlass::method_at_vtable(int index)  {
1133 #ifndef PRODUCT
1134   assert(index &gt;= 0, "valid vtable index");
1135   if (DebugVtables) {
1136     verify_vtable_index(index);
1137   }
1138 #endif
1139   vtableEntry* ve = (vtableEntry*)start_of_vtable();
1140   return ve[index].method();
1141 }
1142 
1143 // for adding methods
1144 // UNSET_IDNUM return means no more ids available
1145 inline u2 InstanceKlass::next_method_idnum() {
1146   if (_idnum_allocated_count == ConstMethod::MAX_IDNUM) {
1147     return ConstMethod::UNSET_IDNUM; // no more ids available
1148   } else {
1149     return _idnum_allocated_count++;
1150   }
1151 }
1152 
1153 
1154 /* JNIid class for jfieldIDs only */
1155 class JNIid: public CHeapObj&lt;mtClass&gt; {
1156   friend class VMStructs;
1157  private:
1158   Klass*             _holder;
1159   JNIid*             _next;
1160   int                _offset;
1161 #ifdef ASSERT
1162   bool               _is_static_field_id;
1163 #endif
1164 
1165  public:
1166   // Accessors
1167   Klass* holder() const           { return _holder; }
1168   int offset() const              { return _offset; }
1169   JNIid* next()                   { return _next; }
1170   // Constructor
1171   JNIid(Klass* holder, int offset, JNIid* next);
1172   // Identifier lookup
1173   JNIid* find(int offset);
1174 
1175   bool find_local_field(fieldDescriptor* fd) {
1176     return InstanceKlass::cast(holder())-&gt;find_local_field_from_offset(offset(), true, fd);
1177   }
1178 
1179   static void deallocate(JNIid* id);
1180   // Debugging
1181 #ifdef ASSERT
1182   bool is_static_field_id() const { return _is_static_field_id; }
1183   void set_is_static_field_id()   { _is_static_field_id = true; }
1184 #endif
1185   void verify(Klass* holder);
1186 };
1187 
1188 
1189 // If breakpoints are more numerous than just JVMTI breakpoints,
1190 // consider compressing this data structure.
1191 // It is currently a simple linked list defined in method.hpp.
1192 
1193 class BreakpointInfo;
1194 
1195 
1196 // A collection point for interesting information about the previous
1197 // version(s) of an InstanceKlass.  A GrowableArray of PreviousVersionNodes
1198 // is attached to the InstanceKlass as needed. See PreviousVersionWalker below.
1199 class PreviousVersionNode : public CHeapObj&lt;mtClass&gt; {
1200  private:
1201   ConstantPool*    _prev_constant_pool;
1202 
1203   // If the previous version of the InstanceKlass doesn't have any
1204   // EMCP methods, then _prev_EMCP_methods will be NULL. If all the
1205   // EMCP methods have been collected, then _prev_EMCP_methods can
1206   // have a length of zero.
1207   GrowableArray&lt;Method*&gt;* _prev_EMCP_methods;
1208 
1209 public:
1210   PreviousVersionNode(ConstantPool* prev_constant_pool,
1211                       GrowableArray&lt;Method*&gt;* prev_EMCP_methods);
1212   ~PreviousVersionNode();
1213   ConstantPool* prev_constant_pool() const {
1214     return _prev_constant_pool;
1215   }
1216   GrowableArray&lt;Method*&gt;* prev_EMCP_methods() const {
1217     return _prev_EMCP_methods;
1218   }
1219 };
1220 
1221 
1222 // Helper object for walking previous versions.
1223 class PreviousVersionWalker : public StackObj {
1224  private:
1225   Thread*                               _thread;
1226   GrowableArray&lt;PreviousVersionNode *&gt;* _previous_versions;
1227   int                                   _current_index;
1228 
1229   // A pointer to the current node object so we can handle the deletes.
1230   PreviousVersionNode*                  _current_p;
1231 
1232   // The constant pool handle keeps all the methods in this class from being
1233   // deallocated from the metaspace during class unloading.
1234   constantPoolHandle                    _current_constant_pool_handle;
1235 
1236  public:
1237   PreviousVersionWalker(Thread* thread, InstanceKlass *ik);
1238 
1239   // Return the interesting information for the next previous version
1240   // of the klass. Returns NULL if there are no more previous versions.
1241   PreviousVersionNode* next_previous_version();
1242 };
1243 
1244 
1245 //
1246 // nmethodBucket is used to record dependent nmethods for
1247 // deoptimization.  nmethod dependencies are actually &lt;klass, method&gt;
1248 // pairs but we really only care about the klass part for purposes of
1249 // finding nmethods which might need to be deoptimized.  Instead of
1250 // recording the method, a count of how many times a particular nmethod
1251 // was recorded is kept.  This ensures that any recording errors are
1252 // noticed since an nmethod should be removed as many times are it's
1253 // added.
1254 //
1255 class nmethodBucket: public CHeapObj&lt;mtClass&gt; {
1256   friend class VMStructs;
1257  private:
1258   nmethod*       _nmethod;
1259   int            _count;
1260   nmethodBucket* _next;
1261 
1262  public:
1263   nmethodBucket(nmethod* nmethod, nmethodBucket* next) {
1264     _nmethod = nmethod;
1265     _next = next;
1266     _count = 1;
1267   }
1268   int count()                             { return _count; }
1269   int increment()                         { _count += 1; return _count; }
1270   int decrement();
1271   nmethodBucket* next()                   { return _next; }
1272   void set_next(nmethodBucket* b)         { _next = b; }
1273   nmethod* get_nmethod()                  { return _nmethod; }
1274 };
1275 
1276 // An iterator that's used to access the inner classes indices in the
1277 // InstanceKlass::_inner_classes array.
1278 class InnerClassesIterator : public StackObj {
1279  private:
1280   Array&lt;jushort&gt;* _inner_classes;
1281   int _length;
1282   int _idx;
1283  public:
1284 
1285   InnerClassesIterator(instanceKlassHandle k) {
1286     _inner_classes = k-&gt;inner_classes();
1287     if (k-&gt;inner_classes() != NULL) {
1288       _length = _inner_classes-&gt;length();
1289       // The inner class array's length should be the multiple of
1290       // inner_class_next_offset if it only contains the InnerClasses
1291       // attribute data, or it should be
1292       // n*inner_class_next_offset+enclosing_method_attribute_size
1293       // if it also contains the EnclosingMethod data.
1294       assert((_length % InstanceKlass::inner_class_next_offset == 0 ||
1295               _length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size),
1296              "just checking");
1297       // Remove the enclosing_method portion if exists.
1298       if (_length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size) {
1299         _length -= InstanceKlass::enclosing_method_attribute_size;
1300       }
1301     } else {
1302       _length = 0;
1303     }
1304     _idx = 0;
1305   }
1306 
1307   int length() const {
1308     return _length;
1309   }
1310 
1311   void next() {
1312     _idx += InstanceKlass::inner_class_next_offset;
1313   }
1314 
1315   bool done() const {
1316     return (_idx &gt;= _length);
1317   }
1318 
1319   u2 inner_class_info_index() const {
1320     return _inner_classes-&gt;at(
1321                _idx + InstanceKlass::inner_class_inner_class_info_offset);
1322   }
1323 
1324   void set_inner_class_info_index(u2 index) {
1325     _inner_classes-&gt;at_put(
1326                _idx + InstanceKlass::inner_class_inner_class_info_offset, index);
1327   }
1328 
1329   u2 outer_class_info_index() const {
1330     return _inner_classes-&gt;at(
1331                _idx + InstanceKlass::inner_class_outer_class_info_offset);
1332   }
1333 
1334   void set_outer_class_info_index(u2 index) {
1335     _inner_classes-&gt;at_put(
1336                _idx + InstanceKlass::inner_class_outer_class_info_offset, index);
1337   }
1338 
1339   u2 inner_name_index() const {
1340     return _inner_classes-&gt;at(
1341                _idx + InstanceKlass::inner_class_inner_name_offset);
1342   }
1343 
1344   void set_inner_name_index(u2 index) {
1345     _inner_classes-&gt;at_put(
1346                _idx + InstanceKlass::inner_class_inner_name_offset, index);
1347   }
1348 
1349   u2 inner_access_flags() const {
1350     return _inner_classes-&gt;at(
1351                _idx + InstanceKlass::inner_class_access_flags_offset);
1352   }
1353 };
1354 
1355 #endif // SHARE_VM_OOPS_INSTANCEKLASS_HPP
</pre></body></html>
