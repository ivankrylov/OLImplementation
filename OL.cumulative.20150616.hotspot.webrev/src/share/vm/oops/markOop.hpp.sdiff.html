<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/share/vm/oops </title>
</head><body id="SUNWwebrev">
<h2>src/share/vm/oops/markOop.hpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  36 //
  37 //  32 bits:
  38 //  --------
  39 //             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)
  40 //             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
  41 //             size:32 ------------------------------------------&gt;| (CMS free block)
  42 //             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)
  43 //
  44 //  64 bits:
  45 //  --------
  46 //  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)
  47 //  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
  48 //  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)
  49 //  size:64 -----------------------------------------------------&gt;| (CMS free block)
  50 //
  51 //  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)
  52 //  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)
  53 //  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)
  54 //  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)
  55 //



















  56 //  - hash contains the identity hash value: largest value is
  57 //    31 bits, see os::random().  Also, 64-bit vm's require
  58 //    a hash value no bigger than 32 bits because they will not
  59 //    properly generate a mask larger than that: see library_call.cpp
  60 //    and c1_CodePatterns_sparc.cpp.
  61 //
  62 //  - the biased lock pattern is used to bias a lock toward a given
  63 //    thread. When this pattern is set in the low three bits, the lock
  64 //    is either biased toward a given thread or "anonymously" biased,
  65 //    indicating that it is possible for it to be biased. When the
  66 //    lock is biased toward a given thread, locking and unlocking can
  67 //    be performed by that thread without using atomic operations.
  68 //    When a lock's bias is revoked, it reverts back to the normal
  69 //    locking scheme described below.
  70 //
  71 //    Note that we are overloading the meaning of the "unlocked" state
  72 //    of the header. Because we steal a bit from the age we can
  73 //    guarantee that the bias pattern will never be seen for a truly
  74 //    unlocked object.
  75 //

</pre><hr></hr><pre>
  84 //    to make room for the age bits &amp; the epoch bits (used in support of
  85 //    biased locking), and for the CMS "freeness" bit in the 64bVM (+COOPs).
  86 //
  87 //    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread
  88 //    [0           | epoch | age | 1 | 01]       lock is anonymously biased
  89 //
  90 //  - the two lock bits are used to describe three states: locked/unlocked and monitor.
  91 //
  92 //    [ptr             | 00]  locked             ptr points to real header on stack
  93 //    [header      | 0 | 01]  unlocked           regular object header
  94 //    [ptr             | 10]  monitor            inflated lock (header is wapped out)
  95 //    [ptr             | 11]  marked             used by markSweep to mark an object
  96 //                                               not valid at any other time
  97 //
  98 //    We assume that stack/thread pointers have the lowest two bits cleared.
  99 
 100 class BasicLock;
 101 class ObjectMonitor;
 102 class JavaThread;
 103 
<span class="changed"> 104 class markOopDesc: public oopDesc {</span>
<span class="changed"> 105  private:</span>
 106   // Conversion
<span class="changed"> 107   uintptr_t value() const { return (uintptr_t) this; }</span>


 108 
<span class="changed"> 109  public:</span>
 110   // Constants
<span class="changed"> 111   enum { age_bits                 = 4,</span>
<span class="changed"> 112          lock_bits                = 2,</span>
 113          biased_lock_bits         = 1,
<span class="changed"> 114          max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,</span>
<span class="changed"> 115          hash_bits                = max_hash_bits &gt; 31 ? 31 : max_hash_bits,</span>

 116          cms_bits                 = LP64_ONLY(1) NOT_LP64(0),




 117          epoch_bits               = 2
 118   };
 119 
 120   // The biased locking code currently requires that the age bits be
 121   // contiguous to the lock bits.
 122   enum { lock_shift               = 0,
 123          biased_lock_shift        = lock_bits,
<span class="changed"> 124          age_shift                = lock_bits + biased_lock_bits,</span>
<span class="changed"> 125          cms_shift                = age_shift + age_bits,</span>


 126          hash_shift               = cms_shift + cms_bits,
 127          epoch_shift              = hash_shift
 128   };
 129 
 130   enum { lock_mask                = right_n_bits(lock_bits),
 131          lock_mask_in_place       = lock_mask &lt;&lt; lock_shift,
 132          biased_lock_mask         = right_n_bits(lock_bits + biased_lock_bits),
<span class="changed"> 133          biased_lock_mask_in_place= biased_lock_mask &lt;&lt; lock_shift,</span>
<span class="changed"> 134          biased_lock_bit_in_place = 1 &lt;&lt; biased_lock_shift,</span>
 135          age_mask                 = right_n_bits(age_bits),
 136          age_mask_in_place        = age_mask &lt;&lt; age_shift,
<span class="changed"> 137          epoch_mask               = right_n_bits(epoch_bits),</span>
<span class="changed"> 138          epoch_mask_in_place      = epoch_mask &lt;&lt; epoch_shift,</span>


 139          cms_mask                 = right_n_bits(cms_bits),
<span class="changed"> 140          cms_mask_in_place        = cms_mask &lt;&lt; cms_shift</span>
 141 #ifndef _WIN64
<span class="changed"> 142          ,hash_mask               = right_n_bits(hash_bits),</span>
<span class="changed"> 143          hash_mask_in_place       = (address_word)hash_mask &lt;&lt; hash_shift</span>
<span class="changed"> 144 #endif</span>
<span class="changed"> 145   };</span>
<span class="changed"> 146 </span>
<span class="changed"> 147   // Alignment of JavaThread pointers encoded in object header required by biased locking</span>
<span class="changed"> 148   enum { biased_lock_alignment    = 2 &lt;&lt; (epoch_shift + epoch_bits)</span>
 149   };
 150 
 151 #ifdef _WIN64
<span class="changed"> 152     // These values are too big for Win64</span>
 153     const static uintptr_t hash_mask = right_n_bits(hash_bits);
 154     const static uintptr_t hash_mask_in_place  =
<span class="changed"> 155                             (address_word)hash_mask &lt;&lt; hash_shift;</span>
<span class="changed"> 156 #endif</span>






 157 
 158   enum { locked_value             = 0,
 159          unlocked_value           = 1,
 160          monitor_value            = 2,
 161          marked_value             = 3,
 162          biased_lock_pattern      = 5
 163   };
 164 
<span class="changed"> 165   enum { no_hash                  = 0 };  // no hash value assigned</span>
 166 
<span class="changed"> 167   enum { no_hash_in_place         = (address_word)no_hash &lt;&lt; hash_shift,</span>
 168          no_lock_in_place         = unlocked_value
 169   };
 170 
 171   enum { max_age                  = age_mask };
 172 
 173   enum { max_bias_epoch           = epoch_mask };
 174 
<span class="changed"> 175   // Biased Locking accessors.</span>
<span class="changed"> 176   // These must be checked by all code which calls into the</span>
<span class="changed"> 177   // ObjectSynchronizer and other code. The biasing is not understood</span>
<span class="changed"> 178   // by the lower-level CAS-based locking code, although the runtime</span>
<span class="changed"> 179   // fixes up biased locks to be compatible with it when a bias is</span>
<span class="changed"> 180   // revoked.</span>













 181   bool has_bias_pattern() const {
<span class="changed"> 182     return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern);</span>
 183   }
 184   JavaThread* biased_locker() const {
 185     assert(has_bias_pattern(), "should not call this otherwise");
<span class="changed"> 186     return (JavaThread*) ((intptr_t) (mask_bits(value(), ~(biased_lock_mask_in_place | age_mask_in_place | epoch_mask_in_place))));</span>



 187   }
 188   // Indicates that the mark has the bias bit set but that it has not
 189   // yet been biased toward a particular thread
 190   bool is_biased_anonymously() const {
<span class="changed"> 191     return (has_bias_pattern() &amp;&amp; (biased_locker() == NULL));</span>
 192   }
 193   // Indicates epoch in which this bias was acquired. If the epoch
 194   // changes due to too many bias revocations occurring, the biases
 195   // from the previous epochs are all considered invalid.
 196   int bias_epoch() const {
 197     assert(has_bias_pattern(), "should not call this otherwise");
<span class="changed"> 198     return (mask_bits(value(), epoch_mask_in_place) &gt;&gt; epoch_shift);</span>
 199   }
<span class="changed"> 200   markOop set_bias_epoch(int epoch) {</span>
 201     assert(has_bias_pattern(), "should not call this otherwise");
<span class="changed"> 202     assert((epoch &amp; (~epoch_mask)) == 0, "epoch overflow");</span>
<span class="changed"> 203     return markOop(mask_bits(value(), ~epoch_mask_in_place) | (epoch &lt;&lt; epoch_shift));</span>

 204   }
<span class="changed"> 205   markOop incr_bias_epoch() {</span>
<span class="changed"> 206     return set_bias_epoch((1 + bias_epoch()) &amp; epoch_mask);</span>
 207   }
 208   // Prototype mark for initialization
 209   static markOop biased_locking_prototype() {
<span class="changed"> 210     return markOop( biased_lock_pattern );</span>
 211   }
 212 
<span class="removed"> 213   // lock accessors (note that these assume lock_shift == 0)</span>
<span class="removed"> 214   bool is_locked()   const {</span>
<span class="removed"> 215     return (mask_bits(value(), lock_mask_in_place) != unlocked_value);</span>
<span class="removed"> 216   }</span>
<span class="removed"> 217   bool is_unlocked() const {</span>
<span class="removed"> 218     return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value);</span>
<span class="removed"> 219   }</span>
<span class="removed"> 220   bool is_marked()   const {</span>
<span class="removed"> 221     return (mask_bits(value(), lock_mask_in_place) == marked_value);</span>
<span class="removed"> 222   }</span>
<span class="removed"> 223   bool is_neutral()  const { return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value); }</span>
<span class="removed"> 224 </span>
 225   // Special temporary state of the markOop while being inflated.
 226   // Code that looks at mark outside a lock need to take this into account.
 227   bool is_being_inflated() const { return (value() == 0); }
 228 
 229   // Distinguished markword value - used when inflating over
 230   // an existing stacklock.  0 indicates the markword is "BUSY".
 231   // Lockword mutators that use a LD...CAS idiom should always
 232   // check for and avoid overwriting a 0 value installed by some
 233   // other thread.  (They should spin or block instead.  The 0 value
 234   // is transient and *should* be short-lived).
 235   static markOop INFLATING() { return (markOop) 0; }    // inflate-in-progress
 236 
 237   // Should this header be preserved during GC?
 238   inline bool must_be_preserved(oop obj_containing_mark) const;
 239   inline bool must_be_preserved_with_bias(oop obj_containing_mark) const;
 240 
 241   // Should this header (including its age bits) be preserved in the
 242   // case of a promotion failure during scavenge?
 243   // Note that we special case this situation. We want to avoid
 244   // calling BiasedLocking::preserve_marks()/restore_marks() (which

</pre><hr></hr><pre>
 309   static markOop unused_mark() {
 310     return (markOop) marked_value;
 311   }
 312   // the following two functions create the markOop to be
 313   // stored into object header, it encodes monitor info
 314   static markOop encode(BasicLock* lock) {
 315     return (markOop) lock;
 316   }
 317   static markOop encode(ObjectMonitor* monitor) {
 318     intptr_t tmp = (intptr_t) monitor;
 319     return (markOop) (tmp | monitor_value);
 320   }
 321   static markOop encode(JavaThread* thread, uint age, int bias_epoch) {
 322     intptr_t tmp = (intptr_t) thread;
 323     assert(UseBiasedLocking &amp;&amp; ((tmp &amp; (epoch_mask_in_place | age_mask_in_place | biased_lock_mask_in_place)) == 0), "misaligned JavaThread pointer");
 324     assert(age &lt;= max_age, "age too large");
 325     assert(bias_epoch &lt;= max_bias_epoch, "bias epoch too large");
 326     return (markOop) (tmp | (bias_epoch &lt;&lt; epoch_shift) | (age &lt;&lt; age_shift) | biased_lock_pattern);
 327   }
 328 
<span class="changed"> 329   // used to encode pointers during GC</span>
<span class="changed"> 330   markOop clear_lock_bits() { return markOop(value() &amp; ~lock_mask_in_place); }</span>








 331 
<span class="changed"> 332   // age operations</span>
<span class="changed"> 333   markOop set_marked()   { return markOop((value() &amp; ~lock_mask_in_place) | marked_value); }</span>
<span class="changed"> 334   markOop set_unmarked() { return markOop((value() &amp; ~lock_mask_in_place) | unlocked_value); }</span>









 335 
<span class="changed"> 336   uint    age()               const { return mask_bits(value() &gt;&gt; age_shift, age_mask); }</span>
<span class="changed"> 337   markOop set_age(uint v) const {</span>
<span class="changed"> 338     assert((v &amp; ~age_mask) == 0, "shouldn't overflow age field");</span>
<span class="changed"> 339     return markOop((value() &amp; ~age_mask_in_place) | (((uintptr_t)v &amp; age_mask) &lt;&lt; age_shift));</span>























 340   }
<span class="removed"> 341   markOop incr_age()          const { return age() == max_age ? markOop(this) : set_age(age() + 1); }</span>
 342 
<span class="changed"> 343   // hash operations</span>
 344   intptr_t hash() const {
 345     return mask_bits(value() &gt;&gt; hash_shift, hash_mask);
 346   }
<span class="removed"> 347 </span>
 348   bool has_no_hash() const {
 349     return hash() == no_hash;
 350   }
 351 
 352   // Prototype mark for initialization
 353   static markOop prototype() {
<span class="changed"> 354     return markOop( no_hash_in_place | no_lock_in_place );</span>
 355   }
 356 
<span class="changed"> 357   // Helper function for restoration of unmarked mark oops during GC</span>
<span class="changed"> 358   static inline markOop prototype_for_object(oop obj);</span>
 359 
 360   // Debugging
 361   void print_on(outputStream* st) const;
 362 
 363   // Prepare address of oop for placement into mark
<span class="changed"> 364   inline static markOop encode_pointer_as_mark(void* p) { return markOop(p)-&gt;set_marked(); }</span>







 365 
 366   // Recover address of oop from encoded form used in mark
<span class="changed"> 367   inline void* decode_pointer() { if (UseBiasedLocking &amp;&amp; has_bias_pattern()) return NULL; return clear_lock_bits(); }</span>





 368 
 369   // These markOops indicate cms free chunk blocks and not objects.
 370   // In 64 bit, the markOop is set to distinguish them from oops.
 371   // These are defined in 32 bit mode for vmStructs.
 372   const static uintptr_t cms_free_chunk_pattern  = 0x1;
 373 
 374   // Constants for the size field.
 375   enum { size_shift                = cms_shift + cms_bits,
 376          size_bits                 = 35    // need for compressed oops 32G
 377        };
 378   // These values are too big for Win64
 379   const static uintptr_t size_mask = LP64_ONLY(right_n_bits(size_bits))
 380                                      NOT_LP64(0);
 381   const static uintptr_t size_mask_in_place =
 382                                      (address_word)size_mask &lt;&lt; size_shift;
 383 
 384 #ifdef _LP64
 385   static markOop cms_free_prototype() {
 386     return markOop(((intptr_t)prototype() &amp; ~cms_mask_in_place) |
 387                    ((cms_free_chunk_pattern &amp; cms_mask) &lt;&lt; cms_shift));
</pre></td><td><pre>

</pre><hr></hr><pre>
  36 //
  37 //  32 bits:
  38 //  --------
  39 //             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)
  40 //             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
  41 //             size:32 ------------------------------------------&gt;| (CMS free block)
  42 //             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)
  43 //
  44 //  64 bits:
  45 //  --------
  46 //  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)
  47 //  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
  48 //  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)
  49 //  size:64 -----------------------------------------------------&gt;| (CMS free block)
  50 //
  51 //  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)
  52 //  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)
  53 //  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)
  54 //  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)
  55 //
<span class="new">  56 //</span>
<span class="new">  57 //  * SPECIAL NOTE ON THE CURRENT IMPLEMENTATION OF STRUCTURED ARRAYS AND OBJECTLAYOUT *</span>
<span class="new">  58 //</span>
<span class="new">  59 //  Structured arrays ares only implemented for 64-bit VM without Compressed OOPs</span>
<span class="new">  60 //  At this moment biased locking is not supported</span>
<span class="new">  61 //</span>
<span class="new">  62 //  Here is the bit encoding of the mark word</span>
<span class="new">  63 //</span>
<span class="new">  64 //  64 bits:</span>
<span class="new">  65 //  --------</span>
<span class="new">  66 //  unused:25 hash:31 --&gt;| unused:1 | container:1 | contained:1 | age:2 |biased_lock:1 lock:2 (normal object)</span>
<span class="new">  67 //</span>
<span class="new">  68 //  There is a TODO item to investigate and to relocate container and </span>
<span class="new">  69 //  contained bits to bits 62 and 63 and restore 4 bits for age description.</span>
<span class="new">  70 //</span>
<span class="new">  71 //  * END OF SPECIAL NOTE ON THE CURRENT IMPLEMENTATION OF STRUCTURED ARRAYS AND OBJECTLAYOUT *</span>
<span class="new">  72 //</span>
<span class="new">  73 //</span>
<span class="new">  74 //</span>
  75 //  - hash contains the identity hash value: largest value is
  76 //    31 bits, see os::random().  Also, 64-bit vm's require
  77 //    a hash value no bigger than 32 bits because they will not
  78 //    properly generate a mask larger than that: see library_call.cpp
  79 //    and c1_CodePatterns_sparc.cpp.
  80 //
  81 //  - the biased lock pattern is used to bias a lock toward a given
  82 //    thread. When this pattern is set in the low three bits, the lock
  83 //    is either biased toward a given thread or "anonymously" biased,
  84 //    indicating that it is possible for it to be biased. When the
  85 //    lock is biased toward a given thread, locking and unlocking can
  86 //    be performed by that thread without using atomic operations.
  87 //    When a lock's bias is revoked, it reverts back to the normal
  88 //    locking scheme described below.
  89 //
  90 //    Note that we are overloading the meaning of the "unlocked" state
  91 //    of the header. Because we steal a bit from the age we can
  92 //    guarantee that the bias pattern will never be seen for a truly
  93 //    unlocked object.
  94 //

</pre><hr></hr><pre>
 103 //    to make room for the age bits &amp; the epoch bits (used in support of
 104 //    biased locking), and for the CMS "freeness" bit in the 64bVM (+COOPs).
 105 //
 106 //    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread
 107 //    [0           | epoch | age | 1 | 01]       lock is anonymously biased
 108 //
 109 //  - the two lock bits are used to describe three states: locked/unlocked and monitor.
 110 //
 111 //    [ptr             | 00]  locked             ptr points to real header on stack
 112 //    [header      | 0 | 01]  unlocked           regular object header
 113 //    [ptr             | 10]  monitor            inflated lock (header is wapped out)
 114 //    [ptr             | 11]  marked             used by markSweep to mark an object
 115 //                                               not valid at any other time
 116 //
 117 //    We assume that stack/thread pointers have the lowest two bits cleared.
 118 
 119 class BasicLock;
 120 class ObjectMonitor;
 121 class JavaThread;
 122 
<span class="changed"> 123 class markOopDesc : public oopDesc {</span>
<span class="changed"> 124 private:</span>
 125   // Conversion
<span class="changed"> 126   uintptr_t value() const {</span>
<span class="changed"> 127     return (uintptr_t) this;</span>
<span class="changed"> 128   }</span>
 129 
<span class="changed"> 130 public:</span>
 131   // Constants
<span class="changed"> 132   enum { lock_bits                = 2,</span>

 133          biased_lock_bits         = 1,
<span class="changed"> 134          age_bits                 = 2,</span>
<span class="changed"> 135          contained_bits           = 1,</span>
<span class="changed"> 136          container_bits           = 1,</span>
 137          cms_bits                 = LP64_ONLY(1) NOT_LP64(0),
<span class="new"> 138          max_hash_bits            = BitsPerWord - lock_bits - biased_lock_bits -</span>
<span class="new"> 139                                     age_bits - contained_bits - container_bits -</span>
<span class="new"> 140                                     cms_bits,</span>
<span class="new"> 141          hash_bits                = max_hash_bits &gt; 31 ? 31 : max_hash_bits,</span>
 142          epoch_bits               = 2
 143   };
 144 
 145   // The biased locking code currently requires that the age bits be
 146   // contiguous to the lock bits.
 147   enum { lock_shift               = 0,
 148          biased_lock_shift        = lock_bits,
<span class="changed"> 149          age_shift                = biased_lock_shift + biased_lock_bits,</span>
<span class="changed"> 150          contained_shift          = age_shift + age_bits,</span>
<span class="changed"> 151          container_shift          = contained_shift + contained_bits,</span>
<span class="changed"> 152          cms_shift                = container_shift + container_bits,</span>
 153          hash_shift               = cms_shift + cms_bits,
 154          epoch_shift              = hash_shift
 155   };
 156 
 157   enum { lock_mask                = right_n_bits(lock_bits),
 158          lock_mask_in_place       = lock_mask &lt;&lt; lock_shift,
 159          biased_lock_mask         = right_n_bits(lock_bits + biased_lock_bits),
<span class="changed"> 160          biased_lock_mask_in_place = biased_lock_mask &lt;&lt; lock_shift,</span>
<span class="changed"> 161          biased_lock_bit_in_place = nth_bit(biased_lock_shift),</span>
 162          age_mask                 = right_n_bits(age_bits),
 163          age_mask_in_place        = age_mask &lt;&lt; age_shift,
<span class="changed"> 164          contained_mask           = right_n_bits(contained_bits),</span>
<span class="changed"> 165          contained_mask_in_place  = contained_mask &lt;&lt; contained_shift,</span>
<span class="changed"> 166          container_mask           = right_n_bits(container_bits),</span>
<span class="changed"> 167          container_mask_in_place  = container_mask &lt;&lt; container_shift,</span>
 168          cms_mask                 = right_n_bits(cms_bits),
<span class="changed"> 169          cms_mask_in_place        = cms_mask &lt;&lt; cms_shift,</span>
 170 #ifndef _WIN64
<span class="changed"> 171          hash_mask                = right_n_bits(hash_bits),</span>
<span class="changed"> 172          hash_mask_in_place       = (address_word) hash_mask &lt;&lt; hash_shift,</span>
<span class="changed"> 173 #endif // _WIN64</span>
<span class="changed"> 174          epoch_mask               = right_n_bits(epoch_bits),</span>
<span class="changed"> 175          epoch_mask_in_place      = epoch_mask &lt;&lt; epoch_shift</span>


 176   };
 177 
 178 #ifdef _WIN64
<span class="changed"> 179   // These values are too big for Win64.</span>
 180   const static uintptr_t hash_mask = right_n_bits(hash_bits);
 181   const static uintptr_t hash_mask_in_place =
<span class="changed"> 182       (address_word) hash_mask &lt;&lt; hash_shift;</span>
<span class="changed"> 183 #endif // _WIN64</span>
<span class="changed"> 184 </span>
<span class="changed"> 185   enum { contained_mask_in_place_when_forwarded = nth_bit(2) };</span>
<span class="changed"> 186 </span>
<span class="changed"> 187   // Alignment of JavaThread pointers encoded in object header required by</span>
<span class="changed"> 188   // biased locking</span>
<span class="changed"> 189   enum { biased_lock_alignment    = 2 &lt;&lt; (epoch_shift + epoch_bits) };</span>
 190 
 191   enum { locked_value             = 0,
 192          unlocked_value           = 1,
 193          monitor_value            = 2,
 194          marked_value             = 3,
 195          biased_lock_pattern      = 5
 196   };
 197 
<span class="changed"> 198   enum { no_hash                  = 0 }; // No hash value assigned</span>
 199 
<span class="changed"> 200   enum { no_hash_in_place         = (address_word) no_hash &lt;&lt; hash_shift,</span>
 201          no_lock_in_place         = unlocked_value
 202   };
 203 
 204   enum { max_age                  = age_mask };
 205 
 206   enum { max_bias_epoch           = epoch_mask };
 207 
<span class="changed"> 208   // Lock accessors (note that these assume lock_shift == 0)</span>
<span class="changed"> 209   bool is_locked() const {</span>
<span class="changed"> 210     return mask_bits(value(), lock_mask_in_place) != unlocked_value;</span>
<span class="changed"> 211   }</span>
<span class="changed"> 212   bool is_unlocked() const {</span>
<span class="changed"> 213     return mask_bits(value(), biased_lock_mask_in_place) == unlocked_value;</span>
<span class="changed"> 214   }</span>
<span class="changed"> 215   bool is_marked() const {</span>
<span class="changed"> 216     return mask_bits(value(), lock_mask_in_place) == marked_value;</span>
<span class="changed"> 217   }</span>
<span class="changed"> 218   bool is_neutral() const {</span>
<span class="changed"> 219     return mask_bits(value(), biased_lock_mask_in_place) == unlocked_value;</span>
<span class="changed"> 220   }</span>
<span class="changed"> 221 </span>
<span class="changed"> 222   // Biased locking accessors</span>
<span class="changed"> 223   // These must be checked by all code which calls into the ObjectSynchronizer</span>
<span class="changed"> 224   // and other code. The biasing is not understood by the lower-level CAS-based</span>
<span class="changed"> 225   // locking code, although the runtime fixes up biased locks to be compatible</span>
<span class="changed"> 226   // with it when a bias is revoked.</span>
 227   bool has_bias_pattern() const {
<span class="changed"> 228     return mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern;</span>
 229   }
 230   JavaThread* biased_locker() const {
 231     assert(has_bias_pattern(), "should not call this otherwise");
<span class="changed"> 232     return (JavaThread*) ((intptr_t) mask_bits(value(),</span>
<span class="changed"> 233         ~(biased_lock_mask_in_place | age_mask_in_place |</span>
<span class="changed"> 234         contained_mask_in_place | container_mask_in_place |</span>
<span class="changed"> 235         epoch_mask_in_place)));</span>
 236   }
 237   // Indicates that the mark has the bias bit set but that it has not
 238   // yet been biased toward a particular thread
 239   bool is_biased_anonymously() const {
<span class="changed"> 240     return has_bias_pattern() &amp;&amp; (biased_locker() == NULL);</span>
 241   }
 242   // Indicates epoch in which this bias was acquired. If the epoch
 243   // changes due to too many bias revocations occurring, the biases
 244   // from the previous epochs are all considered invalid.
 245   int bias_epoch() const {
 246     assert(has_bias_pattern(), "should not call this otherwise");
<span class="changed"> 247     return mask_bits(value(), epoch_mask_in_place) &gt;&gt; epoch_shift;</span>
 248   }
<span class="changed"> 249   markOop set_bias_epoch(int epoch) const {</span>
 250     assert(has_bias_pattern(), "should not call this otherwise");
<span class="changed"> 251     assert((epoch &amp; ~epoch_mask) == 0, "epoch overflow");</span>
<span class="changed"> 252     return markOop(mask_bits(value(), ~epoch_mask_in_place) |</span>
<span class="changed"> 253         (epoch &lt;&lt; epoch_shift));</span>
 254   }
<span class="changed"> 255   markOop incr_bias_epoch() const {</span>
<span class="changed"> 256     return set_bias_epoch((bias_epoch() + 1) &amp; epoch_mask);</span>
 257   }
 258   // Prototype mark for initialization
 259   static markOop biased_locking_prototype() {
<span class="changed"> 260     return markOop(biased_lock_pattern);</span>
 261   }
 262 












 263   // Special temporary state of the markOop while being inflated.
 264   // Code that looks at mark outside a lock need to take this into account.
 265   bool is_being_inflated() const { return (value() == 0); }
 266 
 267   // Distinguished markword value - used when inflating over
 268   // an existing stacklock.  0 indicates the markword is "BUSY".
 269   // Lockword mutators that use a LD...CAS idiom should always
 270   // check for and avoid overwriting a 0 value installed by some
 271   // other thread.  (They should spin or block instead.  The 0 value
 272   // is transient and *should* be short-lived).
 273   static markOop INFLATING() { return (markOop) 0; }    // inflate-in-progress
 274 
 275   // Should this header be preserved during GC?
 276   inline bool must_be_preserved(oop obj_containing_mark) const;
 277   inline bool must_be_preserved_with_bias(oop obj_containing_mark) const;
 278 
 279   // Should this header (including its age bits) be preserved in the
 280   // case of a promotion failure during scavenge?
 281   // Note that we special case this situation. We want to avoid
 282   // calling BiasedLocking::preserve_marks()/restore_marks() (which

</pre><hr></hr><pre>
 347   static markOop unused_mark() {
 348     return (markOop) marked_value;
 349   }
 350   // the following two functions create the markOop to be
 351   // stored into object header, it encodes monitor info
 352   static markOop encode(BasicLock* lock) {
 353     return (markOop) lock;
 354   }
 355   static markOop encode(ObjectMonitor* monitor) {
 356     intptr_t tmp = (intptr_t) monitor;
 357     return (markOop) (tmp | monitor_value);
 358   }
 359   static markOop encode(JavaThread* thread, uint age, int bias_epoch) {
 360     intptr_t tmp = (intptr_t) thread;
 361     assert(UseBiasedLocking &amp;&amp; ((tmp &amp; (epoch_mask_in_place | age_mask_in_place | biased_lock_mask_in_place)) == 0), "misaligned JavaThread pointer");
 362     assert(age &lt;= max_age, "age too large");
 363     assert(bias_epoch &lt;= max_bias_epoch, "bias epoch too large");
 364     return (markOop) (tmp | (bias_epoch &lt;&lt; epoch_shift) | (age &lt;&lt; age_shift) | biased_lock_pattern);
 365   }
 366 
<span class="changed"> 367   markOop set_marked() const {</span>
<span class="changed"> 368     return markOop((value() &amp; ~lock_mask_in_place) | marked_value);</span>
<span class="changed"> 369   }</span>
<span class="changed"> 370   markOop set_unmarked() const {</span>
<span class="changed"> 371     return markOop((value() &amp; ~lock_mask_in_place) | unlocked_value);</span>
<span class="changed"> 372   }</span>
<span class="changed"> 373   markOop clear_lock_and_contained_bits() const {</span>
<span class="changed"> 374     return markOop(value() &amp; ~(lock_mask_in_place |</span>
<span class="changed"> 375         contained_mask_in_place_when_forwarded));</span>
<span class="changed"> 376   }</span>
 377 
<span class="changed"> 378   // Age operations</span>
<span class="changed"> 379   uint age() const {</span>
<span class="changed"> 380     return mask_bits(value(), age_mask_in_place) &gt;&gt; age_shift;</span>
<span class="changed"> 381   }</span>
<span class="changed"> 382   markOop set_age(uint age) const {</span>
<span class="changed"> 383     assert((age &amp; ~age_mask) == 0, "age overflow");</span>
<span class="changed"> 384     return markOop(mask_bits(value(), ~age_mask_in_place) |</span>
<span class="changed"> 385         (age &lt;&lt; age_shift));</span>
<span class="changed"> 386   }</span>
<span class="changed"> 387   markOop incr_age() const {</span>
<span class="changed"> 388     return age() == max_age ? markOop(this) : set_age(age() + 1);</span>
<span class="changed"> 389   }</span>
 390 
<span class="changed"> 391   // Containment bits operations</span>
<span class="changed"> 392   bool is_contained() const {</span>
<span class="changed"> 393     return mask_bits(value(), contained_mask_in_place) != 0;</span>
<span class="changed"> 394   }</span>
<span class="changed"> 395   markOop set_contained() const {</span>
<span class="changed"> 396     return markOop(value() | contained_mask_in_place);</span>
<span class="changed"> 397   }</span>
<span class="changed"> 398   markOop clear_contained() const {</span>
<span class="changed"> 399     return markOop(value() &amp; ~contained_mask_in_place);</span>
<span class="changed"> 400   }</span>
<span class="changed"> 401   bool is_container() const {</span>
<span class="changed"> 402     return mask_bits(value(), container_mask_in_place) != 0;</span>
<span class="changed"> 403   }</span>
<span class="changed"> 404   markOop set_container() const {</span>
<span class="changed"> 405     return markOop(value() | container_mask_in_place);</span>
<span class="changed"> 406   }</span>
<span class="changed"> 407   markOop clear_container() const {</span>
<span class="changed"> 408     return markOop(value() &amp; ~container_mask_in_place);</span>
<span class="changed"> 409   }</span>
<span class="changed"> 410   bool is_contained_when_forwarded() const {</span>
<span class="changed"> 411     return mask_bits(value(), contained_mask_in_place_when_forwarded) != 0;</span>
<span class="changed"> 412   }</span>
<span class="changed"> 413   markOop set_contained_when_forwarded() const {</span>
<span class="changed"> 414     return markOop(value() | contained_mask_in_place_when_forwarded);</span>
<span class="changed"> 415   }</span>
<span class="changed"> 416   markOop clear_contained_when_forwarded() const {</span>
<span class="changed"> 417     return markOop(value() &amp; ~contained_mask_in_place_when_forwarded);</span>
 418   }

 419 
<span class="changed"> 420   // Hash operations</span>
 421   intptr_t hash() const {
 422     return mask_bits(value() &gt;&gt; hash_shift, hash_mask);
 423   }

 424   bool has_no_hash() const {
 425     return hash() == no_hash;
 426   }
 427 
 428   // Prototype mark for initialization
 429   static markOop prototype() {
<span class="changed"> 430     return markOop(no_hash_in_place | no_lock_in_place);</span>
 431   }
 432 
<span class="changed"> 433   // Helper function for restoration of unmarked markOop's during GC</span>
<span class="changed"> 434   static markOop prototype_for_object(oop obj);</span>
 435 
 436   // Debugging
 437   void print_on(outputStream* st) const;
 438 
 439   // Prepare address of oop for placement into mark
<span class="changed"> 440   static markOop encode_pointer_as_mark(void* p, bool is_contained) {</span>
<span class="changed"> 441     assert(!markOop(p)-&gt;is_contained_when_forwarded(), "encoding will fail");</span>
<span class="changed"> 442     markOop m = markOop(p)-&gt;set_marked();</span>
<span class="changed"> 443     if (is_contained) {</span>
<span class="changed"> 444       m = m-&gt;set_contained_when_forwarded();</span>
<span class="changed"> 445     }</span>
<span class="changed"> 446     return m;</span>
<span class="changed"> 447   }</span>
 448 
 449   // Recover address of oop from encoded form used in mark
<span class="changed"> 450   void* decode_pointer() {</span>
<span class="changed"> 451     if (UseBiasedLocking &amp;&amp; has_bias_pattern()) {</span>
<span class="changed"> 452       return NULL;</span>
<span class="changed"> 453     }</span>
<span class="changed"> 454     return clear_lock_and_contained_bits();</span>
<span class="changed"> 455   }</span>
 456 
 457   // These markOops indicate cms free chunk blocks and not objects.
 458   // In 64 bit, the markOop is set to distinguish them from oops.
 459   // These are defined in 32 bit mode for vmStructs.
 460   const static uintptr_t cms_free_chunk_pattern  = 0x1;
 461 
 462   // Constants for the size field.
 463   enum { size_shift                = cms_shift + cms_bits,
 464          size_bits                 = 35    // need for compressed oops 32G
 465        };
 466   // These values are too big for Win64
 467   const static uintptr_t size_mask = LP64_ONLY(right_n_bits(size_bits))
 468                                      NOT_LP64(0);
 469   const static uintptr_t size_mask_in_place =
 470                                      (address_word)size_mask &lt;&lt; size_shift;
 471 
 472 #ifdef _LP64
 473   static markOop cms_free_prototype() {
 474     return markOop(((intptr_t)prototype() &amp; ~cms_mask_in_place) |
 475                    ((cms_free_chunk_pattern &amp; cms_mask) &lt;&lt; cms_shift));
</pre></td>
</tr></table>
</body></html>
