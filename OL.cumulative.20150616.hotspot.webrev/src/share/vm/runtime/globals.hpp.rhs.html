<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_VM_RUNTIME_GLOBALS_HPP
  26 #define SHARE_VM_RUNTIME_GLOBALS_HPP
  27 
  28 #include "utilities/debug.hpp"
  29 
  30 // use this for flags that are true per default in the tiered build
  31 // but false in non-tiered builds, and vice versa
  32 #ifdef TIERED
  33 #define  trueInTiered true
  34 #define falseInTiered false
  35 #else
  36 #define  trueInTiered false
  37 #define falseInTiered true
  38 #endif
  39 
  40 #ifdef TARGET_ARCH_x86
  41 # include "globals_x86.hpp"
  42 #endif
  43 #ifdef TARGET_ARCH_sparc
  44 # include "globals_sparc.hpp"
  45 #endif
  46 #ifdef TARGET_ARCH_zero
  47 # include "globals_zero.hpp"
  48 #endif
  49 #ifdef TARGET_ARCH_arm
  50 # include "globals_arm.hpp"
  51 #endif
  52 #ifdef TARGET_ARCH_ppc
  53 # include "globals_ppc.hpp"
  54 #endif
  55 #ifdef TARGET_OS_FAMILY_linux
  56 # include "globals_linux.hpp"
  57 #endif
  58 #ifdef TARGET_OS_FAMILY_solaris
  59 # include "globals_solaris.hpp"
  60 #endif
  61 #ifdef TARGET_OS_FAMILY_windows
  62 # include "globals_windows.hpp"
  63 #endif
  64 #ifdef TARGET_OS_FAMILY_aix
  65 # include "globals_aix.hpp"
  66 #endif
  67 #ifdef TARGET_OS_FAMILY_bsd
  68 # include "globals_bsd.hpp"
  69 #endif
  70 #ifdef TARGET_OS_ARCH_linux_x86
  71 # include "globals_linux_x86.hpp"
  72 #endif
  73 #ifdef TARGET_OS_ARCH_linux_sparc
  74 # include "globals_linux_sparc.hpp"
  75 #endif
  76 #ifdef TARGET_OS_ARCH_linux_zero
  77 # include "globals_linux_zero.hpp"
  78 #endif
  79 #ifdef TARGET_OS_ARCH_solaris_x86
  80 # include "globals_solaris_x86.hpp"
  81 #endif
  82 #ifdef TARGET_OS_ARCH_solaris_sparc
  83 # include "globals_solaris_sparc.hpp"
  84 #endif
  85 #ifdef TARGET_OS_ARCH_windows_x86
  86 # include "globals_windows_x86.hpp"
  87 #endif
  88 #ifdef TARGET_OS_ARCH_linux_arm
  89 # include "globals_linux_arm.hpp"
  90 #endif
  91 #ifdef TARGET_OS_ARCH_linux_ppc
  92 # include "globals_linux_ppc.hpp"
  93 #endif
  94 #ifdef TARGET_OS_ARCH_aix_ppc
  95 # include "globals_aix_ppc.hpp"
  96 #endif
  97 #ifdef TARGET_OS_ARCH_bsd_x86
  98 # include "globals_bsd_x86.hpp"
  99 #endif
 100 #ifdef TARGET_OS_ARCH_bsd_zero
 101 # include "globals_bsd_zero.hpp"
 102 #endif
 103 #ifdef COMPILER1
 104 #ifdef TARGET_ARCH_x86
 105 # include "c1_globals_x86.hpp"
 106 #endif
 107 #ifdef TARGET_ARCH_sparc
 108 # include "c1_globals_sparc.hpp"
 109 #endif
 110 #ifdef TARGET_ARCH_arm
 111 # include "c1_globals_arm.hpp"
 112 #endif
 113 #ifdef TARGET_ARCH_ppc
 114 # include "c1_globals_ppc.hpp"
 115 #endif
 116 #ifdef TARGET_OS_FAMILY_linux
 117 # include "c1_globals_linux.hpp"
 118 #endif
 119 #ifdef TARGET_OS_FAMILY_solaris
 120 # include "c1_globals_solaris.hpp"
 121 #endif
 122 #ifdef TARGET_OS_FAMILY_windows
 123 # include "c1_globals_windows.hpp"
 124 #endif
 125 #ifdef TARGET_OS_FAMILY_aix
 126 # include "c1_globals_aix.hpp"
 127 #endif
 128 #ifdef TARGET_OS_FAMILY_bsd
 129 # include "c1_globals_bsd.hpp"
 130 #endif
 131 #endif
 132 #ifdef COMPILER2
 133 #ifdef TARGET_ARCH_x86
 134 # include "c2_globals_x86.hpp"
 135 #endif
 136 #ifdef TARGET_ARCH_sparc
 137 # include "c2_globals_sparc.hpp"
 138 #endif
 139 #ifdef TARGET_ARCH_arm
 140 # include "c2_globals_arm.hpp"
 141 #endif
 142 #ifdef TARGET_ARCH_ppc
 143 # include "c2_globals_ppc.hpp"
 144 #endif
 145 #ifdef TARGET_OS_FAMILY_linux
 146 # include "c2_globals_linux.hpp"
 147 #endif
 148 #ifdef TARGET_OS_FAMILY_solaris
 149 # include "c2_globals_solaris.hpp"
 150 #endif
 151 #ifdef TARGET_OS_FAMILY_windows
 152 # include "c2_globals_windows.hpp"
 153 #endif
 154 #ifdef TARGET_OS_FAMILY_aix
 155 # include "c2_globals_aix.hpp"
 156 #endif
 157 #ifdef TARGET_OS_FAMILY_bsd
 158 # include "c2_globals_bsd.hpp"
 159 #endif
 160 #endif
 161 #ifdef SHARK
 162 #ifdef TARGET_ARCH_zero
 163 # include "shark_globals_zero.hpp"
 164 #endif
 165 #endif
 166 
 167 #if !defined(COMPILER1) &amp;&amp; !defined(COMPILER2) &amp;&amp; !defined(SHARK)
 168 define_pd_global(bool, BackgroundCompilation,        false);
 169 define_pd_global(bool, UseTLAB,                      false);
 170 define_pd_global(bool, CICompileOSR,                 false);
 171 define_pd_global(bool, UseTypeProfile,               false);
 172 define_pd_global(bool, UseOnStackReplacement,        false);
 173 define_pd_global(bool, InlineIntrinsics,             false);
 174 define_pd_global(bool, PreferInterpreterNativeStubs, true);
 175 define_pd_global(bool, ProfileInterpreter,           false);
 176 define_pd_global(bool, ProfileTraps,                 false);
 177 define_pd_global(bool, TieredCompilation,            false);
 178 
 179 define_pd_global(intx, CompileThreshold,             0);
 180 define_pd_global(intx, BackEdgeThreshold,            0);
 181 
 182 define_pd_global(intx, OnStackReplacePercentage,     0);
 183 define_pd_global(bool, ResizeTLAB,                   false);
 184 define_pd_global(intx, FreqInlineSize,               0);
 185 define_pd_global(intx, NewSizeThreadIncrease,        4*K);
 186 define_pd_global(intx, InlineClassNatives,           true);
 187 define_pd_global(intx, InlineUnsafeOps,              true);
 188 define_pd_global(intx, InitialCodeCacheSize,         160*K);
 189 define_pd_global(intx, ReservedCodeCacheSize,        32*M);
 190 define_pd_global(intx, CodeCacheExpansionSize,       32*K);
 191 define_pd_global(intx, CodeCacheMinBlockLength,      1);
 192 define_pd_global(intx, CodeCacheMinimumUseSpace,     200*K);
 193 define_pd_global(uintx,MetaspaceSize,    ScaleForWordSize(4*M));
 194 define_pd_global(bool, NeverActAsServerClassMachine, true);
 195 define_pd_global(uint64_t,MaxRAM,                    1ULL*G);
 196 #define CI_COMPILER_COUNT 0
 197 #else
 198 
 199 #ifdef COMPILER2
 200 #define CI_COMPILER_COUNT 2
 201 #else
 202 #define CI_COMPILER_COUNT 1
 203 #endif // COMPILER2
 204 
 205 #endif // no compilers
 206 
 207 // string type aliases used only in this file
 208 typedef const char* ccstr;
 209 typedef const char* ccstrlist;   // represents string arguments which accumulate
 210 
 211 struct Flag {
 212   enum Flags {
 213     // value origin
 214     DEFAULT          = 0,
 215     COMMAND_LINE     = 1,
 216     ENVIRON_VAR      = 2,
 217     CONFIG_FILE      = 3,
 218     MANAGEMENT       = 4,
 219     ERGONOMIC        = 5,
 220     ATTACH_ON_DEMAND = 6,
 221     INTERNAL         = 7,
 222 
 223     LAST_VALUE_ORIGIN = INTERNAL,
 224     VALUE_ORIGIN_BITS = 4,
 225     VALUE_ORIGIN_MASK = right_n_bits(VALUE_ORIGIN_BITS),
 226 
 227     // flag kind
 228     KIND_PRODUCT            = 1 &lt;&lt; 4,
 229     KIND_MANAGEABLE         = 1 &lt;&lt; 5,
 230     KIND_DIAGNOSTIC         = 1 &lt;&lt; 6,
 231     KIND_EXPERIMENTAL       = 1 &lt;&lt; 7,
 232     KIND_NOT_PRODUCT        = 1 &lt;&lt; 8,
 233     KIND_DEVELOP            = 1 &lt;&lt; 9,
 234     KIND_PLATFORM_DEPENDENT = 1 &lt;&lt; 10,
 235     KIND_READ_WRITE         = 1 &lt;&lt; 11,
 236     KIND_C1                 = 1 &lt;&lt; 12,
 237     KIND_C2                 = 1 &lt;&lt; 13,
 238     KIND_ARCH               = 1 &lt;&lt; 14,
 239     KIND_SHARK              = 1 &lt;&lt; 15,
 240     KIND_LP64_PRODUCT       = 1 &lt;&lt; 16,
 241     KIND_COMMERCIAL         = 1 &lt;&lt; 17,
 242 
 243     KIND_MASK = ~VALUE_ORIGIN_MASK
 244   };
 245 
 246   const char* _type;
 247   const char* _name;
 248   void* _addr;
 249   NOT_PRODUCT(const char* _doc;)
 250   Flags _flags;
 251 
 252   // points to all Flags static array
 253   static Flag* flags;
 254 
 255   // number of flags
 256   static size_t numFlags;
 257 
 258   static Flag* find_flag(const char* name, size_t length, bool allow_locked = false, bool return_flag = false);
 259   static Flag* fuzzy_match(const char* name, size_t length, bool allow_locked = false);
 260 
 261   void check_writable();
 262 
 263   bool is_bool() const;
 264   bool get_bool() const;
 265   void set_bool(bool value);
 266 
 267   bool is_intx() const;
 268   intx get_intx() const;
 269   void set_intx(intx value);
 270 
 271   bool is_uintx() const;
 272   uintx get_uintx() const;
 273   void set_uintx(uintx value);
 274 
 275   bool is_uint64_t() const;
 276   uint64_t get_uint64_t() const;
 277   void set_uint64_t(uint64_t value);
 278 
 279   bool is_double() const;
 280   double get_double() const;
 281   void set_double(double value);
 282 
 283   bool is_ccstr() const;
 284   bool ccstr_accumulates() const;
 285   ccstr get_ccstr() const;
 286   void set_ccstr(ccstr value);
 287 
 288   Flags get_origin();
 289   void set_origin(Flags origin);
 290 
 291   bool is_default();
 292   bool is_ergonomic();
 293   bool is_command_line();
 294 
 295   bool is_product() const;
 296   bool is_manageable() const;
 297   bool is_diagnostic() const;
 298   bool is_experimental() const;
 299   bool is_notproduct() const;
 300   bool is_develop() const;
 301   bool is_read_write() const;
 302   bool is_commercial() const;
 303 
 304   bool is_constant_in_binary() const;
 305 
 306   bool is_unlocker() const;
 307   bool is_unlocked() const;
 308   bool is_writeable() const;
 309   bool is_external() const;
 310 
 311   bool is_unlocker_ext() const;
 312   bool is_unlocked_ext() const;
 313   bool is_writeable_ext() const;
 314   bool is_external_ext() const;
 315 
 316   void unlock_diagnostic();
 317 
 318   void get_locked_message(char*, int) const;
 319   void get_locked_message_ext(char*, int) const;
 320 
 321   void print_on(outputStream* st, bool withComments = false );
 322   void print_kind(outputStream* st);
 323   void print_as_flag(outputStream* st);
 324 };
 325 
 326 // debug flags control various aspects of the VM and are global accessible
 327 
 328 // use FlagSetting to temporarily change some debug flag
 329 // e.g. FlagSetting fs(DebugThisAndThat, true);
 330 // restored to previous value upon leaving scope
 331 class FlagSetting {
 332   bool val;
 333   bool* flag;
 334  public:
 335   FlagSetting(bool&amp; fl, bool newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 336   ~FlagSetting()                       { *flag = val; }
 337 };
 338 
 339 
 340 class CounterSetting {
 341   intx* counter;
 342  public:
 343   CounterSetting(intx* cnt) { counter = cnt; (*counter)++; }
 344   ~CounterSetting()         { (*counter)--; }
 345 };
 346 
 347 
 348 class UIntFlagSetting {
 349   uintx val;
 350   uintx* flag;
 351  public:
 352   UIntFlagSetting(uintx&amp; fl, uintx newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 353   ~UIntFlagSetting()                         { *flag = val; }
 354 };
 355 
 356 
 357 class DoubleFlagSetting {
 358   double val;
 359   double* flag;
 360  public:
 361   DoubleFlagSetting(double&amp; fl, double newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 362   ~DoubleFlagSetting()                           { *flag = val; }
 363 };
 364 
 365 
 366 class CommandLineFlags {
 367  public:
 368   static bool boolAt(const char* name, size_t len, bool* value);
 369   static bool boolAt(const char* name, bool* value)      { return boolAt(name, strlen(name), value); }
 370   static bool boolAtPut(const char* name, size_t len, bool* value, Flag::Flags origin);
 371   static bool boolAtPut(const char* name, bool* value, Flag::Flags origin)   { return boolAtPut(name, strlen(name), value, origin); }
 372 
 373   static bool intxAt(const char* name, size_t len, intx* value);
 374   static bool intxAt(const char* name, intx* value)      { return intxAt(name, strlen(name), value); }
 375   static bool intxAtPut(const char* name, size_t len, intx* value, Flag::Flags origin);
 376   static bool intxAtPut(const char* name, intx* value, Flag::Flags origin)   { return intxAtPut(name, strlen(name), value, origin); }
 377 
 378   static bool uintxAt(const char* name, size_t len, uintx* value);
 379   static bool uintxAt(const char* name, uintx* value)    { return uintxAt(name, strlen(name), value); }
 380   static bool uintxAtPut(const char* name, size_t len, uintx* value, Flag::Flags origin);
 381   static bool uintxAtPut(const char* name, uintx* value, Flag::Flags origin) { return uintxAtPut(name, strlen(name), value, origin); }
 382 
 383   static bool uint64_tAt(const char* name, size_t len, uint64_t* value);
 384   static bool uint64_tAt(const char* name, uint64_t* value) { return uint64_tAt(name, strlen(name), value); }
 385   static bool uint64_tAtPut(const char* name, size_t len, uint64_t* value, Flag::Flags origin);
 386   static bool uint64_tAtPut(const char* name, uint64_t* value, Flag::Flags origin) { return uint64_tAtPut(name, strlen(name), value, origin); }
 387 
 388   static bool doubleAt(const char* name, size_t len, double* value);
 389   static bool doubleAt(const char* name, double* value)    { return doubleAt(name, strlen(name), value); }
 390   static bool doubleAtPut(const char* name, size_t len, double* value, Flag::Flags origin);
 391   static bool doubleAtPut(const char* name, double* value, Flag::Flags origin) { return doubleAtPut(name, strlen(name), value, origin); }
 392 
 393   static bool ccstrAt(const char* name, size_t len, ccstr* value);
 394   static bool ccstrAt(const char* name, ccstr* value)    { return ccstrAt(name, strlen(name), value); }
 395   // Contract:  Flag will make private copy of the incoming value.
 396   // Outgoing value is always malloc-ed, and caller MUST call free.
 397   static bool ccstrAtPut(const char* name, size_t len, ccstr* value, Flag::Flags origin);
 398   static bool ccstrAtPut(const char* name, ccstr* value, Flag::Flags origin) { return ccstrAtPut(name, strlen(name), value, origin); }
 399 
 400   // Returns false if name is not a command line flag.
 401   static bool wasSetOnCmdline(const char* name, bool* value);
 402   static void printSetFlags(outputStream* out);
 403 
 404   static void printFlags(outputStream* out, bool withComments);
 405 
 406   static void verify() PRODUCT_RETURN;
 407 };
 408 
 409 // use this for flags that are true by default in the debug version but
 410 // false in the optimized version, and vice versa
 411 #ifdef ASSERT
 412 #define trueInDebug  true
 413 #define falseInDebug false
 414 #else
 415 #define trueInDebug  false
 416 #define falseInDebug true
 417 #endif
 418 
 419 // use this for flags that are true per default in the product build
 420 // but false in development builds, and vice versa
 421 #ifdef PRODUCT
 422 #define trueInProduct  true
 423 #define falseInProduct false
 424 #else
 425 #define trueInProduct  false
 426 #define falseInProduct true
 427 #endif
 428 
 429 #ifdef JAVASE_EMBEDDED
 430 #define falseInEmbedded false
 431 #else
 432 #define falseInEmbedded true
 433 #endif
 434 
 435 // develop flags are settable / visible only during development and are constant in the PRODUCT version
 436 // product flags are always settable / visible
 437 // notproduct flags are settable / visible only during development and are not declared in the PRODUCT version
 438 
 439 // A flag must be declared with one of the following types:
 440 // bool, intx, uintx, ccstr.
 441 // The type "ccstr" is an alias for "const char*" and is used
 442 // only in this file, because the macrology requires single-token type names.
 443 
 444 // Note: Diagnostic options not meant for VM tuning or for product modes.
 445 // They are to be used for VM quality assurance or field diagnosis
 446 // of VM bugs.  They are hidden so that users will not be encouraged to
 447 // try them as if they were VM ordinary execution options.  However, they
 448 // are available in the product version of the VM.  Under instruction
 449 // from support engineers, VM customers can turn them on to collect
 450 // diagnostic information about VM problems.  To use a VM diagnostic
 451 // option, you must first specify +UnlockDiagnosticVMOptions.
 452 // (This master switch also affects the behavior of -Xprintflags.)
 453 //
 454 // experimental flags are in support of features that are not
 455 //    part of the officially supported product, but are available
 456 //    for experimenting with. They could, for example, be performance
 457 //    features that may not have undergone full or rigorous QA, but which may
 458 //    help performance in some cases and released for experimentation
 459 //    by the community of users and developers. This flag also allows one to
 460 //    be able to build a fully supported product that nonetheless also
 461 //    ships with some unsupported, lightly tested, experimental features.
 462 //    Like the UnlockDiagnosticVMOptions flag above, there is a corresponding
 463 //    UnlockExperimentalVMOptions flag, which allows the control and
 464 //    modification of the experimental flags.
 465 //
 466 // Nota bene: neither diagnostic nor experimental options should be used casually,
 467 //    and they are not supported on production loads, except under explicit
 468 //    direction from support engineers.
 469 //
 470 // manageable flags are writeable external product flags.
 471 //    They are dynamically writeable through the JDK management interface
 472 //    (com.sun.management.HotSpotDiagnosticMXBean API) and also through JConsole.
 473 //    These flags are external exported interface (see CCC).  The list of
 474 //    manageable flags can be queried programmatically through the management
 475 //    interface.
 476 //
 477 //    A flag can be made as "manageable" only if
 478 //    - the flag is defined in a CCC as an external exported interface.
 479 //    - the VM implementation supports dynamic setting of the flag.
 480 //      This implies that the VM must *always* query the flag variable
 481 //      and not reuse state related to the flag state at any given time.
 482 //    - you want the flag to be queried programmatically by the customers.
 483 //
 484 // product_rw flags are writeable internal product flags.
 485 //    They are like "manageable" flags but for internal/private use.
 486 //    The list of product_rw flags are internal/private flags which
 487 //    may be changed/removed in a future release.  It can be set
 488 //    through the management interface to get/set value
 489 //    when the name of flag is supplied.
 490 //
 491 //    A flag can be made as "product_rw" only if
 492 //    - the VM implementation supports dynamic setting of the flag.
 493 //      This implies that the VM must *always* query the flag variable
 494 //      and not reuse state related to the flag state at any given time.
 495 //
 496 // Note that when there is a need to support develop flags to be writeable,
 497 // it can be done in the same way as product_rw.
 498 
 499 #define RUNTIME_FLAGS(develop, develop_pd, product, product_pd, diagnostic, experimental, notproduct, manageable, product_rw, lp64_product) \
 500                                                                             \
 501   lp64_product(bool, UseCompressedOops, false,                              \
 502           "Use 32-bit object references in 64-bit VM. "                     \
 503           "lp64_product means flag is always constant in 32 bit VM")        \
 504                                                                             \
 505   lp64_product(bool, UseCompressedClassPointers, false,                     \
 506           "Use 32-bit class pointers in 64-bit VM. "                        \
 507           "lp64_product means flag is always constant in 32 bit VM")        \
 508                                                                             \
 509   notproduct(bool, CheckCompressedOops, true,                               \
 510           "Generate checks in encoding/decoding code in debug VM")          \
 511                                                                             \
 512   product_pd(uintx, HeapBaseMinAddress,                                     \
 513           "OS specific low limit for heap base address")                    \
 514                                                                             \
 515   diagnostic(bool, PrintCompressedOopsMode, false,                          \
 516           "Print compressed oops base address and encoding mode")           \
 517                                                                             \
 518   lp64_product(intx, ObjectAlignmentInBytes, 8,                             \
 519           "Default object alignment in bytes, 8 is minimum")                \
 520                                                                             \
 521   product(bool, AssumeMP, false,                                            \
 522           "Instruct the VM to assume multiple processors are available")    \
 523                                                                             \
 524   /* UseMembar is theoretically a temp flag used for memory barrier         \
 525    * removal testing.  It was supposed to be removed before FCS but has     \
 526    * been re-added (see 6401008) */                                         \
 527   product_pd(bool, UseMembar,                                               \
 528           "(Unstable) Issues membars on thread state transitions")          \
 529                                                                             \
 530   develop(bool, CleanChunkPoolAsync, falseInEmbedded,                       \
 531           "Clean the chunk pool asynchronously")                            \
 532                                                                             \
 533   /* Temporary: See 6948537 */                                              \
 534   experimental(bool, UseMemSetInBOT, true,                                  \
 535           "(Unstable) uses memset in BOT updates in GC code")               \
 536                                                                             \
 537   diagnostic(bool, UnlockDiagnosticVMOptions, trueInDebug,                  \
 538           "Enable normal processing of flags relating to field diagnostics")\
 539                                                                             \
 540   experimental(bool, UnlockExperimentalVMOptions, false,                    \
 541           "Enable normal processing of flags relating to experimental "     \
 542           "features")                                                       \
 543                                                                             \
 544   product(bool, JavaMonitorsInStackTrace, true,                             \
 545           "Print information about Java monitor locks when the stacks are"  \
 546           "dumped")                                                         \
 547                                                                             \
 548   product_pd(bool, UseLargePages,                                           \
 549           "Use large page memory")                                          \
 550                                                                             \
 551   product_pd(bool, UseLargePagesIndividualAllocation,                       \
 552           "Allocate large pages individually for better affinity")          \
 553                                                                             \
 554   develop(bool, LargePagesIndividualAllocationInjectError, false,           \
 555           "Fail large pages individual allocation")                         \
 556                                                                             \
 557   product(bool, UseLargePagesInMetaspace, false,                            \
 558           "Use large page memory in metaspace. "                            \
 559           "Only used if UseLargePages is enabled.")                         \
 560                                                                             \
 561   develop(bool, TracePageSizes, false,                                      \
 562           "Trace page size selection and usage")                            \
 563                                                                             \
 564   product(bool, UseNUMA, false,                                             \
 565           "Use NUMA if available")                                          \
 566                                                                             \
 567   product(bool, UseNUMAInterleaving, false,                                 \
 568           "Interleave memory across NUMA nodes if available")               \
 569                                                                             \
 570   product(uintx, NUMAInterleaveGranularity, 2*M,                            \
 571           "Granularity to use for NUMA interleaving on Windows OS")         \
 572                                                                             \
 573   product(bool, ForceNUMA, false,                                           \
 574           "Force NUMA optimizations on single-node/UMA systems")            \
 575                                                                             \
 576   product(uintx, NUMAChunkResizeWeight, 20,                                 \
 577           "Percentage (0-100) used to weigh the current sample when "       \
 578           "computing exponentially decaying average for "                   \
 579           "AdaptiveNUMAChunkSizing")                                        \
 580                                                                             \
 581   product(uintx, NUMASpaceResizeRate, 1*G,                                  \
 582           "Do not reallocate more than this amount per collection")         \
 583                                                                             \
 584   product(bool, UseAdaptiveNUMAChunkSizing, true,                           \
 585           "Enable adaptive chunk sizing for NUMA")                          \
 586                                                                             \
 587   product(bool, NUMAStats, false,                                           \
 588           "Print NUMA stats in detailed heap information")                  \
 589                                                                             \
 590   product(uintx, NUMAPageScanRate, 256,                                     \
 591           "Maximum number of pages to include in the page scan procedure")  \
 592                                                                             \
 593   product_pd(bool, NeedsDeoptSuspend,                                       \
 594           "True for register window machines (sparc/ia64)")                 \
 595                                                                             \
 596   product(intx, UseSSE, 99,                                                 \
 597           "Highest supported SSE instructions set on x86/x64")              \
 598                                                                             \
 599   product(bool, UseAES, false,                                              \
 600           "Control whether AES instructions can be used on x86/x64")        \
 601                                                                             \
 602   product(bool, UseSHA, false,                                              \
 603           "Control whether SHA instructions can be used on SPARC")          \
 604                                                                             \
 605   product(uintx, LargePageSizeInBytes, 0,                                   \
 606           "Large page size (0 to let VM choose the page size)")             \
 607                                                                             \
 608   product(uintx, LargePageHeapSizeThreshold, 128*M,                         \
 609           "Use large pages if maximum heap is at least this big")           \
 610                                                                             \
 611   product(bool, ForceTimeHighResolution, false,                             \
 612           "Using high time resolution (for Win32 only)")                    \
 613                                                                             \
 614   develop(bool, TraceItables, false,                                        \
 615           "Trace initialization and use of itables")                        \
 616                                                                             \
 617   develop(bool, TracePcPatching, false,                                     \
 618           "Trace usage of frame::patch_pc")                                 \
 619                                                                             \
 620   develop(bool, TraceJumps, false,                                          \
 621           "Trace assembly jumps in thread ring buffer")                     \
 622                                                                             \
 623   develop(bool, TraceRelocator, false,                                      \
 624           "Trace the bytecode relocator")                                   \
 625                                                                             \
 626   develop(bool, TraceLongCompiles, false,                                   \
 627           "Print out every time compilation is longer than "                \
 628           "a given threshold")                                              \
 629                                                                             \
 630   develop(bool, SafepointALot, false,                                       \
 631           "Generate a lot of safepoints. This works with "                  \
 632           "GuaranteedSafepointInterval")                                    \
 633                                                                             \
 634   product_pd(bool, BackgroundCompilation,                                   \
 635           "A thread requesting compilation is not blocked during "          \
 636           "compilation")                                                    \
 637                                                                             \
 638   product(bool, PrintVMQWaitTime, false,                                    \
 639           "Print out the waiting time in VM operation queue")               \
 640                                                                             \
 641   develop(bool, NoYieldsInMicrolock, false,                                 \
 642           "Disable yields in microlock")                                    \
 643                                                                             \
 644   develop(bool, TraceOopMapGeneration, false,                               \
 645           "Show OopMapGeneration")                                          \
 646                                                                             \
 647   product(bool, MethodFlushing, true,                                       \
 648           "Reclamation of zombie and not-entrant methods")                  \
 649                                                                             \
 650   develop(bool, VerifyStack, false,                                         \
 651           "Verify stack of each thread when it is entering a runtime call") \
 652                                                                             \
 653   diagnostic(bool, ForceUnreachable, false,                                 \
 654           "Make all non code cache addresses to be unreachable by "         \
 655           "forcing use of 64bit literal fixups")                            \
 656                                                                             \
 657   notproduct(bool, StressDerivedPointers, false,                            \
 658           "Force scavenge when a derived pointer is detected on stack "     \
 659           "after rtm call")                                                 \
 660                                                                             \
 661   develop(bool, TraceDerivedPointers, false,                                \
 662           "Trace traversal of derived pointers on stack")                   \
 663                                                                             \
 664   notproduct(bool, TraceCodeBlobStacks, false,                              \
 665           "Trace stack-walk of codeblobs")                                  \
 666                                                                             \
 667   product(bool, PrintJNIResolving, false,                                   \
 668           "Used to implement -v:jni")                                       \
 669                                                                             \
 670   notproduct(bool, PrintRewrites, false,                                    \
 671           "Print methods that are being rewritten")                         \
 672                                                                             \
 673   product(bool, UseInlineCaches, true,                                      \
 674           "Use Inline Caches for virtual calls ")                           \
 675                                                                             \
 676   develop(bool, InlineArrayCopy, true,                                      \
 677           "Inline arraycopy native that is known to be part of "            \
 678           "base library DLL")                                               \
 679                                                                             \
 680   develop(bool, InlineObjectHash, true,                                     \
 681           "Inline Object::hashCode() native that is known to be part "      \
 682           "of base library DLL")                                            \
 683                                                                             \
 684   develop(bool, InlineNatives, true,                                        \
 685           "Inline natives that are known to be part of base library DLL")   \
 686                                                                             \
 687   develop(bool, InlineMathNatives, true,                                    \
 688           "Inline SinD, CosD, etc.")                                        \
 689                                                                             \
 690   develop(bool, InlineClassNatives, true,                                   \
 691           "Inline Class.isInstance, etc")                                   \
 692                                                                             \
 693   develop(bool, InlineThreadNatives, true,                                  \
 694           "Inline Thread.currentThread, etc")                               \
 695                                                                             \
 696   develop(bool, InlineUnsafeOps, true,                                      \
 697           "Inline memory ops (native methods) from sun.misc.Unsafe")        \
 698                                                                             \
 699   product(bool, CriticalJNINatives, true,                                   \
 700           "Check for critical JNI entry points")                            \
 701                                                                             \
 702   notproduct(bool, StressCriticalJNINatives, false,                         \
 703           "Exercise register saving code in critical natives")              \
 704                                                                             \
 705   product(bool, UseSSE42Intrinsics, false,                                  \
 706           "SSE4.2 versions of intrinsics")                                  \
 707                                                                             \
 708   product(bool, UseAESIntrinsics, false,                                    \
 709           "Use intrinsics for AES versions of crypto")                      \
 710                                                                             \
 711   product(bool, UseSHA1Intrinsics, false,                                   \
 712           "Use intrinsics for SHA-1 crypto hash function")                  \
 713                                                                             \
 714   product(bool, UseSHA256Intrinsics, false,                                 \
 715           "Use intrinsics for SHA-224 and SHA-256 crypto hash functions")   \
 716                                                                             \
 717   product(bool, UseSHA512Intrinsics, false,                                 \
 718           "Use intrinsics for SHA-384 and SHA-512 crypto hash functions")   \
 719                                                                             \
 720   product(bool, UseCRC32Intrinsics, false,                                  \
<a name="1" id="anc1"></a><span class="changed"> 721           "Use intrinsics for java.util.zip.CRC32")                         \</span>
<span class="changed"> 722                                                                             \</span>
<span class="changed"> 723   product(bool, UseObjectLayoutIntrinsics, false,                           \</span>
<span class="changed"> 724           "Use intrinsics enabling optimized ObjectLayout implementation")  \</span>
<span class="changed"> 725                                                                             \</span>
<span class="changed"> 726   product(bool, TraceObjectLayoutIntrinsics, false,                         \</span>
<span class="changed"> 727           "Trace intrinsics specific to ObjectLayout implementation")       \</span>
<span class="changed"> 728                                                                             \</span>
<span class="changed"> 729   product(intx, ObjectLayoutIntrinsicsTraceLevel, 0,                        \</span>
<span class="changed"> 730           "Trace level for ObjectLayout related intrinsics")                \</span>
 731                                                                             \
 732   develop(bool, TraceCallFixup, false,                                      \
 733           "Trace all call fixups")                                          \
 734                                                                             \
 735   develop(bool, DeoptimizeALot, false,                                      \
 736           "Deoptimize at every exit from the runtime system")               \
 737                                                                             \
 738   notproduct(ccstrlist, DeoptimizeOnlyAt, "",                               \
 739           "A comma separated list of bcis to deoptimize at")                \
 740                                                                             \
 741   product(bool, DeoptimizeRandom, false,                                    \
 742           "Deoptimize random frames on random exit from the runtime system")\
 743                                                                             \
 744   notproduct(bool, ZombieALot, false,                                       \
 745           "Create zombies (non-entrant) at exit from the runtime system")   \
 746                                                                             \
 747   product(bool, UnlinkSymbolsALot, false,                                   \
 748           "Unlink unreferenced symbols from the symbol table at safepoints")\
 749                                                                             \
 750   notproduct(bool, WalkStackALot, false,                                    \
 751           "Trace stack (no print) at every exit from the runtime system")   \
 752                                                                             \
 753   product(bool, Debugging, false,                                           \
 754           "Set when executing debug methods in debug.cpp "                  \
 755           "(to prevent triggering assertions)")                             \
 756                                                                             \
 757   notproduct(bool, StrictSafepointChecks, trueInDebug,                      \
 758           "Enable strict checks that safepoints cannot happen for threads " \
 759           "that use No_Safepoint_Verifier")                                 \
 760                                                                             \
 761   notproduct(bool, VerifyLastFrame, false,                                  \
 762           "Verify oops on last frame on entry to VM")                       \
 763                                                                             \
 764   develop(bool, TraceHandleAllocation, false,                               \
 765           "Print out warnings when suspiciously many handles are allocated")\
 766                                                                             \
 767   product(bool, UseCompilerSafepoints, true,                                \
 768           "Stop at safepoints in compiled code")                            \
 769                                                                             \
 770   product(bool, FailOverToOldVerifier, true,                                \
 771           "Fail over to old verifier when split verifier fails")            \
 772                                                                             \
 773   develop(bool, ShowSafepointMsgs, false,                                   \
 774           "Show message about safepoint synchronization")                   \
 775                                                                             \
 776   product(bool, SafepointTimeout, false,                                    \
 777           "Time out and warn or fail after SafepointTimeoutDelay "          \
 778           "milliseconds if failed to reach safepoint")                      \
 779                                                                             \
 780   develop(bool, DieOnSafepointTimeout, false,                               \
 781           "Die upon failure to reach safepoint (see SafepointTimeout)")     \
 782                                                                             \
 783   /* 50 retries * (5 * current_retry_count) millis = ~6.375 seconds */      \
 784   /* typically, at most a few retries are needed */                         \
 785   product(intx, SuspendRetryCount, 50,                                      \
 786           "Maximum retry count for an external suspend request")            \
 787                                                                             \
 788   product(intx, SuspendRetryDelay, 5,                                       \
 789           "Milliseconds to delay per retry (* current_retry_count)")        \
 790                                                                             \
 791   product(bool, AssertOnSuspendWaitFailure, false,                          \
 792           "Assert/Guarantee on external suspend wait failure")              \
 793                                                                             \
 794   product(bool, TraceSuspendWaitFailures, false,                            \
 795           "Trace external suspend wait failures")                           \
 796                                                                             \
 797   product(bool, MaxFDLimit, true,                                           \
 798           "Bump the number of file descriptors to maximum in Solaris")      \
 799                                                                             \
 800   diagnostic(bool, LogEvents, true,                                         \
 801           "Enable the various ring buffer event logs")                      \
 802                                                                             \
 803   diagnostic(uintx, LogEventsBufferEntries, 10,                             \
 804           "Number of ring buffer event logs")                               \
 805                                                                             \
 806   product(bool, BytecodeVerificationRemote, true,                           \
 807           "Enable the Java bytecode verifier for remote classes")           \
 808                                                                             \
 809   product(bool, BytecodeVerificationLocal, false,                           \
 810           "Enable the Java bytecode verifier for local classes")            \
 811                                                                             \
 812   develop(bool, ForceFloatExceptions, trueInDebug,                          \
 813           "Force exceptions on FP stack under/overflow")                    \
 814                                                                             \
 815   develop(bool, VerifyStackAtCalls, false,                                  \
 816           "Verify that the stack pointer is unchanged after calls")         \
 817                                                                             \
 818   develop(bool, TraceJavaAssertions, false,                                 \
 819           "Trace java language assertions")                                 \
 820                                                                             \
 821   notproduct(bool, CheckAssertionStatusDirectives, false,                   \
 822           "Temporary - see javaClasses.cpp")                                \
 823                                                                             \
 824   notproduct(bool, PrintMallocFree, false,                                  \
 825           "Trace calls to C heap malloc/free allocation")                   \
 826                                                                             \
 827   product(bool, PrintOopAddress, false,                                     \
 828           "Always print the location of the oop")                           \
 829                                                                             \
 830   notproduct(bool, VerifyCodeCacheOften, false,                             \
 831           "Verify compiled-code cache often")                               \
 832                                                                             \
 833   develop(bool, ZapDeadCompiledLocals, false,                               \
 834           "Zap dead locals in compiler frames")                             \
 835                                                                             \
 836   notproduct(bool, ZapDeadLocalsOld, false,                                 \
 837           "Zap dead locals (old version, zaps all frames when "             \
 838           "entering the VM")                                                \
 839                                                                             \
 840   notproduct(bool, CheckOopishValues, false,                                \
 841           "Warn if value contains oop (requires ZapDeadLocals)")            \
 842                                                                             \
 843   develop(bool, UseMallocOnly, false,                                       \
 844           "Use only malloc/free for allocation (no resource area/arena)")   \
 845                                                                             \
 846   develop(bool, PrintMalloc, false,                                         \
 847           "Print all malloc/free calls")                                    \
 848                                                                             \
 849   develop(bool, PrintMallocStatistics, false,                               \
 850           "Print malloc/free statistics")                                   \
 851                                                                             \
 852   develop(bool, ZapResourceArea, trueInDebug,                               \
 853           "Zap freed resource/arena space with 0xABABABAB")                 \
 854                                                                             \
 855   notproduct(bool, ZapVMHandleArea, trueInDebug,                            \
 856           "Zap freed VM handle space with 0xBCBCBCBC")                      \
 857                                                                             \
 858   develop(bool, ZapJNIHandleArea, trueInDebug,                              \
 859           "Zap freed JNI handle space with 0xFEFEFEFE")                     \
 860                                                                             \
 861   notproduct(bool, ZapStackSegments, trueInDebug,                           \
 862           "Zap allocated/freed stack segments with 0xFADFADED")             \
 863                                                                             \
 864   develop(bool, ZapUnusedHeapArea, trueInDebug,                             \
 865           "Zap unused heap space with 0xBAADBABE")                          \
 866                                                                             \
 867   develop(bool, TraceZapUnusedHeapArea, false,                              \
 868           "Trace zapping of unused heap space")                             \
 869                                                                             \
 870   develop(bool, CheckZapUnusedHeapArea, false,                              \
 871           "Check zapping of unused heap space")                             \
 872                                                                             \
 873   develop(bool, ZapFillerObjects, trueInDebug,                              \
 874           "Zap filler objects with 0xDEAFBABE")                             \
 875                                                                             \
 876   develop(bool, PrintVMMessages, true,                                      \
 877           "Print VM messages on console")                                   \
 878                                                                             \
 879   product(bool, PrintGCApplicationConcurrentTime, false,                    \
 880           "Print the time the application has been running")                \
 881                                                                             \
 882   product(bool, PrintGCApplicationStoppedTime, false,                       \
 883           "Print the time the application has been stopped")                \
 884                                                                             \
 885   diagnostic(bool, VerboseVerification, false,                              \
 886           "Display detailed verification details")                          \
 887                                                                             \
 888   notproduct(uintx, ErrorHandlerTest, 0,                                    \
 889           "If &gt; 0, provokes an error after VM initialization; the value "   \
 890           "determines which error to provoke. See test_error_handler() "    \
 891           "in debug.cpp.")                                                  \
 892                                                                             \
 893   develop(bool, Verbose, false,                                             \
 894           "Print additional debugging information from other modes")        \
 895                                                                             \
 896   develop(bool, PrintMiscellaneous, false,                                  \
 897           "Print uncategorized debugging information (requires +Verbose)")  \
 898                                                                             \
 899   develop(bool, WizardMode, false,                                          \
 900           "Print much more debugging information")                          \
 901                                                                             \
 902   product(bool, ShowMessageBoxOnError, false,                               \
 903           "Keep process alive on VM fatal error")                           \
 904                                                                             \
 905   product(bool, CreateMinidumpOnCrash, false,                               \
 906           "Create minidump on VM fatal error")                              \
 907                                                                             \
 908   product_pd(bool, UseOSErrorReporting,                                     \
 909           "Let VM fatal error propagate to the OS (ie. WER on Windows)")    \
 910                                                                             \
 911   product(bool, SuppressFatalErrorMessage, false,                           \
 912           "Report NO fatal error message (avoid deadlock)")                 \
 913                                                                             \
 914   product(ccstrlist, OnError, "",                                           \
 915           "Run user-defined commands on fatal error; see VMError.cpp "      \
 916           "for examples")                                                   \
 917                                                                             \
 918   product(ccstrlist, OnOutOfMemoryError, "",                                \
 919           "Run user-defined commands on first java.lang.OutOfMemoryError")  \
 920                                                                             \
 921   manageable(bool, HeapDumpBeforeFullGC, false,                             \
 922           "Dump heap to file before any major stop-the-world GC")           \
 923                                                                             \
 924   manageable(bool, HeapDumpAfterFullGC, false,                              \
 925           "Dump heap to file after any major stop-the-world GC")            \
 926                                                                             \
 927   manageable(bool, HeapDumpOnOutOfMemoryError, false,                       \
 928           "Dump heap to file when java.lang.OutOfMemoryError is thrown")    \
 929                                                                             \
 930   manageable(ccstr, HeapDumpPath, NULL,                                     \
 931           "When HeapDumpOnOutOfMemoryError is on, the path (filename or "   \
 932           "directory) of the dump file (defaults to java_pid&lt;pid&gt;.hprof "   \
 933           "in the working directory)")                                      \
 934                                                                             \
 935   develop(uintx, SegmentedHeapDumpThreshold, 2*G,                           \
 936           "Generate a segmented heap dump (JAVA PROFILE 1.0.2 format) "     \
 937           "when the heap usage is larger than this")                        \
 938                                                                             \
 939   develop(uintx, HeapDumpSegmentSize, 1*G,                                  \
 940           "Approximate segment size when generating a segmented heap dump") \
 941                                                                             \
 942   develop(bool, BreakAtWarning, false,                                      \
 943           "Execute breakpoint upon encountering VM warning")                \
 944                                                                             \
 945   develop(bool, TraceVMOperation, false,                                    \
 946           "Trace VM operations")                                            \
 947                                                                             \
 948   develop(bool, UseFakeTimers, false,                                       \
 949           "Tell whether the VM should use system time or a fake timer")     \
 950                                                                             \
 951   product(ccstr, NativeMemoryTracking, "off",                               \
 952           "Native memory tracking options")                                 \
 953                                                                             \
 954   diagnostic(bool, PrintNMTStatistics, false,                               \
 955           "Print native memory tracking summary data if it is on")          \
 956                                                                             \
 957   diagnostic(bool, LogCompilation, false,                                   \
 958           "Log compilation activity in detail to LogFile")                  \
 959                                                                             \
 960   product(bool, PrintCompilation, false,                                    \
 961           "Print compilations")                                             \
 962                                                                             \
 963   diagnostic(bool, TraceNMethodInstalls, false,                             \
 964           "Trace nmethod installation")                                     \
 965                                                                             \
 966   diagnostic(intx, ScavengeRootsInCode, 2,                                  \
 967           "0: do not allow scavengable oops in the code cache; "            \
 968           "1: allow scavenging from the code cache; "                       \
 969           "2: emit as many constants as the compiler can see")              \
 970                                                                             \
 971   product(bool, AlwaysRestoreFPU, false,                                    \
 972           "Restore the FPU control word after every JNI call (expensive)")  \
 973                                                                             \
 974   diagnostic(bool, PrintCompilation2, false,                                \
 975           "Print additional statistics per compilation")                    \
 976                                                                             \
 977   diagnostic(bool, PrintAdapterHandlers, false,                             \
 978           "Print code generated for i2c/c2i adapters")                      \
 979                                                                             \
 980   diagnostic(bool, VerifyAdapterCalls, trueInDebug,                         \
 981           "Verify that i2c/c2i adapters are called properly")               \
 982                                                                             \
 983   develop(bool, VerifyAdapterSharing, false,                                \
 984           "Verify that the code for shared adapters is the equivalent")     \
 985                                                                             \
 986   diagnostic(bool, PrintAssembly, false,                                    \
 987           "Print assembly code (using external disassembler.so)")           \
 988                                                                             \
 989   diagnostic(ccstr, PrintAssemblyOptions, NULL,                             \
 990           "Print options string passed to disassembler.so")                 \
 991                                                                             \
 992   diagnostic(bool, PrintNMethods, false,                                    \
 993           "Print assembly code for nmethods when generated")                \
 994                                                                             \
 995   diagnostic(bool, PrintNativeNMethods, false,                              \
 996           "Print assembly code for native nmethods when generated")         \
 997                                                                             \
 998   develop(bool, PrintDebugInfo, false,                                      \
 999           "Print debug information for all nmethods when generated")        \
1000                                                                             \
1001   develop(bool, PrintRelocations, false,                                    \
1002           "Print relocation information for all nmethods when generated")   \
1003                                                                             \
1004   develop(bool, PrintDependencies, false,                                   \
1005           "Print dependency information for all nmethods when generated")   \
1006                                                                             \
1007   develop(bool, PrintExceptionHandlers, false,                              \
1008           "Print exception handler tables for all nmethods when generated") \
1009                                                                             \
1010   develop(bool, StressCompiledExceptionHandlers, false,                     \
1011           "Exercise compiled exception handlers")                           \
1012                                                                             \
1013   develop(bool, InterceptOSException, false,                                \
1014           "Start debugger when an implicit OS (e.g. NULL) "                 \
1015           "exception happens")                                              \
1016                                                                             \
1017   product(bool, PrintCodeCache, false,                                      \
1018           "Print the code cache memory usage when exiting")                 \
1019                                                                             \
1020   develop(bool, PrintCodeCache2, false,                                     \
1021           "Print detailed usage information on the code cache when exiting")\
1022                                                                             \
1023   product(bool, PrintCodeCacheOnCompilation, false,                         \
1024           "Print the code cache memory usage each time a method is "        \
1025           "compiled")                                                       \
1026                                                                             \
1027   diagnostic(bool, PrintStubCode, false,                                    \
1028           "Print generated stub code")                                      \
1029                                                                             \
1030   product(bool, StackTraceInThrowable, true,                                \
1031           "Collect backtrace in throwable when exception happens")          \
1032                                                                             \
1033   product(bool, OmitStackTraceInFastThrow, true,                            \
1034           "Omit backtraces for some 'hot' exceptions in optimized code")    \
1035                                                                             \
1036   product(bool, ProfilerPrintByteCodeStatistics, false,                     \
1037           "Print bytecode statistics when dumping profiler output")         \
1038                                                                             \
1039   product(bool, ProfilerRecordPC, false,                                    \
1040           "Collect ticks for each 16 byte interval of compiled code")       \
1041                                                                             \
1042   product(bool, ProfileVM, false,                                           \
1043           "Profile ticks that fall within VM (either in the VM Thread "     \
1044           "or VM code called through stubs)")                               \
1045                                                                             \
1046   product(bool, ProfileIntervals, false,                                    \
1047           "Print profiles for each interval (see ProfileIntervalsTicks)")   \
1048                                                                             \
1049   notproduct(bool, ProfilerCheckIntervals, false,                           \
1050           "Collect and print information on spacing of profiler ticks")     \
1051                                                                             \
1052   develop(bool, PrintJVMWarnings, false,                                    \
1053           "Print warnings for unimplemented JVM functions")                 \
1054                                                                             \
1055   product(bool, PrintWarnings, true,                                        \
1056           "Print JVM warnings to output stream")                            \
1057                                                                             \
1058   notproduct(uintx, WarnOnStalledSpinLock, 0,                               \
1059           "Print warnings for stalled SpinLocks")                           \
1060                                                                             \
1061   product(bool, RegisterFinalizersAtInit, true,                             \
1062           "Register finalizable objects at end of Object.&lt;init&gt; or "        \
1063           "after allocation")                                               \
1064                                                                             \
1065   develop(bool, RegisterReferences, true,                                   \
1066           "Tell whether the VM should register soft/weak/final/phantom "    \
1067           "references")                                                     \
1068                                                                             \
1069   develop(bool, IgnoreRewrites, false,                                      \
1070           "Suppress rewrites of bytecodes in the oopmap generator. "        \
1071           "This is unsafe!")                                                \
1072                                                                             \
1073   develop(bool, PrintCodeCacheExtension, false,                             \
1074           "Print extension of code cache")                                  \
1075                                                                             \
1076   develop(bool, UsePrivilegedStack, true,                                   \
1077           "Enable the security JVM functions")                              \
1078                                                                             \
1079   develop(bool, ProtectionDomainVerification, true,                         \
1080           "Verify protection domain before resolution in system dictionary")\
1081                                                                             \
1082   product(bool, ClassUnloading, true,                                       \
1083           "Do unloading of classes")                                        \
1084                                                                             \
1085   product(bool, ClassUnloadingWithConcurrentMark, true,                     \
1086           "Do unloading of classes with a concurrent marking cycle")        \
1087                                                                             \
1088   develop(bool, DisableStartThread, false,                                  \
1089           "Disable starting of additional Java threads "                    \
1090           "(for debugging only)")                                           \
1091                                                                             \
1092   develop(bool, MemProfiling, false,                                        \
1093           "Write memory usage profiling to log file")                       \
1094                                                                             \
1095   notproduct(bool, PrintSystemDictionaryAtExit, false,                      \
1096           "Print the system dictionary at exit")                            \
1097                                                                             \
1098   experimental(intx, PredictedLoadedClassCount, 0,                          \
1099           "Experimental: Tune loaded class cache starting size")            \
1100                                                                             \
1101   diagnostic(bool, UnsyncloadClass, false,                                  \
1102           "Unstable: VM calls loadClass unsynchronized. Custom "            \
1103           "class loader must call VM synchronized for findClass "           \
1104           "and defineClass.")                                               \
1105                                                                             \
1106   product(bool, AlwaysLockClassLoader, false,                               \
1107           "Require the VM to acquire the class loader lock before calling " \
1108           "loadClass() even for class loaders registering "                 \
1109           "as parallel capable")                                            \
1110                                                                             \
1111   product(bool, AllowParallelDefineClass, false,                            \
1112           "Allow parallel defineClass requests for class loaders "          \
1113           "registering as parallel capable")                                \
1114                                                                             \
1115   product(bool, MustCallLoadClassInternal, false,                           \
1116           "Call loadClassInternal() rather than loadClass()")               \
1117                                                                             \
1118   product_pd(bool, DontYieldALot,                                           \
1119           "Throw away obvious excess yield calls (for Solaris only)")       \
1120                                                                             \
1121   product_pd(bool, ConvertSleepToYield,                                     \
1122           "Convert sleep(0) to thread yield "                               \
1123           "(may be off for Solaris to improve GUI)")                        \
1124                                                                             \
1125   product(bool, ConvertYieldToSleep, false,                                 \
1126           "Convert yield to a sleep of MinSleepInterval to simulate Win32 " \
1127           "behavior (Solaris only)")                                        \
1128                                                                             \
1129   product(bool, UseBoundThreads, true,                                      \
1130           "Bind user level threads to kernel threads (for Solaris only)")   \
1131                                                                             \
1132   develop(bool, UseDetachedThreads, true,                                   \
1133           "Use detached threads that are recycled upon termination "        \
1134           "(for Solaris only)")                                             \
1135                                                                             \
1136   product(bool, UseLWPSynchronization, true,                                \
1137           "Use LWP-based instead of libthread-based synchronization "       \
1138           "(SPARC only)")                                                   \
1139                                                                             \
1140   product(ccstr, SyncKnobs, NULL,                                           \
1141           "(Unstable) Various monitor synchronization tunables")            \
1142                                                                             \
1143   product(intx, EmitSync, 0,                                                \
1144           "(Unsafe, Unstable) "                                             \
1145           "Control emission of inline sync fast-path code")                 \
1146                                                                             \
1147   product(intx, MonitorBound, 0, "Bound Monitor population")                \
1148                                                                             \
1149   product(bool, MonitorInUseLists, false, "Track Monitors for Deflation")   \
1150                                                                             \
1151   product(intx, SyncFlags, 0, "(Unsafe, Unstable) Experimental Sync flags") \
1152                                                                             \
1153   product(intx, SyncVerbose, 0, "(Unstable)")                               \
1154                                                                             \
1155   product(intx, ClearFPUAtPark, 0, "(Unsafe, Unstable)")                    \
1156                                                                             \
1157   product(intx, hashCode, 5,                                                \
1158           "(Unstable) select hashCode generation algorithm")                \
1159                                                                             \
1160   product(intx, WorkAroundNPTLTimedWaitHang, 1,                             \
1161           "(Unstable, Linux-specific) "                                     \
1162           "avoid NPTL-FUTEX hang pthread_cond_timedwait")                   \
1163                                                                             \
1164   product(bool, FilterSpuriousWakeups, true,                                \
1165           "Prevent spurious or premature wakeups from object.wait "         \
1166           "(Solaris only)")                                                 \
1167                                                                             \
1168   experimental(intx, NativeMonitorTimeout, -1, "(Unstable)")                \
1169                                                                             \
1170   experimental(intx, NativeMonitorFlags, 0, "(Unstable)")                   \
1171                                                                             \
1172   experimental(intx, NativeMonitorSpinLimit, 20, "(Unstable)")              \
1173                                                                             \
1174   develop(bool, UsePthreads, false,                                         \
1175           "Use pthread-based instead of libthread-based synchronization "   \
1176           "(SPARC only)")                                                   \
1177                                                                             \
1178   product(bool, AdjustConcurrency, false,                                   \
1179           "Call thr_setconcurrency at thread creation time to avoid "       \
1180           "LWP starvation on MP systems (for Solaris Only)")                \
1181                                                                             \
1182   product(bool, ReduceSignalUsage, false,                                   \
1183           "Reduce the use of OS signals in Java and/or the VM")             \
1184                                                                             \
1185   develop_pd(bool, ShareVtableStubs,                                        \
1186           "Share vtable stubs (smaller code but worse branch prediction")   \
1187                                                                             \
1188   develop(bool, LoadLineNumberTables, true,                                 \
1189           "Tell whether the class file parser loads line number tables")    \
1190                                                                             \
1191   develop(bool, LoadLocalVariableTables, true,                              \
1192           "Tell whether the class file parser loads local variable tables") \
1193                                                                             \
1194   develop(bool, LoadLocalVariableTypeTables, true,                          \
1195           "Tell whether the class file parser loads local variable type"    \
1196           "tables")                                                         \
1197                                                                             \
1198   product(bool, AllowUserSignalHandlers, false,                             \
1199           "Do not complain if the application installs signal handlers "    \
1200           "(Solaris &amp; Linux only)")                                         \
1201                                                                             \
1202   product(bool, UseSignalChaining, true,                                    \
1203           "Use signal-chaining to invoke signal handlers installed "        \
1204           "by the application (Solaris &amp; Linux only)")                      \
1205                                                                             \
1206   product(bool, UseAltSigs, false,                                          \
1207           "Use alternate signals instead of SIGUSR1 &amp; SIGUSR2 for VM "      \
1208           "internal signals (Solaris only)")                                \
1209                                                                             \
1210   product(bool, AllowJNIEnvProxy, false,                                    \
1211           "Allow JNIEnv proxies for jdbx")                                  \
1212                                                                             \
1213   product(bool, JNIDetachReleasesMonitors, true,                            \
1214           "JNI DetachCurrentThread releases monitors owned by thread")      \
1215                                                                             \
1216   product(bool, RestoreMXCSROnJNICalls, false,                              \
1217           "Restore MXCSR when returning from JNI calls")                    \
1218                                                                             \
1219   product(bool, CheckJNICalls, false,                                       \
1220           "Verify all arguments to JNI calls")                              \
1221                                                                             \
1222   product(bool, CheckEndorsedAndExtDirs, false,                             \
1223           "Verify the endorsed and extension directories are not used")     \
1224                                                                             \
1225   product(bool, UseFastJNIAccessors, true,                                  \
1226           "Use optimized versions of Get&lt;Primitive&gt;Field")                  \
1227                                                                             \
1228   product(intx, MaxJNILocalCapacity, 65536,                                 \
1229           "Maximum allowable local JNI handle capacity to "                 \
1230           "EnsureLocalCapacity() and PushLocalFrame(), "                    \
1231           "where &lt;= 0 is unlimited, default: 65536")                        \
1232                                                                             \
1233   product(bool, EagerXrunInit, false,                                       \
1234           "Eagerly initialize -Xrun libraries; allows startup profiling, "  \
1235           "but not all -Xrun libraries may support the state of the VM "    \
1236           "at this time")                                                   \
1237                                                                             \
1238   product(bool, PreserveAllAnnotations, false,                              \
1239           "Preserve RuntimeInvisibleAnnotations as well "                   \
1240           "as RuntimeVisibleAnnotations")                                   \
1241                                                                             \
1242   develop(uintx, PreallocatedOutOfMemoryErrorCount, 4,                      \
1243           "Number of OutOfMemoryErrors preallocated with backtrace")        \
1244                                                                             \
1245   product(bool, LazyBootClassLoader, true,                                  \
1246           "Enable/disable lazy opening of boot class path entries")         \
1247                                                                             \
1248   product(bool, UseXMMForArrayCopy, false,                                  \
1249           "Use SSE2 MOVQ instruction for Arraycopy")                        \
1250                                                                             \
1251   product(intx, FieldsAllocationStyle, 1,                                   \
1252           "0 - type based with oops first, 1 - with oops last, "            \
1253           "2 - oops in super and sub classes are together")                 \
1254                                                                             \
1255   product(bool, CompactFields, true,                                        \
1256           "Allocate nonstatic fields in gaps between previous fields")      \
1257                                                                             \
<a name="2" id="anc2"></a><span class="changed">1258   product(bool, PrintFieldLayout, false,                                    \</span>
1259           "Print field layout for each class")                              \
1260                                                                             \
1261   product(intx, ContendedPaddingWidth, 128,                                 \
1262           "How many bytes to pad the fields/classes marked @Contended with")\
1263                                                                             \
1264   product(bool, EnableContended, true,                                      \
1265           "Enable @Contended annotation support")                           \
1266                                                                             \
1267   product(bool, RestrictContended, true,                                    \
1268           "Restrict @Contended to trusted classes")                         \
1269                                                                             \
<a name="3" id="anc3"></a><span class="changed">1270   product(bool, UseBiasedLocking, false,                                     \</span>
1271           "Enable biased locking in JVM")                                   \
1272                                                                             \
1273   product(intx, BiasedLockingStartupDelay, 4000,                            \
1274           "Number of milliseconds to wait before enabling biased locking")  \
1275                                                                             \
1276   diagnostic(bool, PrintBiasedLockingStatistics, false,                     \
1277           "Print statistics of biased locking in JVM")                      \
1278                                                                             \
1279   product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \
1280           "Threshold of number of revocations per type to try to "          \
1281           "rebias all objects in the heap of that type")                    \
1282                                                                             \
1283   product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \
1284           "Threshold of number of revocations per type to permanently "     \
1285           "revoke biases of all objects in the heap of that type")          \
1286                                                                             \
1287   product(intx, BiasedLockingDecayTime, 25000,                              \
1288           "Decay time (in milliseconds) to re-enable bulk rebiasing of a "  \
1289           "type after previous bulk rebias")                                \
1290                                                                             \
1291   /* tracing */                                                             \
1292                                                                             \
1293   notproduct(bool, TraceRuntimeCalls, false,                                \
1294           "Trace run-time calls")                                           \
1295                                                                             \
1296   develop(bool, TraceJNICalls, false,                                       \
1297           "Trace JNI calls")                                                \
1298                                                                             \
1299   develop(bool, StressRewriter, false,                                      \
1300           "Stress linktime bytecode rewriting")                             \
1301                                                                             \
1302   notproduct(bool, TraceJVMCalls, false,                                    \
1303           "Trace JVM calls")                                                \
1304                                                                             \
1305   product(ccstr, TraceJVMTI, NULL,                                          \
1306           "Trace flags for JVMTI functions and events")                     \
1307                                                                             \
1308   /* This option can change an EMCP method into an obsolete method. */      \
1309   /* This can affect tests that except specific methods to be EMCP. */      \
1310   /* This option should be used with caution. */                            \
1311   product(bool, StressLdcRewrite, false,                                    \
1312           "Force ldc -&gt; ldc_w rewrite during RedefineClasses")              \
1313                                                                             \
1314   product(intx, TraceRedefineClasses, 0,                                    \
1315           "Trace level for JVMTI RedefineClasses")                          \
1316                                                                             \
1317   develop(bool, StressMethodComparator, false,                              \
1318           "Run the MethodComparator on all loaded methods")                 \
1319                                                                             \
1320   /* change to false by default sometime after Mustang */                   \
1321   product(bool, VerifyMergedCPBytecodes, true,                              \
1322           "Verify bytecodes after RedefineClasses constant pool merging")   \
1323                                                                             \
1324   develop(bool, TraceJNIHandleAllocation, false,                            \
1325           "Trace allocation/deallocation of JNI handle blocks")             \
1326                                                                             \
1327   develop(bool, TraceThreadEvents, false,                                   \
1328           "Trace all thread events")                                        \
1329                                                                             \
1330   develop(bool, TraceBytecodes, false,                                      \
1331           "Trace bytecode execution")                                       \
1332                                                                             \
1333   develop(bool, TraceClassInitialization, false,                            \
1334           "Trace class initialization")                                     \
1335                                                                             \
1336   develop(bool, TraceExceptions, false,                                     \
1337           "Trace exceptions")                                               \
1338                                                                             \
1339   develop(bool, TraceICs, false,                                            \
1340           "Trace inline cache changes")                                     \
1341                                                                             \
1342   notproduct(bool, TraceInvocationCounterOverflow, false,                   \
1343           "Trace method invocation counter overflow")                       \
1344                                                                             \
1345   develop(bool, TraceInlineCacheClearing, false,                            \
1346           "Trace clearing of inline caches in nmethods")                    \
1347                                                                             \
1348   develop(bool, TraceDependencies, false,                                   \
1349           "Trace dependencies")                                             \
1350                                                                             \
1351   develop(bool, VerifyDependencies, trueInDebug,                            \
1352           "Exercise and verify the compilation dependency mechanism")       \
1353                                                                             \
1354   develop(bool, TraceNewOopMapGeneration, false,                            \
1355           "Trace OopMapGeneration")                                         \
1356                                                                             \
1357   develop(bool, TraceNewOopMapGenerationDetailed, false,                    \
1358           "Trace OopMapGeneration: print detailed cell states")             \
1359                                                                             \
1360   develop(bool, TimeOopMap, false,                                          \
1361           "Time calls to GenerateOopMap::compute_map() in sum")             \
1362                                                                             \
1363   develop(bool, TimeOopMap2, false,                                         \
1364           "Time calls to GenerateOopMap::compute_map() individually")       \
1365                                                                             \
1366   develop(bool, TraceMonitorMismatch, false,                                \
1367           "Trace monitor matching failures during OopMapGeneration")        \
1368                                                                             \
1369   develop(bool, TraceOopMapRewrites, false,                                 \
1370           "Trace rewriting of method oops during oop map generation")       \
1371                                                                             \
1372   develop(bool, TraceSafepoint, false,                                      \
1373           "Trace safepoint operations")                                     \
1374                                                                             \
1375   develop(bool, TraceICBuffer, false,                                       \
1376           "Trace usage of IC buffer")                                       \
1377                                                                             \
1378   develop(bool, TraceCompiledIC, false,                                     \
1379           "Trace changes of compiled IC")                                   \
1380                                                                             \
1381   notproduct(bool, TraceZapDeadLocals, false,                               \
1382           "Trace zapping dead locals")                                      \
1383                                                                             \
1384   develop(bool, TraceStartupTime, false,                                    \
1385           "Trace setup time")                                               \
1386                                                                             \
1387   develop(bool, TraceProtectionDomainVerification, false,                   \
1388           "Trace protection domain verification")                           \
1389                                                                             \
1390   develop(bool, TraceClearedExceptions, false,                              \
1391           "Print when an exception is forcibly cleared")                    \
1392                                                                             \
1393   product(bool, TraceClassResolution, false,                                \
1394           "Trace all constant pool resolutions (for debugging)")            \
1395                                                                             \
1396   product(bool, TraceBiasedLocking, false,                                  \
1397           "Trace biased locking in JVM")                                    \
1398                                                                             \
1399   product(bool, TraceMonitorInflation, false,                               \
1400           "Trace monitor inflation in JVM")                                 \
1401                                                                             \
1402   /* gc */                                                                  \
1403                                                                             \
1404   product(bool, UseSerialGC, false,                                         \
1405           "Use the Serial garbage collector")                               \
1406                                                                             \
1407   product(bool, UseG1GC, false,                                             \
1408           "Use the Garbage-First garbage collector")                        \
1409                                                                             \
1410   product(bool, UseParallelGC, false,                                       \
1411           "Use the Parallel Scavenge garbage collector")                    \
1412                                                                             \
1413   product(bool, UseParallelOldGC, false,                                    \
1414           "Use the Parallel Old garbage collector")                         \
1415                                                                             \
1416   product(uintx, HeapMaximumCompactionInterval, 20,                         \
1417           "How often should we maximally compact the heap (not allowing "   \
1418           "any dead space)")                                                \
1419                                                                             \
1420   product(uintx, HeapFirstMaximumCompactionCount, 3,                        \
1421           "The collection count for the first maximum compaction")          \
1422                                                                             \
1423   product(bool, UseMaximumCompactionOnSystemGC, true,                       \
1424           "Use maximum compaction in the Parallel Old garbage collector "   \
1425           "for a system GC")                                                \
1426                                                                             \
1427   product(uintx, ParallelOldDeadWoodLimiterMean, 50,                        \
1428           "The mean used by the parallel compact dead wood "                \
1429           "limiter (a number between 0-100)")                               \
1430                                                                             \
1431   product(uintx, ParallelOldDeadWoodLimiterStdDev, 80,                      \
1432           "The standard deviation used by the parallel compact dead wood "  \
1433           "limiter (a number between 0-100)")                               \
1434                                                                             \
1435   product(uintx, ParallelGCThreads, 0,                                      \
1436           "Number of parallel threads parallel gc will use")                \
1437                                                                             \
1438   product(bool, UseDynamicNumberOfGCThreads, false,                         \
1439           "Dynamically choose the number of parallel threads "              \
1440           "parallel gc will use")                                           \
1441                                                                             \
1442   diagnostic(bool, ForceDynamicNumberOfGCThreads, false,                    \
1443           "Force dynamic selection of the number of "                       \
1444           "parallel threads parallel gc will use to aid debugging")         \
1445                                                                             \
1446   product(uintx, HeapSizePerGCThread, ScaleForWordSize(64*M),               \
1447           "Size of heap (bytes) per GC thread used in calculating the "     \
1448           "number of GC threads")                                           \
1449                                                                             \
1450   product(bool, TraceDynamicGCThreads, false,                               \
1451           "Trace the dynamic GC thread usage")                              \
1452                                                                             \
1453   develop(bool, ParallelOldGCSplitALot, false,                              \
1454           "Provoke splitting (copying data from a young gen space to "      \
1455           "multiple destination spaces)")                                   \
1456                                                                             \
1457   develop(uintx, ParallelOldGCSplitInterval, 3,                             \
1458           "How often to provoke splitting a young gen space")               \
1459                                                                             \
1460   product(uintx, ConcGCThreads, 0,                                          \
1461           "Number of threads concurrent gc will use")                       \
1462                                                                             \
1463   product(uintx, YoungPLABSize, 4096,                                       \
1464           "Size of young gen promotion LAB's (in HeapWords)")               \
1465                                                                             \
1466   product(uintx, OldPLABSize, 1024,                                         \
1467           "Size of old gen promotion LAB's (in HeapWords)")                 \
1468                                                                             \
1469   product(uintx, GCTaskTimeStampEntries, 200,                               \
1470           "Number of time stamp entries per gc worker thread")              \
1471                                                                             \
1472   product(bool, AlwaysTenure, false,                                        \
1473           "Always tenure objects in eden (ParallelGC only)")                \
1474                                                                             \
1475   product(bool, NeverTenure, false,                                         \
1476           "Never tenure objects in eden, may tenure on overflow "           \
1477           "(ParallelGC only)")                                              \
1478                                                                             \
1479   product(bool, ScavengeBeforeFullGC, true,                                 \
1480           "Scavenge youngest generation before each full GC, "              \
1481           "used with UseParallelGC")                                        \
1482                                                                             \
1483   develop(bool, ScavengeWithObjectsInToSpace, false,                        \
1484           "Allow scavenges to occur when to-space contains objects")        \
1485                                                                             \
1486   product(bool, UseConcMarkSweepGC, false,                                  \
1487           "Use Concurrent Mark-Sweep GC in the old generation")             \
1488                                                                             \
1489   product(bool, ExplicitGCInvokesConcurrent, false,                         \
1490           "A System.gc() request invokes a concurrent collection; "         \
1491           "(effective only when UseConcMarkSweepGC)")                       \
1492                                                                             \
1493   product(bool, ExplicitGCInvokesConcurrentAndUnloadsClasses, false,        \
1494           "A System.gc() request invokes a concurrent collection and "      \
1495           "also unloads classes during such a concurrent gc cycle "         \
1496           "(effective only when UseConcMarkSweepGC)")                       \
1497                                                                             \
1498   product(bool, GCLockerInvokesConcurrent, false,                           \
1499           "The exit of a JNI critical section necessitating a scavenge, "   \
1500           "also kicks off a background concurrent collection")              \
1501                                                                             \
1502   product(uintx, GCLockerEdenExpansionPercent, 5,                           \
1503           "How much the GC can expand the eden by while the GC locker "     \
1504           "is active (as a percentage)")                                    \
1505                                                                             \
<a name="4" id="anc4"></a><span class="changed">1506   diagnostic(intx, GCLockerRetryAllocationCount, 2,                         \</span>
1507           "Number of times to retry allocations when "                      \
1508           "blocked by the GC locker")                                       \
1509                                                                             \
1510   develop(bool, UseCMSAdaptiveFreeLists, true,                              \
1511           "Use adaptive free lists in the CMS generation")                  \
1512                                                                             \
1513   develop(bool, UseAsyncConcMarkSweepGC, true,                              \
1514           "Use Asynchronous Concurrent Mark-Sweep GC in the old generation")\
1515                                                                             \
1516   develop(bool, RotateCMSCollectionTypes, false,                            \
1517           "Rotate the CMS collections among concurrent and STW")            \
1518                                                                             \
1519   product(bool, UseCMSBestFit, true,                                        \
1520           "Use CMS best fit allocation strategy")                           \
1521                                                                             \
1522   product(bool, UseCMSCollectionPassing, true,                              \
1523           "Use passing of collection from background to foreground")        \
1524                                                                             \
1525   product(bool, UseParNewGC, false,                                         \
1526           "Use parallel threads in the new generation")                     \
1527                                                                             \
1528   product(bool, ParallelGCVerbose, false,                                   \
1529           "Verbose output for parallel gc")                                 \
1530                                                                             \
1531   product(uintx, ParallelGCBufferWastePct, 10,                              \
1532           "Wasted fraction of parallel allocation buffer")                  \
1533                                                                             \
1534   diagnostic(bool, ParallelGCRetainPLAB, false,                             \
1535           "Retain parallel allocation buffers across scavenges; "           \
1536           "it is disabled because this currently conflicts with "           \
1537           "parallel card scanning under certain conditions.")               \
1538                                                                             \
1539   product(uintx, TargetPLABWastePct, 10,                                    \
1540           "Target wasted space in last buffer as percent of overall "       \
1541           "allocation")                                                     \
1542                                                                             \
1543   product(uintx, PLABWeight, 75,                                            \
1544           "Percentage (0-100) used to weigh the current sample when "       \
1545           "computing exponentially decaying average for ResizePLAB")        \
1546                                                                             \
1547   product(bool, ResizePLAB, true,                                           \
1548           "Dynamically resize (survivor space) promotion LAB's")            \
1549                                                                             \
1550   product(bool, PrintPLAB, false,                                           \
1551           "Print (survivor space) promotion LAB's sizing decisions")        \
1552                                                                             \
1553   product(intx, ParGCArrayScanChunk, 50,                                    \
1554           "Scan a subset of object array and push remainder, if array is "  \
1555           "bigger than this")                                               \
1556                                                                             \
1557   product(bool, ParGCUseLocalOverflow, false,                               \
1558           "Instead of a global overflow list, use local overflow stacks")   \
1559                                                                             \
1560   product(bool, ParGCTrimOverflow, true,                                    \
1561           "Eagerly trim the local overflow lists "                          \
1562           "(when ParGCUseLocalOverflow)")                                   \
1563                                                                             \
1564   notproduct(bool, ParGCWorkQueueOverflowALot, false,                       \
1565           "Simulate work queue overflow in ParNew")                         \
1566                                                                             \
1567   notproduct(uintx, ParGCWorkQueueOverflowInterval, 1000,                   \
1568           "An `interval' counter that determines how frequently "           \
1569           "we simulate overflow; a smaller number increases frequency")     \
1570                                                                             \
1571   product(uintx, ParGCDesiredObjsFromOverflowList, 20,                      \
1572           "The desired number of objects to claim from the overflow list")  \
1573                                                                             \
1574   diagnostic(uintx, ParGCStridesPerThread, 2,                               \
1575           "The number of strides per worker thread that we divide up the "  \
1576           "card table scanning work into")                                  \
1577                                                                             \
1578   diagnostic(intx, ParGCCardsPerStrideChunk, 256,                           \
1579           "The number of cards in each chunk of the parallel chunks used "  \
1580           "during card table scanning")                                     \
1581                                                                             \
1582   product(uintx, CMSParPromoteBlocksToClaim, 16,                            \
1583           "Number of blocks to attempt to claim when refilling CMS LAB's "  \
1584           "for parallel GC")                                                \
1585                                                                             \
1586   product(uintx, OldPLABWeight, 50,                                         \
1587           "Percentage (0-100) used to weight the current sample when "      \
1588           "computing exponentially decaying average for resizing "          \
1589           "CMSParPromoteBlocksToClaim")                                     \
1590                                                                             \
1591   product(bool, ResizeOldPLAB, true,                                        \
1592           "Dynamically resize (old gen) promotion LAB's")                   \
1593                                                                             \
1594   product(bool, PrintOldPLAB, false,                                        \
1595           "Print (old gen) promotion LAB's sizing decisions")               \
1596                                                                             \
1597   product(uintx, CMSOldPLABMin, 16,                                         \
1598           "Minimum size of CMS gen promotion LAB caches per worker "        \
1599           "per block size")                                                 \
1600                                                                             \
1601   product(uintx, CMSOldPLABMax, 1024,                                       \
1602           "Maximum size of CMS gen promotion LAB caches per worker "        \
1603           "per block size")                                                 \
1604                                                                             \
1605   product(uintx, CMSOldPLABNumRefills, 4,                                   \
1606           "Nominal number of refills of CMS gen promotion LAB cache "       \
1607           "per worker per block size")                                      \
1608                                                                             \
1609   product(bool, CMSOldPLABResizeQuicker, false,                             \
1610           "React on-the-fly during a scavenge to a sudden "                 \
1611           "change in block demand rate")                                    \
1612                                                                             \
1613   product(uintx, CMSOldPLABToleranceFactor, 4,                              \
1614           "The tolerance of the phase-change detector for on-the-fly "      \
1615           "PLAB resizing during a scavenge")                                \
1616                                                                             \
1617   product(uintx, CMSOldPLABReactivityFactor, 2,                             \
1618           "The gain in the feedback loop for on-the-fly PLAB resizing "     \
1619           "during a scavenge")                                              \
1620                                                                             \
1621   product(bool, AlwaysPreTouch, false,                                      \
1622           "Force all freshly committed pages to be pre-touched")            \
1623                                                                             \
1624   product_pd(uintx, CMSYoungGenPerWorker,                                   \
1625           "The maximum size of young gen chosen by default per GC worker "  \
1626           "thread available")                                               \
1627                                                                             \
1628   product(bool, CMSIncrementalMode, false,                                  \
1629           "Whether CMS GC should operate in \"incremental\" mode")          \
1630                                                                             \
1631   product(uintx, CMSIncrementalDutyCycle, 10,                               \
1632           "Percentage (0-100) of CMS incremental mode duty cycle. If "      \
1633           "CMSIncrementalPacing is enabled, then this is just the initial " \
1634           "value.")                                                         \
1635                                                                             \
1636   product(bool, CMSIncrementalPacing, true,                                 \
1637           "Whether the CMS incremental mode duty cycle should be "          \
1638           "automatically adjusted")                                         \
1639                                                                             \
1640   product(uintx, CMSIncrementalDutyCycleMin, 0,                             \
1641           "Minimum percentage (0-100) of the CMS incremental duty cycle "   \
1642           "used when CMSIncrementalPacing is enabled")                      \
1643                                                                             \
1644   product(uintx, CMSIncrementalSafetyFactor, 10,                            \
1645           "Percentage (0-100) used to add conservatism when computing the " \
1646           "duty cycle")                                                     \
1647                                                                             \
1648   product(uintx, CMSIncrementalOffset, 0,                                   \
1649           "Percentage (0-100) by which the CMS incremental mode duty cycle "\
1650           "is shifted to the right within the period between young GCs")    \
1651                                                                             \
1652   product(uintx, CMSExpAvgFactor, 50,                                       \
1653           "Percentage (0-100) used to weigh the current sample when "       \
1654           "computing exponential averages for CMS statistics")              \
1655                                                                             \
1656   product(uintx, CMS_FLSWeight, 75,                                         \
1657           "Percentage (0-100) used to weigh the current sample when "       \
1658           "computing exponentially decaying averages for CMS FLS "          \
1659           "statistics")                                                     \
1660                                                                             \
1661   product(uintx, CMS_FLSPadding, 1,                                         \
1662           "The multiple of deviation from mean to use for buffering "       \
1663           "against volatility in free list demand")                         \
1664                                                                             \
1665   product(uintx, FLSCoalescePolicy, 2,                                      \
1666           "CMS: aggressiveness level for coalescing, increasing "           \
1667           "from 0 to 4")                                                    \
1668                                                                             \
1669   product(bool, FLSAlwaysCoalesceLarge, false,                              \
1670           "CMS: larger free blocks are always available for coalescing")    \
1671                                                                             \
1672   product(double, FLSLargestBlockCoalesceProximity, 0.99,                   \
1673           "CMS: the smaller the percentage the greater the coalescing "     \
1674           "force")                                                          \
1675                                                                             \
1676   product(double, CMSSmallCoalSurplusPercent, 1.05,                         \
1677           "CMS: the factor by which to inflate estimated demand of small "  \
1678           "block sizes to prevent coalescing with an adjoining block")      \
1679                                                                             \
1680   product(double, CMSLargeCoalSurplusPercent, 0.95,                         \
1681           "CMS: the factor by which to inflate estimated demand of large "  \
1682           "block sizes to prevent coalescing with an adjoining block")      \
1683                                                                             \
1684   product(double, CMSSmallSplitSurplusPercent, 1.10,                        \
1685           "CMS: the factor by which to inflate estimated demand of small "  \
1686           "block sizes to prevent splitting to supply demand for smaller "  \
1687           "blocks")                                                         \
1688                                                                             \
1689   product(double, CMSLargeSplitSurplusPercent, 1.00,                        \
1690           "CMS: the factor by which to inflate estimated demand of large "  \
1691           "block sizes to prevent splitting to supply demand for smaller "  \
1692           "blocks")                                                         \
1693                                                                             \
1694   product(bool, CMSExtrapolateSweep, false,                                 \
1695           "CMS: cushion for block demand during sweep")                     \
1696                                                                             \
1697   product(uintx, CMS_SweepWeight, 75,                                       \
1698           "Percentage (0-100) used to weight the current sample when "      \
1699           "computing exponentially decaying average for inter-sweep "       \
1700           "duration")                                                       \
1701                                                                             \
1702   product(uintx, CMS_SweepPadding, 1,                                       \
1703           "The multiple of deviation from mean to use for buffering "       \
1704           "against volatility in inter-sweep duration")                     \
1705                                                                             \
1706   product(uintx, CMS_SweepTimerThresholdMillis, 10,                         \
1707           "Skip block flux-rate sampling for an epoch unless inter-sweep "  \
1708           "duration exceeds this threshold in milliseconds")                \
1709                                                                             \
1710   develop(bool, CMSTraceIncrementalMode, false,                             \
1711           "Trace CMS incremental mode")                                     \
1712                                                                             \
1713   develop(bool, CMSTraceIncrementalPacing, false,                           \
1714           "Trace CMS incremental mode pacing computation")                  \
1715                                                                             \
1716   develop(bool, CMSTraceThreadState, false,                                 \
1717           "Trace the CMS thread state (enable the trace_state() method)")   \
1718                                                                             \
1719   product(bool, CMSClassUnloadingEnabled, true,                             \
1720           "Whether class unloading enabled when using CMS GC")              \
1721                                                                             \
1722   product(uintx, CMSClassUnloadingMaxInterval, 0,                           \
1723           "When CMS class unloading is enabled, the maximum CMS cycle "     \
1724           "count for which classes may not be unloaded")                    \
1725                                                                             \
1726   product(bool, CMSCompactWhenClearAllSoftRefs, true,                       \
1727           "Compact when asked to collect CMS gen with "                     \
1728           "clear_all_soft_refs()")                                          \
1729                                                                             \
1730   product(bool, UseCMSCompactAtFullCollection, true,                        \
1731           "Use Mark-Sweep-Compact algorithm at full collections")           \
1732                                                                             \
1733   product(uintx, CMSFullGCsBeforeCompaction, 0,                             \
1734           "Number of CMS full collection done before compaction if &gt; 0")    \
1735                                                                             \
1736   develop(intx, CMSDictionaryChoice, 0,                                     \
1737           "Use BinaryTreeDictionary as default in the CMS generation")      \
1738                                                                             \
1739   product(uintx, CMSIndexedFreeListReplenish, 4,                            \
1740           "Replenish an indexed free list with this number of chunks")      \
1741                                                                             \
1742   product(bool, CMSReplenishIntermediate, true,                             \
1743           "Replenish all intermediate free-list caches")                    \
1744                                                                             \
1745   product(bool, CMSSplitIndexedFreeListBlocks, true,                        \
1746           "When satisfying batched demand, split blocks from the "          \
1747           "IndexedFreeList whose size is a multiple of requested size")     \
1748                                                                             \
1749   product(bool, CMSLoopWarn, false,                                         \
1750           "Warn in case of excessive CMS looping")                          \
1751                                                                             \
1752   develop(bool, CMSOverflowEarlyRestoration, false,                         \
1753           "Restore preserved marks early")                                  \
1754                                                                             \
1755   product(uintx, MarkStackSize, NOT_LP64(32*K) LP64_ONLY(4*M),              \
1756           "Size of marking stack")                                          \
1757                                                                             \
1758   product(uintx, MarkStackSizeMax, NOT_LP64(4*M) LP64_ONLY(512*M),          \
1759           "Maximum size of marking stack")                                  \
1760                                                                             \
1761   notproduct(bool, CMSMarkStackOverflowALot, false,                         \
1762           "Simulate frequent marking stack / work queue overflow")          \
1763                                                                             \
1764   notproduct(uintx, CMSMarkStackOverflowInterval, 1000,                     \
1765           "An \"interval\" counter that determines how frequently "         \
1766           "to simulate overflow; a smaller number increases frequency")     \
1767                                                                             \
1768   product(uintx, CMSMaxAbortablePrecleanLoops, 0,                           \
1769           "(Temporary, subject to experimentation) "                        \
1770           "Maximum number of abortable preclean iterations, if &gt; 0")        \
1771                                                                             \
1772   product(intx, CMSMaxAbortablePrecleanTime, 5000,                          \
1773           "(Temporary, subject to experimentation) "                        \
1774           "Maximum time in abortable preclean (in milliseconds)")           \
1775                                                                             \
1776   product(uintx, CMSAbortablePrecleanMinWorkPerIteration, 100,              \
1777           "(Temporary, subject to experimentation) "                        \
1778           "Nominal minimum work per abortable preclean iteration")          \
1779                                                                             \
1780   manageable(intx, CMSAbortablePrecleanWaitMillis, 100,                     \
1781           "(Temporary, subject to experimentation) "                        \
1782           "Time that we sleep between iterations when not given "           \
1783           "enough work per iteration")                                      \
1784                                                                             \
1785   product(uintx, CMSRescanMultiple, 32,                                     \
1786           "Size (in cards) of CMS parallel rescan task")                    \
1787                                                                             \
1788   product(uintx, CMSConcMarkMultiple, 32,                                   \
1789           "Size (in cards) of CMS concurrent MT marking task")              \
1790                                                                             \
1791   product(bool, CMSAbortSemantics, false,                                   \
1792           "Whether abort-on-overflow semantics is implemented")             \
1793                                                                             \
1794   product(bool, CMSParallelInitialMarkEnabled, true,                        \
1795           "Use the parallel initial mark.")                                 \
1796                                                                             \
1797   product(bool, CMSParallelRemarkEnabled, true,                             \
1798           "Whether parallel remark enabled (only if ParNewGC)")             \
1799                                                                             \
1800   product(bool, CMSParallelSurvivorRemarkEnabled, true,                     \
1801           "Whether parallel remark of survivor space "                      \
1802           "enabled (effective only if CMSParallelRemarkEnabled)")           \
1803                                                                             \
1804   product(bool, CMSPLABRecordAlways, true,                                  \
1805           "Always record survivor space PLAB boundaries (effective only "   \
1806           "if CMSParallelSurvivorRemarkEnabled)")                           \
1807                                                                             \
1808   product(bool, CMSEdenChunksRecordAlways, true,                            \
1809           "Always record eden chunks used for the parallel initial mark "   \
1810           "or remark of eden")                                              \
1811                                                                             \
1812   product(bool, CMSPrintEdenSurvivorChunks, false,                          \
1813           "Print the eden and the survivor chunks used for the parallel "   \
1814           "initial mark or remark of the eden/survivor spaces")             \
1815                                                                             \
1816   product(bool, CMSConcurrentMTEnabled, true,                               \
1817           "Whether multi-threaded concurrent work enabled "                 \
1818           "(effective only if ParNewGC)")                                   \
1819                                                                             \
1820   product(bool, CMSPrecleaningEnabled, true,                                \
1821           "Whether concurrent precleaning enabled")                         \
1822                                                                             \
1823   product(uintx, CMSPrecleanIter, 3,                                        \
1824           "Maximum number of precleaning iteration passes")                 \
1825                                                                             \
1826   product(uintx, CMSPrecleanNumerator, 2,                                   \
1827           "CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence " \
1828           "ratio")                                                          \
1829                                                                             \
1830   product(uintx, CMSPrecleanDenominator, 3,                                 \
1831           "CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence " \
1832           "ratio")                                                          \
1833                                                                             \
1834   product(bool, CMSPrecleanRefLists1, true,                                 \
1835           "Preclean ref lists during (initial) preclean phase")             \
1836                                                                             \
1837   product(bool, CMSPrecleanRefLists2, false,                                \
1838           "Preclean ref lists during abortable preclean phase")             \
1839                                                                             \
1840   product(bool, CMSPrecleanSurvivors1, false,                               \
1841           "Preclean survivors during (initial) preclean phase")             \
1842                                                                             \
1843   product(bool, CMSPrecleanSurvivors2, true,                                \
1844           "Preclean survivors during abortable preclean phase")             \
1845                                                                             \
1846   product(uintx, CMSPrecleanThreshold, 1000,                                \
1847           "Do not iterate again if number of dirty cards is less than this")\
1848                                                                             \
1849   product(bool, CMSCleanOnEnter, true,                                      \
1850           "Clean-on-enter optimization for reducing number of dirty cards") \
1851                                                                             \
1852   product(uintx, CMSRemarkVerifyVariant, 1,                                 \
1853           "Choose variant (1,2) of verification following remark")          \
1854                                                                             \
1855   product(uintx, CMSScheduleRemarkEdenSizeThreshold, 2*M,                   \
1856           "If Eden size is below this, do not try to schedule remark")      \
1857                                                                             \
1858   product(uintx, CMSScheduleRemarkEdenPenetration, 50,                      \
1859           "The Eden occupancy percentage (0-100) at which "                 \
1860           "to try and schedule remark pause")                               \
1861                                                                             \
1862   product(uintx, CMSScheduleRemarkSamplingRatio, 5,                         \
1863           "Start sampling eden top at least before young gen "              \
1864           "occupancy reaches 1/&lt;ratio&gt; of the size at which "               \
1865           "we plan to schedule remark")                                     \
1866                                                                             \
1867   product(uintx, CMSSamplingGrain, 16*K,                                    \
1868           "The minimum distance between eden samples for CMS (see above)")  \
1869                                                                             \
1870   product(bool, CMSScavengeBeforeRemark, false,                             \
1871           "Attempt scavenge before the CMS remark step")                    \
1872                                                                             \
1873   develop(bool, CMSTraceSweeper, false,                                     \
1874           "Trace some actions of the CMS sweeper")                          \
1875                                                                             \
1876   product(uintx, CMSWorkQueueDrainThreshold, 10,                            \
1877           "Don't drain below this size per parallel worker/thief")          \
1878                                                                             \
1879   manageable(intx, CMSWaitDuration, 2000,                                   \
1880           "Time in milliseconds that CMS thread waits for young GC")        \
1881                                                                             \
1882   develop(uintx, CMSCheckInterval, 1000,                                    \
1883           "Interval in milliseconds that CMS thread checks if it "          \
1884           "should start a collection cycle")                                \
1885                                                                             \
1886   product(bool, CMSYield, true,                                             \
1887           "Yield between steps of CMS")                                     \
1888                                                                             \
1889   product(uintx, CMSBitMapYieldQuantum, 10*M,                               \
1890           "Bitmap operations should process at most this many bits "        \
1891           "between yields")                                                 \
1892                                                                             \
1893   product(bool, CMSDumpAtPromotionFailure, false,                           \
1894           "Dump useful information about the state of the CMS old "         \
1895           "generation upon a promotion failure")                            \
1896                                                                             \
1897   product(bool, CMSPrintChunksInDump, false,                                \
1898           "In a dump enabled by CMSDumpAtPromotionFailure, include "        \
1899           "more detailed information about the free chunks")                \
1900                                                                             \
1901   product(bool, CMSPrintObjectsInDump, false,                               \
1902           "In a dump enabled by CMSDumpAtPromotionFailure, include "        \
1903           "more detailed information about the allocated objects")          \
1904                                                                             \
1905   diagnostic(bool, FLSVerifyAllHeapReferences, false,                       \
1906           "Verify that all references across the FLS boundary "             \
1907           "are to valid objects")                                           \
1908                                                                             \
1909   diagnostic(bool, FLSVerifyLists, false,                                   \
1910           "Do lots of (expensive) FreeListSpace verification")              \
1911                                                                             \
1912   diagnostic(bool, FLSVerifyIndexTable, false,                              \
1913           "Do lots of (expensive) FLS index table verification")            \
1914                                                                             \
1915   develop(bool, FLSVerifyDictionary, false,                                 \
1916           "Do lots of (expensive) FLS dictionary verification")             \
1917                                                                             \
1918   develop(bool, VerifyBlockOffsetArray, false,                              \
1919           "Do (expensive) block offset array verification")                 \
1920                                                                             \
1921   diagnostic(bool, BlockOffsetArrayUseUnallocatedBlock, false,              \
1922           "Maintain _unallocated_block in BlockOffsetArray "                \
1923           "(currently applicable only to CMS collector)")                   \
1924                                                                             \
1925   develop(bool, TraceCMSState, false,                                       \
1926           "Trace the state of the CMS collection")                          \
1927                                                                             \
1928   product(intx, RefDiscoveryPolicy, 0,                                      \
1929           "Select type of reference discovery policy: "                     \
1930           "reference-based(0) or referent-based(1)")                        \
1931                                                                             \
1932   product(bool, ParallelRefProcEnabled, false,                              \
1933           "Enable parallel reference processing whenever possible")         \
1934                                                                             \
1935   product(bool, ParallelRefProcBalancingEnabled, true,                      \
1936           "Enable balancing of reference processing queues")                \
1937                                                                             \
1938   product(uintx, CMSTriggerRatio, 80,                                       \
1939           "Percentage of MinHeapFreeRatio in CMS generation that is "       \
1940           "allocated before a CMS collection cycle commences")              \
1941                                                                             \
1942   product(uintx, CMSBootstrapOccupancy, 50,                                 \
1943           "Percentage CMS generation occupancy at which to "                \
1944           "initiate CMS collection for bootstrapping collection stats")     \
1945                                                                             \
1946   product(intx, CMSInitiatingOccupancyFraction, -1,                         \
1947           "Percentage CMS generation occupancy to start a CMS collection "  \
1948           "cycle. A negative value means that CMSTriggerRatio is used")     \
1949                                                                             \
1950   product(uintx, InitiatingHeapOccupancyPercent, 45,                        \
1951           "Percentage of the (entire) heap occupancy to start a "           \
1952           "concurrent GC cycle. It is used by GCs that trigger a "          \
1953           "concurrent GC cycle based on the occupancy of the entire heap, " \
1954           "not just one of the generations (e.g., G1). A value of 0 "       \
1955           "denotes 'do constant GC cycles'.")                               \
1956                                                                             \
1957   manageable(intx, CMSTriggerInterval, -1,                                  \
1958           "Commence a CMS collection cycle (at least) every so many "       \
1959           "milliseconds (0 permanently, -1 disabled)")                      \
1960                                                                             \
1961   product(bool, UseCMSInitiatingOccupancyOnly, false,                       \
1962           "Only use occupancy as a criterion for starting a CMS collection")\
1963                                                                             \
1964   product(uintx, CMSIsTooFullPercentage, 98,                                \
1965           "An absolute ceiling above which CMS will always consider the "   \
1966           "unloading of classes when class unloading is enabled")           \
1967                                                                             \
1968   develop(bool, CMSTestInFreeList, false,                                   \
1969           "Check if the coalesced range is already in the "                 \
1970           "free lists as claimed")                                          \
1971                                                                             \
1972   notproduct(bool, CMSVerifyReturnedBytes, false,                           \
1973           "Check that all the garbage collected was returned to the "       \
1974           "free lists")                                                     \
1975                                                                             \
1976   notproduct(bool, ScavengeALot, false,                                     \
1977           "Force scavenge at every Nth exit from the runtime system "       \
1978           "(N=ScavengeALotInterval)")                                       \
1979                                                                             \
1980   develop(bool, FullGCALot, false,                                          \
1981           "Force full gc at every Nth exit from the runtime system "        \
1982           "(N=FullGCALotInterval)")                                         \
1983                                                                             \
1984   notproduct(bool, GCALotAtAllSafepoints, false,                            \
1985           "Enforce ScavengeALot/GCALot at all potential safepoints")        \
1986                                                                             \
1987   product(bool, PrintPromotionFailure, false,                               \
1988           "Print additional diagnostic information following "              \
1989           "promotion failure")                                              \
1990                                                                             \
1991   notproduct(bool, PromotionFailureALot, false,                             \
1992           "Use promotion failure handling on every youngest generation "    \
1993           "collection")                                                     \
1994                                                                             \
1995   develop(uintx, PromotionFailureALotCount, 1000,                           \
1996           "Number of promotion failures occurring at ParGCAllocBuffer "     \
1997           "refill attempts (ParNew) or promotion attempts "                 \
1998           "(other young collectors)")                                       \
1999                                                                             \
2000   develop(uintx, PromotionFailureALotInterval, 5,                           \
2001           "Total collections between promotion failures alot")              \
2002                                                                             \
2003   experimental(uintx, WorkStealingSleepMillis, 1,                           \
2004           "Sleep time when sleep is used for yields")                       \
2005                                                                             \
2006   experimental(uintx, WorkStealingYieldsBeforeSleep, 5000,                  \
2007           "Number of yields before a sleep is done during workstealing")    \
2008                                                                             \
2009   experimental(uintx, WorkStealingHardSpins, 4096,                          \
2010           "Number of iterations in a spin loop between checks on "          \
2011           "time out of hard spin")                                          \
2012                                                                             \
2013   experimental(uintx, WorkStealingSpinToYieldRatio, 10,                     \
2014           "Ratio of hard spins to calls to yield")                          \
2015                                                                             \
2016   develop(uintx, ObjArrayMarkingStride, 512,                                \
2017           "Number of object array elements to push onto the marking stack " \
2018           "before pushing a continuation entry")                            \
2019                                                                             \
2020   develop(bool, MetadataAllocationFailALot, false,                          \
2021           "Fail metadata allocations at intervals controlled by "           \
2022           "MetadataAllocationFailALotInterval")                             \
2023                                                                             \
2024   develop(uintx, MetadataAllocationFailALotInterval, 1000,                  \
2025           "Metadata allocation failure a lot interval")                     \
2026                                                                             \
2027   develop(bool, TraceMetadataChunkAllocation, false,                        \
2028           "Trace chunk metadata allocations")                               \
2029                                                                             \
2030   product(bool, TraceMetadataHumongousAllocation, false,                    \
2031           "Trace humongous metadata allocations")                           \
2032                                                                             \
2033   develop(bool, TraceMetavirtualspaceAllocation, false,                     \
2034           "Trace virtual space metadata allocations")                       \
2035                                                                             \
2036   notproduct(bool, ExecuteInternalVMTests, false,                           \
2037           "Enable execution of internal VM tests")                          \
2038                                                                             \
2039   notproduct(bool, VerboseInternalVMTests, false,                           \
2040           "Turn on logging for internal VM tests.")                         \
2041                                                                             \
2042   product_pd(bool, UseTLAB, "Use thread-local object allocation")           \
2043                                                                             \
2044   product_pd(bool, ResizeTLAB,                                              \
2045           "Dynamically resize TLAB size for threads")                       \
2046                                                                             \
2047   product(bool, ZeroTLAB, false,                                            \
2048           "Zero out the newly created TLAB")                                \
2049                                                                             \
2050   product(bool, FastTLABRefill, true,                                       \
2051           "Use fast TLAB refill code")                                      \
2052                                                                             \
2053   product(bool, PrintTLAB, false,                                           \
2054           "Print various TLAB related information")                         \
2055                                                                             \
2056   product(bool, TLABStats, true,                                            \
2057           "Provide more detailed and expensive TLAB statistics "            \
2058           "(with PrintTLAB)")                                               \
2059                                                                             \
<a name="5" id="anc5"></a><span class="new">2060   EMBEDDED_ONLY(product(bool, LowMemoryProtection, true,                    \</span>
<span class="new">2061           "Enable LowMemoryProtection"))                                    \</span>
<span class="new">2062                                                                             \</span>
2063   product_pd(bool, NeverActAsServerClassMachine,                            \
2064           "Never act like a server-class machine")                          \
2065                                                                             \
2066   product(bool, AlwaysActAsServerClassMachine, false,                       \
2067           "Always act like a server-class machine")                         \
2068                                                                             \
2069   product_pd(uint64_t, MaxRAM,                                              \
2070           "Real memory size (in bytes) used to set maximum heap size")      \
2071                                                                             \
2072   product(uintx, ErgoHeapSizeLimit, 0,                                      \
2073           "Maximum ergonomically set heap size (in bytes); zero means use " \
2074           "MaxRAM / MaxRAMFraction")                                        \
2075                                                                             \
2076   product(uintx, MaxRAMFraction, 4,                                         \
2077           "Maximum fraction (1/n) of real memory used for maximum heap "    \
2078           "size")                                                           \
2079                                                                             \
2080   product(uintx, DefaultMaxRAMFraction, 4,                                  \
2081           "Maximum fraction (1/n) of real memory used for maximum heap "    \
2082           "size; deprecated: to be renamed to MaxRAMFraction")              \
2083                                                                             \
2084   product(uintx, MinRAMFraction, 2,                                         \
2085           "Minimum fraction (1/n) of real memory used for maxmimum heap "   \
2086           "size on systems with small physical memory size")                \
2087                                                                             \
2088   product(uintx, InitialRAMFraction, 64,                                    \
2089           "Fraction (1/n) of real memory used for initial heap size")       \
2090                                                                             \
2091   develop(uintx, MaxVirtMemFraction, 2,                                     \
2092           "Maximum fraction (1/n) of virtual memory used for ergonomically "\
2093           "determining maximum heap size")                                  \
2094                                                                             \
2095   product(bool, UseAutoGCSelectPolicy, false,                               \
2096           "Use automatic collection selection policy")                      \
2097                                                                             \
2098   product(uintx, AutoGCSelectPauseMillis, 5000,                             \
2099           "Automatic GC selection pause threshold in milliseconds")         \
2100                                                                             \
2101   product(bool, UseAdaptiveSizePolicy, true,                                \
2102           "Use adaptive generation sizing policies")                        \
2103                                                                             \
2104   product(bool, UsePSAdaptiveSurvivorSizePolicy, true,                      \
2105           "Use adaptive survivor sizing policies")                          \
2106                                                                             \
2107   product(bool, UseAdaptiveGenerationSizePolicyAtMinorCollection, true,     \
2108           "Use adaptive young-old sizing policies at minor collections")    \
2109                                                                             \
2110   product(bool, UseAdaptiveGenerationSizePolicyAtMajorCollection, true,     \
2111           "Use adaptive young-old sizing policies at major collections")    \
2112                                                                             \
2113   product(bool, UseAdaptiveSizePolicyWithSystemGC, false,                   \
2114           "Include statistics from System.gc() for adaptive size policy")   \
2115                                                                             \
2116   product(bool, UseAdaptiveGCBoundary, false,                               \
2117           "Allow young-old boundary to move")                               \
2118                                                                             \
2119   develop(bool, TraceAdaptiveGCBoundary, false,                             \
2120           "Trace young-old boundary moves")                                 \
2121                                                                             \
2122   develop(intx, PSAdaptiveSizePolicyResizeVirtualSpaceAlot, -1,             \
2123           "Resize the virtual spaces of the young or old generations")      \
2124                                                                             \
2125   product(uintx, AdaptiveSizeThroughPutPolicy, 0,                           \
2126           "Policy for changing generation size for throughput goals")       \
2127                                                                             \
2128   product(uintx, AdaptiveSizePausePolicy, 0,                                \
2129           "Policy for changing generation size for pause goals")            \
2130                                                                             \
2131   develop(bool, PSAdjustTenuredGenForMinorPause, false,                     \
2132           "Adjust tenured generation to achieve a minor pause goal")        \
2133                                                                             \
2134   develop(bool, PSAdjustYoungGenForMajorPause, false,                       \
2135           "Adjust young generation to achieve a major pause goal")          \
2136                                                                             \
2137   product(uintx, AdaptiveSizePolicyInitializingSteps, 20,                   \
2138           "Number of steps where heuristics is used before data is used")   \
2139                                                                             \
2140   develop(uintx, AdaptiveSizePolicyReadyThreshold, 5,                       \
2141           "Number of collections before the adaptive sizing is started")    \
2142                                                                             \
2143   product(uintx, AdaptiveSizePolicyOutputInterval, 0,                       \
2144           "Collection interval for printing information; zero means never") \
2145                                                                             \
2146   product(bool, UseAdaptiveSizePolicyFootprintGoal, true,                   \
2147           "Use adaptive minimum footprint as a goal")                       \
2148                                                                             \
2149   product(uintx, AdaptiveSizePolicyWeight, 10,                              \
2150           "Weight given to exponential resizing, between 0 and 100")        \
2151                                                                             \
2152   product(uintx, AdaptiveTimeWeight,       25,                              \
2153           "Weight given to time in adaptive policy, between 0 and 100")     \
2154                                                                             \
2155   product(uintx, PausePadding, 1,                                           \
2156           "How much buffer to keep for pause time")                         \
2157                                                                             \
2158   product(uintx, PromotedPadding, 3,                                        \
2159           "How much buffer to keep for promotion failure")                  \
2160                                                                             \
2161   product(uintx, SurvivorPadding, 3,                                        \
2162           "How much buffer to keep for survivor overflow")                  \
2163                                                                             \
2164   product(uintx, ThresholdTolerance, 10,                                    \
2165           "Allowed collection cost difference between generations")         \
2166                                                                             \
2167   product(uintx, AdaptiveSizePolicyCollectionCostMargin, 50,                \
2168           "If collection costs are within margin, reduce both by full "     \
2169           "delta")                                                          \
2170                                                                             \
2171   product(uintx, YoungGenerationSizeIncrement, 20,                          \
2172           "Adaptive size percentage change in young generation")            \
2173                                                                             \
2174   product(uintx, YoungGenerationSizeSupplement, 80,                         \
2175           "Supplement to YoungedGenerationSizeIncrement used at startup")   \
2176                                                                             \
2177   product(uintx, YoungGenerationSizeSupplementDecay, 8,                     \
2178           "Decay factor to YoungedGenerationSizeSupplement")                \
2179                                                                             \
2180   product(uintx, TenuredGenerationSizeIncrement, 20,                        \
2181           "Adaptive size percentage change in tenured generation")          \
2182                                                                             \
2183   product(uintx, TenuredGenerationSizeSupplement, 80,                       \
2184           "Supplement to TenuredGenerationSizeIncrement used at startup")   \
2185                                                                             \
2186   product(uintx, TenuredGenerationSizeSupplementDecay, 2,                   \
2187           "Decay factor to TenuredGenerationSizeIncrement")                 \
2188                                                                             \
2189   product(uintx, MaxGCPauseMillis, max_uintx,                               \
2190           "Adaptive size policy maximum GC pause time goal in millisecond, "\
2191           "or (G1 Only) the maximum GC time per MMU time slice")            \
2192                                                                             \
2193   product(uintx, GCPauseIntervalMillis, 0,                                  \
2194           "Time slice for MMU specification")                               \
2195                                                                             \
2196   product(uintx, MaxGCMinorPauseMillis, max_uintx,                          \
2197           "Adaptive size policy maximum GC minor pause time goal "          \
2198           "in millisecond")                                                 \
2199                                                                             \
2200   product(uintx, GCTimeRatio, 99,                                           \
2201           "Adaptive size policy application time to GC time ratio")         \
2202                                                                             \
2203   product(uintx, AdaptiveSizeDecrementScaleFactor, 4,                       \
2204           "Adaptive size scale down factor for shrinking")                  \
2205                                                                             \
2206   product(bool, UseAdaptiveSizeDecayMajorGCCost, true,                      \
2207           "Adaptive size decays the major cost for long major intervals")   \
2208                                                                             \
2209   product(uintx, AdaptiveSizeMajorGCDecayTimeScale, 10,                     \
2210           "Time scale over which major costs decay")                        \
2211                                                                             \
2212   product(uintx, MinSurvivorRatio, 3,                                       \
2213           "Minimum ratio of young generation/survivor space size")          \
2214                                                                             \
2215   product(uintx, InitialSurvivorRatio, 8,                                   \
2216           "Initial ratio of young generation/survivor space size")          \
2217                                                                             \
2218   product(uintx, BaseFootPrintEstimate, 256*M,                              \
2219           "Estimate of footprint other than Java Heap")                     \
2220                                                                             \
2221   product(bool, UseGCOverheadLimit, true,                                   \
2222           "Use policy to limit of proportion of time spent in GC "          \
2223           "before an OutOfMemory error is thrown")                          \
2224                                                                             \
2225   product(uintx, GCTimeLimit, 98,                                           \
2226           "Limit of the proportion of time spent in GC before "             \
2227           "an OutOfMemoryError is thrown (used with GCHeapFreeLimit)")      \
2228                                                                             \
2229   product(uintx, GCHeapFreeLimit, 2,                                        \
2230           "Minimum percentage of free space after a full GC before an "     \
2231           "OutOfMemoryError is thrown (used with GCTimeLimit)")             \
2232                                                                             \
2233   develop(uintx, AdaptiveSizePolicyGCTimeLimitThreshold, 5,                 \
2234           "Number of consecutive collections before gc time limit fires")   \
2235                                                                             \
2236   product(bool, PrintAdaptiveSizePolicy, false,                             \
2237           "Print information about AdaptiveSizePolicy")                     \
2238                                                                             \
2239   product(intx, PrefetchCopyIntervalInBytes, -1,                            \
2240           "How far ahead to prefetch destination area (&lt;= 0 means off)")    \
2241                                                                             \
2242   product(intx, PrefetchScanIntervalInBytes, -1,                            \
2243           "How far ahead to prefetch scan area (&lt;= 0 means off)")           \
2244                                                                             \
2245   product(intx, PrefetchFieldsAhead, -1,                                    \
2246           "How many fields ahead to prefetch in oop scan (&lt;= 0 means off)") \
2247                                                                             \
2248   diagnostic(bool, VerifySilently, false,                                   \
2249           "Do not print the verification progress")                         \
2250                                                                             \
2251   diagnostic(bool, VerifyDuringStartup, false,                              \
2252           "Verify memory system before executing any Java code "            \
2253           "during VM initialization")                                       \
2254                                                                             \
2255   diagnostic(bool, VerifyBeforeExit, trueInDebug,                           \
2256           "Verify system before exiting")                                   \
2257                                                                             \
2258   diagnostic(bool, VerifyBeforeGC, false,                                   \
2259           "Verify memory system before GC")                                 \
2260                                                                             \
2261   diagnostic(bool, VerifyAfterGC, false,                                    \
2262           "Verify memory system after GC")                                  \
2263                                                                             \
2264   diagnostic(bool, VerifyDuringGC, false,                                   \
2265           "Verify memory system during GC (between phases)")                \
2266                                                                             \
2267   diagnostic(bool, GCParallelVerificationEnabled, true,                     \
2268           "Enable parallel memory system verification")                     \
2269                                                                             \
2270   diagnostic(bool, DeferInitialCardMark, false,                             \
2271           "When +ReduceInitialCardMarks, explicitly defer any that "        \
2272           "may arise from new_pre_store_barrier")                           \
2273                                                                             \
2274   diagnostic(bool, VerifyRememberedSets, false,                             \
2275           "Verify GC remembered sets")                                      \
2276                                                                             \
2277   diagnostic(bool, VerifyObjectStartArray, true,                            \
2278           "Verify GC object start array if verify before/after")            \
2279                                                                             \
2280   product(bool, DisableExplicitGC, false,                                   \
2281           "Ignore calls to System.gc()")                                    \
2282                                                                             \
2283   notproduct(bool, CheckMemoryInitialization, false,                        \
2284           "Check memory initialization")                                    \
2285                                                                             \
2286   product(bool, CollectGen0First, false,                                    \
2287           "Collect youngest generation before each full GC")                \
2288                                                                             \
2289   diagnostic(bool, BindCMSThreadToCPU, false,                               \
2290           "Bind CMS Thread to CPU if possible")                             \
2291                                                                             \
2292   diagnostic(uintx, CPUForCMSThread, 0,                                     \
2293           "When BindCMSThreadToCPU is true, the CPU to bind CMS thread to") \
2294                                                                             \
2295   product(bool, BindGCTaskThreadsToCPUs, false,                             \
2296           "Bind GCTaskThreads to CPUs if possible")                         \
2297                                                                             \
2298   product(bool, UseGCTaskAffinity, false,                                   \
2299           "Use worker affinity when asking for GCTasks")                    \
2300                                                                             \
2301   product(uintx, ProcessDistributionStride, 4,                              \
2302           "Stride through processors when distributing processes")          \
2303                                                                             \
2304   product(uintx, CMSCoordinatorYieldSleepCount, 10,                         \
2305           "Number of times the coordinator GC thread will sleep while "     \
2306           "yielding before giving up and resuming GC")                      \
2307                                                                             \
2308   product(uintx, CMSYieldSleepCount, 0,                                     \
2309           "Number of times a GC thread (minus the coordinator) "            \
2310           "will sleep while yielding before giving up and resuming GC")     \
2311                                                                             \
2312   /* gc tracing */                                                          \
2313   manageable(bool, PrintGC, false,                                          \
2314           "Print message at garbage collection")                            \
2315                                                                             \
2316   manageable(bool, PrintGCDetails, false,                                   \
2317           "Print more details at garbage collection")                       \
2318                                                                             \
2319   manageable(bool, PrintGCDateStamps, false,                                \
2320           "Print date stamps at garbage collection")                        \
2321                                                                             \
2322   manageable(bool, PrintGCTimeStamps, false,                                \
2323           "Print timestamps at garbage collection")                         \
2324                                                                             \
2325   manageable(bool, PrintGCID, false,                                        \
2326           "Print an identifier for each garbage collection")                \
2327                                                                             \
2328   product(bool, PrintGCTaskTimeStamps, false,                               \
2329           "Print timestamps for individual gc worker thread tasks")         \
2330                                                                             \
2331   develop(intx, ConcGCYieldTimeout, 0,                                      \
2332           "If non-zero, assert that GC threads yield within this "          \
2333           "number of milliseconds")                                         \
2334                                                                             \
2335   notproduct(bool, TraceMarkSweep, false,                                   \
2336           "Trace mark sweep")                                               \
2337                                                                             \
2338   product(bool, PrintReferenceGC, false,                                    \
2339           "Print times spent handling reference objects during GC "         \
2340           "(enabled only when PrintGCDetails)")                             \
2341                                                                             \
2342   develop(bool, TraceReferenceGC, false,                                    \
2343           "Trace handling of soft/weak/final/phantom references")           \
2344                                                                             \
2345   develop(bool, TraceFinalizerRegistration, false,                          \
2346           "Trace registration of final references")                         \
2347                                                                             \
2348   notproduct(bool, TraceScavenge, false,                                    \
2349           "Trace scavenge")                                                 \
2350                                                                             \
2351   product(bool, IgnoreEmptyClassPaths, false,                               \
2352           "Ignore empty path elements in -classpath")                       \
2353                                                                             \
2354   product(bool, TraceClassPaths, false,                                     \
2355           "Trace processing of class paths")                                \
2356                                                                             \
2357   product_rw(bool, TraceClassLoading, false,                                \
2358           "Trace all classes loaded")                                       \
2359                                                                             \
2360   product(bool, TraceClassLoadingPreorder, false,                           \
2361           "Trace all classes loaded in order referenced (not loaded)")      \
2362                                                                             \
2363   product_rw(bool, TraceClassUnloading, false,                              \
2364           "Trace unloading of classes")                                     \
2365                                                                             \
2366   product_rw(bool, TraceLoaderConstraints, false,                           \
2367           "Trace loader constraints")                                       \
2368                                                                             \
2369   develop(bool, TraceClassLoaderData, false,                                \
2370           "Trace class loader loader_data lifetime")                        \
2371                                                                             \
2372   product(uintx, InitialBootClassLoaderMetaspaceSize,                       \
2373           NOT_LP64(2200*K) LP64_ONLY(4*M),                                  \
2374           "Initial size of the boot class loader data metaspace")           \
2375                                                                             \
2376   product(bool, TraceGen0Time, false,                                       \
2377           "Trace accumulated time for Gen 0 collection")                    \
2378                                                                             \
2379   product(bool, TraceGen1Time, false,                                       \
2380           "Trace accumulated time for Gen 1 collection")                    \
2381                                                                             \
2382   product(bool, PrintTenuringDistribution, false,                           \
2383           "Print tenuring age information")                                 \
2384                                                                             \
2385   product_rw(bool, PrintHeapAtGC, false,                                    \
2386           "Print heap layout before and after each GC")                     \
2387                                                                             \
2388   product_rw(bool, PrintHeapAtGCExtended, false,                            \
2389           "Print extended information about the layout of the heap "        \
2390           "when -XX:+PrintHeapAtGC is set")                                 \
2391                                                                             \
2392   product(bool, PrintHeapAtSIGBREAK, true,                                  \
2393           "Print heap layout in response to SIGBREAK")                      \
2394                                                                             \
2395   manageable(bool, PrintClassHistogramBeforeFullGC, false,                  \
2396           "Print a class histogram before any major stop-world GC")         \
2397                                                                             \
2398   manageable(bool, PrintClassHistogramAfterFullGC, false,                   \
2399           "Print a class histogram after any major stop-world GC")          \
2400                                                                             \
2401   manageable(bool, PrintClassHistogram, false,                              \
2402           "Print a histogram of class instances")                           \
2403                                                                             \
2404   develop(bool, TraceWorkGang, false,                                       \
2405           "Trace activities of work gangs")                                 \
2406                                                                             \
2407   product(bool, TraceParallelOldGCTasks, false,                             \
2408           "Trace multithreaded GC activity")                                \
2409                                                                             \
2410   develop(bool, TraceBlockOffsetTable, false,                               \
2411           "Print BlockOffsetTable maps")                                    \
2412                                                                             \
2413   develop(bool, TraceCardTableModRefBS, false,                              \
2414           "Print CardTableModRefBS maps")                                   \
2415                                                                             \
2416   develop(bool, TraceGCTaskManager, false,                                  \
2417           "Trace actions of the GC task manager")                           \
2418                                                                             \
2419   develop(bool, TraceGCTaskQueue, false,                                    \
2420           "Trace actions of the GC task queues")                            \
2421                                                                             \
2422   diagnostic(bool, TraceGCTaskThread, false,                                \
2423           "Trace actions of the GC task threads")                           \
2424                                                                             \
2425   product(bool, PrintParallelOldGCPhaseTimes, false,                        \
2426           "Print the time taken by each phase in ParallelOldGC "            \
2427           "(PrintGCDetails must also be enabled)")                          \
2428                                                                             \
2429   develop(bool, TraceParallelOldGCMarkingPhase, false,                      \
2430           "Trace marking phase in ParallelOldGC")                           \
2431                                                                             \
2432   develop(bool, TraceParallelOldGCSummaryPhase, false,                      \
2433           "Trace summary phase in ParallelOldGC")                           \
2434                                                                             \
2435   develop(bool, TraceParallelOldGCCompactionPhase, false,                   \
2436           "Trace compaction phase in ParallelOldGC")                        \
2437                                                                             \
2438   develop(bool, TraceParallelOldGCDensePrefix, false,                       \
2439           "Trace dense prefix computation for ParallelOldGC")               \
2440                                                                             \
2441   develop(bool, IgnoreLibthreadGPFault, false,                              \
2442           "Suppress workaround for libthread GP fault")                     \
2443                                                                             \
2444   product(bool, PrintJNIGCStalls, false,                                    \
2445           "Print diagnostic message when GC is stalled "                    \
2446           "by JNI critical section")                                        \
2447                                                                             \
2448   experimental(double, ObjectCountCutOffPercent, 0.5,                       \
2449           "The percentage of the used heap that the instances of a class "  \
2450           "must occupy for the class to generate a trace event")            \
2451                                                                             \
2452   /* GC log rotation setting */                                             \
2453                                                                             \
2454   product(bool, UseGCLogFileRotation, false,                                \
2455           "Rotate gclog files (for long running applications). It requires "\
2456           "-Xloggc:&lt;filename&gt;")                                             \
2457                                                                             \
2458   product(uintx, NumberOfGCLogFiles, 0,                                     \
2459           "Number of gclog files in rotation "                              \
2460           "(default: 0, no rotation)")                                      \
2461                                                                             \
2462   product(uintx, GCLogFileSize, 8*K,                                        \
2463           "GC log file size, requires UseGCLogFileRotation. "               \
2464           "Set to 0 to only trigger rotation via jcmd")                     \
2465                                                                             \
2466   /* JVMTI heap profiling */                                                \
2467                                                                             \
2468   diagnostic(bool, TraceJVMTIObjectTagging, false,                          \
2469           "Trace JVMTI object tagging calls")                               \
2470                                                                             \
2471   diagnostic(bool, VerifyBeforeIteration, false,                            \
2472           "Verify memory system before JVMTI iteration")                    \
2473                                                                             \
2474   /* compiler interface */                                                  \
2475                                                                             \
2476   develop(bool, CIPrintCompilerName, false,                                 \
2477           "when CIPrint is active, print the name of the active compiler")  \
2478                                                                             \
2479   develop(bool, CIPrintCompileQueue, false,                                 \
2480           "display the contents of the compile queue whenever a "           \
2481           "compilation is enqueued")                                        \
2482                                                                             \
2483   develop(bool, CIPrintRequests, false,                                     \
2484           "display every request for compilation")                          \
2485                                                                             \
2486   product(bool, CITime, false,                                              \
2487           "collect timing information for compilation")                     \
2488                                                                             \
2489   develop(bool, CITimeEach, false,                                          \
2490           "display timing information after each successful compilation")   \
2491                                                                             \
2492   develop(bool, CICountOSR, false,                                          \
2493           "use a separate counter when assigning ids to osr compilations")  \
2494                                                                             \
2495   develop(bool, CICompileNatives, true,                                     \
2496           "compile native methods if supported by the compiler")            \
2497                                                                             \
2498   develop_pd(bool, CICompileOSR,                                            \
2499           "compile on stack replacement methods if supported by the "       \
2500           "compiler")                                                       \
2501                                                                             \
2502   develop(bool, CIPrintMethodCodes, false,                                  \
2503           "print method bytecodes of the compiled code")                    \
2504                                                                             \
2505   develop(bool, CIPrintTypeFlow, false,                                     \
2506           "print the results of ciTypeFlow analysis")                       \
2507                                                                             \
2508   develop(bool, CITraceTypeFlow, false,                                     \
2509           "detailed per-bytecode tracing of ciTypeFlow analysis")           \
2510                                                                             \
2511   develop(intx, OSROnlyBCI, -1,                                             \
2512           "OSR only at this bci.  Negative values mean exclude that bci")   \
2513                                                                             \
2514   /* compiler */                                                            \
2515                                                                             \
2516   product(intx, CICompilerCount, CI_COMPILER_COUNT,                         \
2517           "Number of compiler threads to run")                              \
2518                                                                             \
2519   product(intx, CompilationPolicyChoice, 0,                                 \
2520           "which compilation policy (0/1)")                                 \
2521                                                                             \
2522   develop(bool, UseStackBanging, true,                                      \
2523           "use stack banging for stack overflow checks (required for "      \
2524           "proper StackOverflow handling; disable only to measure cost "    \
2525           "of stackbanging)")                                               \
2526                                                                             \
2527   develop(bool, UseStrictFP, true,                                          \
2528           "use strict fp if modifier strictfp is set")                      \
2529                                                                             \
2530   develop(bool, GenerateSynchronizationCode, true,                          \
2531           "generate locking/unlocking code for synchronized methods and "   \
2532           "monitors")                                                       \
2533                                                                             \
2534   develop(bool, GenerateCompilerNullChecks, true,                           \
2535           "Generate explicit null checks for loads/stores/calls")           \
2536                                                                             \
2537   develop(bool, GenerateRangeChecks, true,                                  \
2538           "Generate range checks for array accesses")                       \
2539                                                                             \
2540   develop_pd(bool, ImplicitNullChecks,                                      \
2541           "Generate code for implicit null checks")                         \
2542                                                                             \
2543   product_pd(bool, TrapBasedNullChecks,                                     \
2544           "Generate code for null checks that uses a cmp and trap "         \
2545           "instruction raising SIGTRAP.  This is only used if an access to" \
2546           "null (+offset) will not raise a SIGSEGV, i.e.,"                  \
2547           "ImplicitNullChecks don't work (PPC64).")                         \
2548                                                                             \
2549   product(bool, PrintSafepointStatistics, false,                            \
2550           "Print statistics about safepoint synchronization")               \
2551                                                                             \
2552   product(intx, PrintSafepointStatisticsCount, 300,                         \
2553           "Total number of safepoint statistics collected "                 \
2554           "before printing them out")                                       \
2555                                                                             \
2556   product(intx, PrintSafepointStatisticsTimeout,  -1,                       \
2557           "Print safepoint statistics only when safepoint takes "           \
2558           "more than PrintSafepointSatisticsTimeout in millis")             \
2559                                                                             \
2560   product(bool, TraceSafepointCleanupTime, false,                           \
2561           "Print the break down of clean up tasks performed during "        \
2562           "safepoint")                                                      \
2563                                                                             \
2564   product(bool, Inline, true,                                               \
2565           "Enable inlining")                                                \
2566                                                                             \
2567   product(bool, ClipInlining, true,                                         \
2568           "Clip inlining if aggregate method exceeds DesiredMethodLimit")   \
2569                                                                             \
2570   develop(bool, UseCHA, true,                                               \
2571           "Enable CHA")                                                     \
2572                                                                             \
2573   product(bool, UseTypeProfile, true,                                       \
2574           "Check interpreter profile for historically monomorphic calls")   \
2575                                                                             \
2576   notproduct(bool, TimeCompiler, false,                                     \
2577           "Time the compiler")                                              \
2578                                                                             \
2579   diagnostic(bool, PrintInlining, false,                                    \
2580           "Print inlining optimizations")                                   \
2581                                                                             \
2582   product(bool, UsePopCountInstruction, false,                              \
2583           "Use population count instruction")                               \
2584                                                                             \
2585   develop(bool, EagerInitialization, false,                                 \
2586           "Eagerly initialize classes if possible")                         \
2587                                                                             \
2588   develop(bool, TraceMethodReplacement, false,                              \
2589           "Print when methods are replaced do to recompilation")            \
2590                                                                             \
2591   develop(bool, PrintMethodFlushing, false,                                 \
2592           "Print the nmethods being flushed")                               \
2593                                                                             \
2594   diagnostic(bool, PrintMethodFlushingStatistics, false,                    \
2595           "print statistics about method flushing")                         \
2596                                                                             \
2597   develop(bool, UseRelocIndex, false,                                       \
2598           "Use an index to speed random access to relocations")             \
2599                                                                             \
2600   develop(bool, StressCodeBuffers, false,                                   \
2601           "Exercise code buffer expansion and other rare state changes")    \
2602                                                                             \
2603   diagnostic(bool, DebugNonSafepoints, trueInDebug,                         \
2604           "Generate extra debugging information for non-safepoints in "     \
2605           "nmethods")                                                       \
2606                                                                             \
2607   product(bool, PrintVMOptions, false,                                      \
2608           "Print flags that appeared on the command line")                  \
2609                                                                             \
2610   product(bool, IgnoreUnrecognizedVMOptions, false,                         \
2611           "Ignore unrecognized VM options")                                 \
2612                                                                             \
2613   product(bool, PrintCommandLineFlags, false,                               \
2614           "Print flags specified on command line or set by ergonomics")     \
2615                                                                             \
2616   product(bool, PrintFlagsInitial, false,                                   \
2617           "Print all VM flags before argument processing and exit VM")      \
2618                                                                             \
2619   product(bool, PrintFlagsFinal, false,                                     \
2620           "Print all VM flags after argument and ergonomic processing")     \
2621                                                                             \
2622   notproduct(bool, PrintFlagsWithComments, false,                           \
2623           "Print all VM flags with default values and descriptions and "    \
2624           "exit")                                                           \
2625                                                                             \
2626   diagnostic(bool, SerializeVMOutput, true,                                 \
2627           "Use a mutex to serialize output to tty and LogFile")             \
2628                                                                             \
2629   diagnostic(bool, DisplayVMOutput, true,                                   \
2630           "Display all VM output on the tty, independently of LogVMOutput") \
2631                                                                             \
2632   diagnostic(bool, LogVMOutput, false,                                      \
2633           "Save VM output to LogFile")                                      \
2634                                                                             \
2635   diagnostic(ccstr, LogFile, NULL,                                          \
2636           "If LogVMOutput or LogCompilation is on, save VM output to "      \
2637           "this file [default: ./hotspot_pid%p.log] (%p replaced with pid)")\
2638                                                                             \
2639   product(ccstr, ErrorFile, NULL,                                           \
2640           "If an error occurs, save the error data to this file "           \
2641           "[default: ./hs_err_pid%p.log] (%p replaced with pid)")           \
2642                                                                             \
2643   product(bool, DisplayVMOutputToStderr, false,                             \
2644           "If DisplayVMOutput is true, display all VM output to stderr")    \
2645                                                                             \
2646   product(bool, DisplayVMOutputToStdout, false,                             \
2647           "If DisplayVMOutput is true, display all VM output to stdout")    \
2648                                                                             \
2649   product(bool, UseHeavyMonitors, false,                                    \
2650           "use heavyweight instead of lightweight Java monitors")           \
2651                                                                             \
2652   product(bool, PrintStringTableStatistics, false,                          \
2653           "print statistics about the StringTable and SymbolTable")         \
2654                                                                             \
2655   diagnostic(bool, VerifyStringTableAtExit, false,                          \
2656           "verify StringTable contents at exit")                            \
2657                                                                             \
2658   notproduct(bool, PrintSymbolTableSizeHistogram, false,                    \
2659           "print histogram of the symbol table")                            \
2660                                                                             \
2661   notproduct(bool, ExitVMOnVerifyError, false,                              \
2662           "standard exit from VM if bytecode verify error "                 \
2663           "(only in debug mode)")                                           \
2664                                                                             \
2665   notproduct(ccstr, AbortVMOnException, NULL,                               \
2666           "Call fatal if this exception is thrown.  Example: "              \
2667           "java -XX:AbortVMOnException=java.lang.NullPointerException Foo") \
2668                                                                             \
2669   notproduct(ccstr, AbortVMOnExceptionMessage, NULL,                        \
2670           "Call fatal if the exception pointed by AbortVMOnException "      \
2671           "has this message")                                               \
2672                                                                             \
2673   develop(bool, DebugVtables, false,                                        \
2674           "add debugging code to vtable dispatch")                          \
2675                                                                             \
2676   develop(bool, PrintVtables, false,                                        \
2677           "print vtables when printing klass")                              \
2678                                                                             \
2679   notproduct(bool, PrintVtableStats, false,                                 \
2680           "print vtables stats at end of run")                              \
2681                                                                             \
2682   develop(bool, TraceCreateZombies, false,                                  \
2683           "trace creation of zombie nmethods")                              \
2684                                                                             \
2685   notproduct(bool, IgnoreLockingAssertions, false,                          \
2686           "disable locking assertions (for speed)")                         \
2687                                                                             \
2688   product(bool, RangeCheckElimination, true,                                \
2689           "Eliminate range checks")                                         \
2690                                                                             \
2691   develop_pd(bool, UncommonNullCast,                                        \
2692           "track occurrences of null in casts; adjust compiler tactics")    \
2693                                                                             \
2694   develop(bool, TypeProfileCasts,  true,                                    \
2695           "treat casts like calls for purposes of type profiling")          \
2696                                                                             \
2697   develop(bool, DelayCompilationDuringStartup, true,                        \
2698           "Delay invoking the compiler until main application class is "    \
2699           "loaded")                                                         \
2700                                                                             \
2701   develop(bool, CompileTheWorld, false,                                     \
2702           "Compile all methods in all classes in bootstrap class path "     \
2703           "(stress test)")                                                  \
2704                                                                             \
2705   develop(bool, CompileTheWorldPreloadClasses, true,                        \
2706           "Preload all classes used by a class before start loading")       \
2707                                                                             \
2708   notproduct(intx, CompileTheWorldSafepointInterval, 100,                   \
2709           "Force a safepoint every n compiles so sweeper can keep up")      \
2710                                                                             \
2711   develop(bool, FillDelaySlots, true,                                       \
2712           "Fill delay slots (on SPARC only)")                               \
2713                                                                             \
2714   develop(bool, TimeLivenessAnalysis, false,                                \
2715           "Time computation of bytecode liveness analysis")                 \
2716                                                                             \
2717   develop(bool, TraceLivenessGen, false,                                    \
2718           "Trace the generation of liveness analysis information")          \
2719                                                                             \
2720   notproduct(bool, TraceLivenessQuery, false,                               \
2721           "Trace queries of liveness analysis information")                 \
2722                                                                             \
2723   notproduct(bool, CollectIndexSetStatistics, false,                        \
2724           "Collect information about IndexSets")                            \
2725                                                                             \
2726   develop(bool, UseLoopSafepoints, true,                                    \
2727           "Generate Safepoint nodes in every loop")                         \
2728                                                                             \
2729   develop(intx, FastAllocateSizeLimit, 128*K,                               \
2730           /* Note:  This value is zero mod 1&lt;&lt;13 for a cheap sparc set. */  \
2731           "Inline allocations larger than this in doublewords must go slow")\
2732                                                                             \
2733   product(bool, AggressiveOpts, false,                                      \
2734           "Enable aggressive optimizations - see arguments.cpp")            \
2735                                                                             \
2736   product_pd(uintx, TypeProfileLevel,                                       \
2737           "=XYZ, with Z: Type profiling of arguments at call; "             \
2738                      "Y: Type profiling of return value at call; "          \
2739                      "X: Type profiling of parameters to methods; "         \
2740           "X, Y and Z in 0=off ; 1=jsr292 only; 2=all methods")             \
2741                                                                             \
2742   product(intx, TypeProfileArgsLimit,     2,                                \
2743           "max number of call arguments to consider for type profiling")    \
2744                                                                             \
2745   product(intx, TypeProfileParmsLimit,    2,                                \
2746           "max number of incoming parameters to consider for type profiling"\
2747           ", -1 for all")                                                   \
2748                                                                             \
2749   /* statistics */                                                          \
2750   develop(bool, CountCompiledCalls, false,                                  \
2751           "Count method invocations")                                       \
2752                                                                             \
2753   notproduct(bool, CountRuntimeCalls, false,                                \
2754           "Count VM runtime calls")                                         \
2755                                                                             \
2756   develop(bool, CountJNICalls, false,                                       \
2757           "Count jni method invocations")                                   \
2758                                                                             \
2759   notproduct(bool, CountJVMCalls, false,                                    \
2760           "Count jvm method invocations")                                   \
2761                                                                             \
2762   notproduct(bool, CountRemovableExceptions, false,                         \
2763           "Count exceptions that could be replaced by branches due to "     \
2764           "inlining")                                                       \
2765                                                                             \
2766   notproduct(bool, ICMissHistogram, false,                                  \
2767           "Produce histogram of IC misses")                                 \
2768                                                                             \
2769   notproduct(bool, PrintClassStatistics, false,                             \
2770           "Print class statistics at end of run")                           \
2771                                                                             \
2772   notproduct(bool, PrintMethodStatistics, false,                            \
2773           "Print method statistics at end of run")                          \
2774                                                                             \
2775   /* interpreter */                                                         \
2776   develop(bool, ClearInterpreterLocals, false,                              \
2777           "Always clear local variables of interpreter activations upon "   \
2778           "entry")                                                          \
2779                                                                             \
2780   product_pd(bool, RewriteBytecodes,                                        \
2781           "Allow rewriting of bytecodes (bytecodes are not immutable)")     \
2782                                                                             \
2783   product_pd(bool, RewriteFrequentPairs,                                    \
2784           "Rewrite frequently used bytecode pairs into a single bytecode")  \
2785                                                                             \
2786   diagnostic(bool, PrintInterpreter, false,                                 \
2787           "Print the generated interpreter code")                           \
2788                                                                             \
2789   product(bool, UseInterpreter, true,                                       \
2790           "Use interpreter for non-compiled methods")                       \
2791                                                                             \
2792   develop(bool, UseFastSignatureHandlers, true,                             \
2793           "Use fast signature handlers for native calls")                   \
2794                                                                             \
2795   product(bool, UseLoopCounter, true,                                       \
2796           "Increment invocation counter on backward branch")                \
2797                                                                             \
2798   product(bool, UseFastEmptyMethods, true,                                  \
2799           "Use fast method entry code for empty methods")                   \
2800                                                                             \
2801   product(bool, UseFastAccessorMethods, true,                               \
2802           "Use fast method entry code for accessor methods")                \
2803                                                                             \
2804   product_pd(bool, UseOnStackReplacement,                                   \
2805           "Use on stack replacement, calls runtime if invoc. counter "      \
2806           "overflows in loop")                                              \
2807                                                                             \
2808   notproduct(bool, TraceOnStackReplacement, false,                          \
2809           "Trace on stack replacement")                                     \
2810                                                                             \
2811   product_pd(bool, PreferInterpreterNativeStubs,                            \
2812           "Use always interpreter stubs for native methods invoked via "    \
2813           "interpreter")                                                    \
2814                                                                             \
2815   develop(bool, CountBytecodes, false,                                      \
2816           "Count number of bytecodes executed")                             \
2817                                                                             \
2818   develop(bool, PrintBytecodeHistogram, false,                              \
2819           "Print histogram of the executed bytecodes")                      \
2820                                                                             \
2821   develop(bool, PrintBytecodePairHistogram, false,                          \
2822           "Print histogram of the executed bytecode pairs")                 \
2823                                                                             \
2824   diagnostic(bool, PrintSignatureHandlers, false,                           \
2825           "Print code generated for native method signature handlers")      \
2826                                                                             \
2827   develop(bool, VerifyOops, false,                                          \
2828           "Do plausibility checks for oops")                                \
2829                                                                             \
2830   develop(bool, CheckUnhandledOops, false,                                  \
2831           "Check for unhandled oops in VM code")                            \
2832                                                                             \
2833   develop(bool, VerifyJNIFields, trueInDebug,                               \
2834           "Verify jfieldIDs for instance fields")                           \
2835                                                                             \
2836   notproduct(bool, VerifyJNIEnvThread, false,                               \
2837           "Verify JNIEnv.thread == Thread::current() when entering VM "     \
2838           "from JNI")                                                       \
2839                                                                             \
2840   develop(bool, VerifyFPU, false,                                           \
2841           "Verify FPU state (check for NaN's, etc.)")                       \
2842                                                                             \
2843   develop(bool, VerifyThread, false,                                        \
2844           "Watch the thread register for corruption (SPARC only)")          \
2845                                                                             \
2846   develop(bool, VerifyActivationFrameSize, false,                           \
2847           "Verify that activation frame didn't become smaller than its "    \
2848           "minimal size")                                                   \
2849                                                                             \
2850   develop(bool, TraceFrequencyInlining, false,                              \
2851           "Trace frequency based inlining")                                 \
2852                                                                             \
2853   develop_pd(bool, InlineIntrinsics,                                        \
2854           "Inline intrinsics that can be statically resolved")              \
2855                                                                             \
2856   product_pd(bool, ProfileInterpreter,                                      \
2857           "Profile at the bytecode level during interpretation")            \
2858                                                                             \
2859   develop(bool, TraceProfileInterpreter, false,                             \
2860           "Trace profiling at the bytecode level during interpretation. "   \
2861           "This outputs the profiling information collected to improve "    \
2862           "jit compilation.")                                               \
2863                                                                             \
2864   develop_pd(bool, ProfileTraps,                                            \
2865           "Profile deoptimization traps at the bytecode level")             \
2866                                                                             \
2867   product(intx, ProfileMaturityPercentage, 20,                              \
2868           "number of method invocations/branches (expressed as % of "       \
2869           "CompileThreshold) before using the method's profile")            \
2870                                                                             \
2871   develop(bool, PrintMethodData, false,                                     \
2872           "Print the results of +ProfileInterpreter at end of run")         \
2873                                                                             \
2874   develop(bool, VerifyDataPointer, trueInDebug,                             \
2875           "Verify the method data pointer during interpreter profiling")    \
2876                                                                             \
2877   develop(bool, VerifyCompiledCode, false,                                  \
2878           "Include miscellaneous runtime verifications in nmethod code; "   \
2879           "default off because it disturbs nmethod size heuristics")        \
2880                                                                             \
2881   notproduct(bool, CrashGCForDumpingJavaThread, false,                      \
2882           "Manually make GC thread crash then dump java stack trace;  "     \
2883           "Test only")                                                      \
2884                                                                             \
2885   /* compilation */                                                         \
2886   product(bool, UseCompiler, true,                                          \
2887           "Use Just-In-Time compilation")                                   \
2888                                                                             \
2889   develop(bool, TraceCompilationPolicy, false,                              \
2890           "Trace compilation policy")                                       \
2891                                                                             \
2892   develop(bool, TimeCompilationPolicy, false,                               \
2893           "Time the compilation policy")                                    \
2894                                                                             \
2895   product(bool, UseCounterDecay, true,                                      \
2896           "Adjust recompilation counters")                                  \
2897                                                                             \
2898   develop(intx, CounterHalfLifeTime,    30,                                 \
2899           "Half-life time of invocation counters (in seconds)")             \
2900                                                                             \
2901   develop(intx, CounterDecayMinIntervalLength,   500,                       \
2902           "The minimum interval (in milliseconds) between invocation of "   \
2903           "CounterDecay")                                                   \
2904                                                                             \
2905   product(bool, AlwaysCompileLoopMethods, false,                            \
2906           "When using recompilation, never interpret methods "              \
2907           "containing loops")                                               \
2908                                                                             \
2909   product(bool, DontCompileHugeMethods, true,                               \
2910           "Do not compile methods &gt; HugeMethodLimit")                       \
2911                                                                             \
2912   /* Bytecode escape analysis estimation. */                                \
2913   product(bool, EstimateArgEscape, true,                                    \
2914           "Analyze bytecodes to estimate escape state of arguments")        \
2915                                                                             \
2916   product(intx, BCEATraceLevel, 0,                                          \
2917           "How much tracing to do of bytecode escape analysis estimates")   \
2918                                                                             \
2919   product(intx, MaxBCEAEstimateLevel, 5,                                    \
2920           "Maximum number of nested calls that are analyzed by BC EA")      \
2921                                                                             \
2922   product(intx, MaxBCEAEstimateSize, 150,                                   \
2923           "Maximum bytecode size of a method to be analyzed by BC EA")      \
2924                                                                             \
2925   product(intx,  AllocatePrefetchStyle, 1,                                  \
2926           "0 = no prefetch, "                                               \
2927           "1 = prefetch instructions for each allocation, "                 \
2928           "2 = use TLAB watermark to gate allocation prefetch, "            \
2929           "3 = use BIS instruction on Sparc for allocation prefetch")       \
2930                                                                             \
2931   product(intx,  AllocatePrefetchDistance, -1,                              \
2932           "Distance to prefetch ahead of allocation pointer")               \
2933                                                                             \
2934   product(intx,  AllocatePrefetchLines, 3,                                  \
2935           "Number of lines to prefetch ahead of array allocation pointer")  \
2936                                                                             \
2937   product(intx,  AllocateInstancePrefetchLines, 1,                          \
2938           "Number of lines to prefetch ahead of instance allocation "       \
2939           "pointer")                                                        \
2940                                                                             \
2941   product(intx,  AllocatePrefetchStepSize, 16,                              \
2942           "Step size in bytes of sequential prefetch instructions")         \
2943                                                                             \
2944   product(intx,  AllocatePrefetchInstr, 0,                                  \
2945           "Prefetch instruction to prefetch ahead of allocation pointer")   \
2946                                                                             \
2947   /* deoptimization */                                                      \
2948   develop(bool, TraceDeoptimization, false,                                 \
2949           "Trace deoptimization")                                           \
2950                                                                             \
2951   develop(bool, DebugDeoptimization, false,                                 \
2952           "Tracing various information while debugging deoptimization")     \
2953                                                                             \
2954   product(intx, SelfDestructTimer, 0,                                       \
2955           "Will cause VM to terminate after a given time (in minutes) "     \
2956           "(0 means off)")                                                  \
2957                                                                             \
2958   product(intx, MaxJavaStackTraceDepth, 1024,                               \
2959           "The maximum number of lines in the stack trace for Java "        \
2960           "exceptions (0 means all)")                                       \
2961                                                                             \
2962   NOT_EMBEDDED(diagnostic(intx, GuaranteedSafepointInterval, 1000,          \
2963           "Guarantee a safepoint (at least) every so many milliseconds "    \
2964           "(0 means none)"))                                                \
2965                                                                             \
2966   EMBEDDED_ONLY(product(intx, GuaranteedSafepointInterval, 0,               \
2967           "Guarantee a safepoint (at least) every so many milliseconds "    \
2968           "(0 means none)"))                                                \
2969                                                                             \
2970   product(intx, SafepointTimeoutDelay, 10000,                               \
2971           "Delay in milliseconds for option SafepointTimeout")              \
2972                                                                             \
2973   product(intx, NmethodSweepFraction, 16,                                   \
2974           "Number of invocations of sweeper to cover all nmethods")         \
2975                                                                             \
2976   product(intx, NmethodSweepCheckInterval, 5,                               \
2977           "Compilers wake up every n seconds to possibly sweep nmethods")   \
2978                                                                             \
2979   product(intx, NmethodSweepActivity, 10,                                   \
2980           "Removes cold nmethods from code cache if &gt; 0. Higher values "    \
2981           "result in more aggressive sweeping")                             \
2982                                                                             \
2983   notproduct(bool, LogSweeper, false,                                       \
2984           "Keep a ring buffer of sweeper activity")                         \
2985                                                                             \
2986   notproduct(intx, SweeperLogEntries, 1024,                                 \
2987           "Number of records in the ring buffer of sweeper activity")       \
2988                                                                             \
2989   notproduct(intx, MemProfilingInterval, 500,                               \
2990           "Time between each invocation of the MemProfiler")                \
2991                                                                             \
2992   develop(intx, MallocCatchPtr, -1,                                         \
2993           "Hit breakpoint when mallocing/freeing this pointer")             \
2994                                                                             \
2995   notproduct(intx, AssertRepeat, 1,                                         \
2996           "number of times to evaluate expression in assert "               \
2997           "(to estimate overhead); only works with -DUSE_REPEATED_ASSERTS") \
2998                                                                             \
2999   notproduct(ccstrlist, SuppressErrorAt, "",                                \
3000           "List of assertions (file:line) to muzzle")                       \
3001                                                                             \
3002   notproduct(uintx, HandleAllocationLimit, 1024,                            \
3003           "Threshold for HandleMark allocation when +TraceHandleAllocation "\
3004           "is used")                                                        \
3005                                                                             \
3006   develop(uintx, TotalHandleAllocationLimit, 1024,                          \
3007           "Threshold for total handle allocation when "                     \
3008           "+TraceHandleAllocation is used")                                 \
3009                                                                             \
3010   develop(intx, StackPrintLimit, 100,                                       \
3011           "number of stack frames to print in VM-level stack dump")         \
3012                                                                             \
3013   notproduct(intx, MaxElementPrintSize, 256,                                \
3014           "maximum number of elements to print")                            \
3015                                                                             \
3016   notproduct(intx, MaxSubklassPrintSize, 4,                                 \
3017           "maximum number of subklasses to print when printing klass")      \
3018                                                                             \
3019   product(intx, MaxInlineLevel, 9,                                          \
3020           "maximum number of nested calls that are inlined")                \
3021                                                                             \
3022   product(intx, MaxRecursiveInlineLevel, 1,                                 \
3023           "maximum number of nested recursive calls that are inlined")      \
3024                                                                             \
3025   develop(intx, MaxForceInlineLevel, 100,                                   \
3026           "maximum number of nested calls that are forced for inlining "    \
3027           "(using CompilerOracle or marked w/ @ForceInline)")               \
3028                                                                             \
3029   product_pd(intx, InlineSmallCode,                                         \
3030           "Only inline already compiled methods if their code size is "     \
3031           "less than this")                                                 \
3032                                                                             \
3033   product(intx, MaxInlineSize, 35,                                          \
3034           "The maximum bytecode size of a method to be inlined")            \
3035                                                                             \
3036   product_pd(intx, FreqInlineSize,                                          \
3037           "The maximum bytecode size of a frequent method to be inlined")   \
3038                                                                             \
3039   product(intx, MaxTrivialSize, 6,                                          \
3040           "The maximum bytecode size of a trivial method to be inlined")    \
3041                                                                             \
3042   product(intx, MinInliningThreshold, 250,                                  \
3043           "The minimum invocation count a method needs to have to be "      \
3044           "inlined")                                                        \
3045                                                                             \
3046   develop(intx, MethodHistogramCutoff, 100,                                 \
3047           "The cutoff value for method invocation histogram (+CountCalls)") \
3048                                                                             \
3049   develop(intx, ProfilerNumberOfInterpretedMethods, 25,                     \
3050           "Number of interpreted methods to show in profile")               \
3051                                                                             \
3052   develop(intx, ProfilerNumberOfCompiledMethods, 25,                        \
3053           "Number of compiled methods to show in profile")                  \
3054                                                                             \
3055   develop(intx, ProfilerNumberOfStubMethods, 25,                            \
3056           "Number of stub methods to show in profile")                      \
3057                                                                             \
3058   develop(intx, ProfilerNumberOfRuntimeStubNodes, 25,                       \
3059           "Number of runtime stub nodes to show in profile")                \
3060                                                                             \
3061   product(intx, ProfileIntervalsTicks, 100,                                 \
3062           "Number of ticks between printing of interval profile "           \
3063           "(+ProfileIntervals)")                                            \
3064                                                                             \
3065   notproduct(intx, ScavengeALotInterval,     1,                             \
3066           "Interval between which scavenge will occur with +ScavengeALot")  \
3067                                                                             \
3068   notproduct(intx, FullGCALotInterval,     1,                               \
3069           "Interval between which full gc will occur with +FullGCALot")     \
3070                                                                             \
3071   notproduct(intx, FullGCALotStart,     0,                                  \
3072           "For which invocation to start FullGCAlot")                       \
3073                                                                             \
3074   notproduct(intx, FullGCALotDummies,  32*K,                                \
3075           "Dummy object allocated with +FullGCALot, forcing all objects "   \
3076           "to move")                                                        \
3077                                                                             \
3078   develop(intx, DontYieldALotInterval,    10,                               \
3079           "Interval between which yields will be dropped (milliseconds)")   \
3080                                                                             \
3081   develop(intx, MinSleepInterval,     1,                                    \
3082           "Minimum sleep() interval (milliseconds) when "                   \
3083           "ConvertSleepToYield is off (used for Solaris)")                  \
3084                                                                             \
3085   develop(intx, ProfilerPCTickThreshold,    15,                             \
3086           "Number of ticks in a PC buckets to be a hotspot")                \
3087                                                                             \
3088   notproduct(intx, DeoptimizeALotInterval,     5,                           \
3089           "Number of exits until DeoptimizeALot kicks in")                  \
3090                                                                             \
3091   notproduct(intx, ZombieALotInterval,     5,                               \
3092           "Number of exits until ZombieALot kicks in")                      \
3093                                                                             \
3094   diagnostic(intx, MallocVerifyInterval,     0,                             \
3095           "If non-zero, verify C heap after every N calls to "              \
3096           "malloc/realloc/free")                                            \
3097                                                                             \
3098   diagnostic(intx, MallocVerifyStart,     0,                                \
3099           "If non-zero, start verifying C heap after Nth call to "          \
3100           "malloc/realloc/free")                                            \
3101                                                                             \
3102   diagnostic(uintx, MallocMaxTestWords,     0,                              \
3103           "If non-zero, maximum number of words that malloc/realloc can "   \
3104           "allocate (for testing only)")                                    \
3105                                                                             \
3106   product(intx, TypeProfileWidth,     2,                                    \
3107           "Number of receiver types to record in call/cast profile")        \
3108                                                                             \
3109   develop(intx, BciProfileWidth,      2,                                    \
3110           "Number of return bci's to record in ret profile")                \
3111                                                                             \
3112   product(intx, PerMethodRecompilationCutoff, 400,                          \
3113           "After recompiling N times, stay in the interpreter (-1=&gt;'Inf')") \
3114                                                                             \
3115   product(intx, PerBytecodeRecompilationCutoff, 200,                        \
3116           "Per-BCI limit on repeated recompilation (-1=&gt;'Inf')")            \
3117                                                                             \
3118   product(intx, PerMethodTrapLimit,  100,                                   \
3119           "Limit on traps (of one kind) in a method (includes inlines)")    \
3120                                                                             \
3121   experimental(intx, PerMethodSpecTrapLimit,  5000,                         \
3122           "Limit on speculative traps (of one kind) in a method (includes inlines)") \
3123                                                                             \
3124   product(intx, PerBytecodeTrapLimit,  4,                                   \
3125           "Limit on traps (of one kind) at a particular BCI")               \
3126                                                                             \
3127   experimental(intx, SpecTrapLimitExtraEntries,  3,                         \
3128           "Extra method data trap entries for speculation")                 \
3129                                                                             \
3130   develop(intx, InlineFrequencyRatio,    20,                                \
3131           "Ratio of call site execution to caller method invocation")       \
3132                                                                             \
3133   develop_pd(intx, InlineFrequencyCount,                                    \
3134           "Count of call site execution necessary to trigger frequent "     \
3135           "inlining")                                                       \
3136                                                                             \
3137   develop(intx, InlineThrowCount,    50,                                    \
3138           "Force inlining of interpreted methods that throw this often")    \
3139                                                                             \
3140   develop(intx, InlineThrowMaxSize,   200,                                  \
3141           "Force inlining of throwing methods smaller than this")           \
3142                                                                             \
3143   develop(intx, ProfilerNodeSize,  1024,                                    \
3144           "Size in K to allocate for the Profile Nodes of each thread")     \
3145                                                                             \
3146   product_pd(intx, PreInflateSpin,                                          \
3147           "Number of times to spin wait before inflation")                  \
3148                                                                             \
3149   /* gc parameters */                                                       \
3150   product(uintx, InitialHeapSize, 0,                                        \
3151           "Initial heap size (in bytes); zero means use ergonomics")        \
3152                                                                             \
3153   product(uintx, MaxHeapSize, ScaleForWordSize(96*M),                       \
3154           "Maximum heap size (in bytes)")                                   \
3155                                                                             \
3156   product(uintx, OldSize, ScaleForWordSize(4*M),                            \
3157           "Initial tenured generation size (in bytes)")                     \
3158                                                                             \
3159   product(uintx, NewSize, ScaleForWordSize(1*M),                            \
3160           "Initial new generation size (in bytes)")                         \
3161                                                                             \
3162   product(uintx, MaxNewSize, max_uintx,                                     \
3163           "Maximum new generation size (in bytes), max_uintx means set "    \
3164           "ergonomically")                                                  \
3165                                                                             \
3166   product(uintx, PretenureSizeThreshold, 0,                                 \
3167           "Maximum size in bytes of objects allocated in DefNew "           \
3168           "generation; zero means no maximum")                              \
3169                                                                             \
3170   product(uintx, TLABSize, 0,                                               \
3171           "Starting TLAB size (in bytes); zero means set ergonomically")    \
3172                                                                             \
3173   product(uintx, MinTLABSize, 2*K,                                          \
3174           "Minimum allowed TLAB size (in bytes)")                           \
3175                                                                             \
3176   product(uintx, TLABAllocationWeight, 35,                                  \
3177           "Allocation averaging weight")                                    \
3178                                                                             \
3179   product(uintx, TLABWasteTargetPercent, 1,                                 \
3180           "Percentage of Eden that can be wasted")                          \
3181                                                                             \
3182   product(uintx, TLABRefillWasteFraction,    64,                            \
3183           "Maximum TLAB waste at a refill (internal fragmentation)")        \
3184                                                                             \
3185   product(uintx, TLABWasteIncrement,    4,                                  \
3186           "Increment allowed waste at slow allocation")                     \
3187                                                                             \
3188   product(uintx, SurvivorRatio, 8,                                          \
3189           "Ratio of eden/survivor space size")                              \
3190                                                                             \
3191   product(uintx, NewRatio, 2,                                               \
3192           "Ratio of old/new generation sizes")                              \
3193                                                                             \
3194   product_pd(uintx, NewSizeThreadIncrease,                                  \
3195           "Additional size added to desired new generation size per "       \
3196           "non-daemon thread (in bytes)")                                   \
3197                                                                             \
3198   product_pd(uintx, MetaspaceSize,                                          \
3199           "Initial size of Metaspaces (in bytes)")                          \
3200                                                                             \
3201   product(uintx, MaxMetaspaceSize, max_uintx,                               \
3202           "Maximum size of Metaspaces (in bytes)")                          \
3203                                                                             \
3204   product(uintx, CompressedClassSpaceSize, 1*G,                             \
3205           "Maximum size of class area in Metaspace when compressed "        \
3206           "class pointers are used")                                        \
3207                                                                             \
3208   manageable(uintx, MinHeapFreeRatio, 40,                                   \
3209           "The minimum percentage of heap free after GC to avoid expansion."\
3210           " For most GCs this applies to the old generation. In G1 and"     \
3211           " ParallelGC it applies to the whole heap.")                      \
3212                                                                             \
3213   manageable(uintx, MaxHeapFreeRatio, 70,                                   \
3214           "The maximum percentage of heap free after GC to avoid shrinking."\
3215           " For most GCs this applies to the old generation. In G1 and"     \
3216           " ParallelGC it applies to the whole heap.")                      \
3217                                                                             \
3218   product(intx, SoftRefLRUPolicyMSPerMB, 1000,                              \
3219           "Number of milliseconds per MB of free space in the heap")        \
3220                                                                             \
3221   product(uintx, MinHeapDeltaBytes, ScaleForWordSize(128*K),                \
3222           "The minimum change in heap space due to GC (in bytes)")          \
3223                                                                             \
3224   product(uintx, MinMetaspaceExpansion, ScaleForWordSize(256*K),            \
3225           "The minimum expansion of Metaspace (in bytes)")                  \
3226                                                                             \
3227   product(uintx, MinMetaspaceFreeRatio,    40,                              \
3228           "The minimum percentage of Metaspace free after GC to avoid "     \
3229           "expansion")                                                      \
3230                                                                             \
3231   product(uintx, MaxMetaspaceFreeRatio,    70,                              \
3232           "The maximum percentage of Metaspace free after GC to avoid "     \
3233           "shrinking")                                                      \
3234                                                                             \
3235   product(uintx, MaxMetaspaceExpansion, ScaleForWordSize(4*M),              \
3236           "The maximum expansion of Metaspace without full GC (in bytes)")  \
3237                                                                             \
3238   product(uintx, QueuedAllocationWarningCount, 0,                           \
3239           "Number of times an allocation that queues behind a GC "          \
3240           "will retry before printing a warning")                           \
3241                                                                             \
3242   diagnostic(uintx, VerifyGCStartAt,   0,                                   \
3243           "GC invoke count where +VerifyBefore/AfterGC kicks in")           \
3244                                                                             \
3245   diagnostic(intx, VerifyGCLevel,     0,                                    \
3246           "Generation level at which to start +VerifyBefore/AfterGC")       \
3247                                                                             \
<a name="6" id="anc6"></a><span class="changed">3248   product(uintx, MaxTenuringThreshold, 3,                                   \</span>
3249           "Maximum value for tenuring threshold")                           \
3250                                                                             \
<a name="7" id="anc7"></a><span class="changed">3251   product(uintx, InitialTenuringThreshold, 3,                               \</span>
3252           "Initial value for tenuring threshold")                           \
3253                                                                             \
3254   product(uintx, TargetSurvivorRatio,    50,                                \
3255           "Desired percentage of survivor space used after scavenge")       \
3256                                                                             \
3257   product(uintx, MarkSweepDeadRatio,     5,                                 \
3258           "Percentage (0-100) of the old gen allowed as dead wood. "        \
3259           "Serial mark sweep treats this as both the minimum and maximum "  \
3260           "value. "                                                         \
3261           "CMS uses this value only if it falls back to mark sweep. "       \
3262           "Par compact uses a variable scale based on the density of the "  \
3263           "generation and treats this as the maximum value when the heap "  \
3264           "is either completely full or completely empty.  Par compact "    \
3265           "also has a smaller default value; see arguments.cpp.")           \
3266                                                                             \
3267   product(uintx, MarkSweepAlwaysCompactCount,     4,                        \
3268           "How often should we fully compact the heap (ignoring the dead "  \
3269           "space parameters)")                                              \
3270                                                                             \
3271   product(intx, PrintCMSStatistics, 0,                                      \
3272           "Statistics for CMS")                                             \
3273                                                                             \
3274   product(bool, PrintCMSInitiationStatistics, false,                        \
3275           "Statistics for initiating a CMS collection")                     \
3276                                                                             \
3277   product(intx, PrintFLSStatistics, 0,                                      \
3278           "Statistics for CMS' FreeListSpace")                              \
3279                                                                             \
3280   product(intx, PrintFLSCensus, 0,                                          \
3281           "Census for CMS' FreeListSpace")                                  \
3282                                                                             \
3283   develop(uintx, GCExpandToAllocateDelayMillis, 0,                          \
3284           "Delay between expansion and allocation (in milliseconds)")       \
3285                                                                             \
3286   develop(uintx, GCWorkerDelayMillis, 0,                                    \
3287           "Delay in scheduling GC workers (in milliseconds)")               \
3288                                                                             \
3289   product(intx, DeferThrSuspendLoopCount,     4000,                         \
3290           "(Unstable) Number of times to iterate in safepoint loop "        \
3291           "before blocking VM threads ")                                    \
3292                                                                             \
3293   product(intx, DeferPollingPageLoopCount,     -1,                          \
3294           "(Unsafe,Unstable) Number of iterations in safepoint loop "       \
3295           "before changing safepoint polling page to RO ")                  \
3296                                                                             \
3297   product(intx, SafepointSpinBeforeYield, 2000, "(Unstable)")               \
3298                                                                             \
3299   product(bool, PSChunkLargeArrays, true,                                   \
3300           "Process large arrays in chunks")                                 \
3301                                                                             \
3302   product(uintx, GCDrainStackTargetSize, 64,                                \
3303           "Number of entries we will try to leave on the stack "            \
3304           "during parallel gc")                                             \
3305                                                                             \
3306   /* stack parameters */                                                    \
3307   product_pd(intx, StackYellowPages,                                        \
3308           "Number of yellow zone (recoverable overflows) pages")            \
3309                                                                             \
3310   product_pd(intx, StackRedPages,                                           \
3311           "Number of red zone (unrecoverable overflows) pages")             \
3312                                                                             \
3313   product_pd(intx, StackShadowPages,                                        \
3314           "Number of shadow zone (for overflow checking) pages "            \
3315           "this should exceed the depth of the VM and native call stack")   \
3316                                                                             \
3317   product_pd(intx, ThreadStackSize,                                         \
3318           "Thread Stack Size (in Kbytes)")                                  \
3319                                                                             \
3320   product_pd(intx, VMThreadStackSize,                                       \
3321           "Non-Java Thread Stack Size (in Kbytes)")                         \
3322                                                                             \
3323   product_pd(intx, CompilerThreadStackSize,                                 \
3324           "Compiler Thread Stack Size (in Kbytes)")                         \
3325                                                                             \
3326   develop_pd(uintx, JVMInvokeMethodSlack,                                   \
3327           "Stack space (bytes) required for JVM_InvokeMethod to complete")  \
3328                                                                             \
3329   product(uintx, ThreadSafetyMargin, 50*M,                                  \
3330           "Thread safety margin is used on fixed-stack LinuxThreads (on "   \
3331           "Linux/x86 only) to prevent heap-stack collision. Set to 0 to "   \
3332           "disable this feature")                                           \
3333                                                                             \
3334   /* code cache parameters */                                               \
3335   /* ppc64 has large code-entry alignment. */                               \
3336   develop(uintx, CodeCacheSegmentSize, 64 PPC64_ONLY(+64),                  \
3337           "Code cache segment size (in bytes) - smallest unit of "          \
3338           "allocation")                                                     \
3339                                                                             \
3340   develop_pd(intx, CodeEntryAlignment,                                      \
3341           "Code entry alignment for generated code (in bytes)")             \
3342                                                                             \
3343   product_pd(intx, OptoLoopAlignment,                                       \
3344           "Align inner loops to zero relative to this modulus")             \
3345                                                                             \
3346   product_pd(uintx, InitialCodeCacheSize,                                   \
3347           "Initial code cache size (in bytes)")                             \
3348                                                                             \
3349   develop_pd(uintx, CodeCacheMinimumUseSpace,                               \
3350           "Minimum code cache size (in bytes) required to start VM.")       \
3351                                                                             \
3352   product_pd(uintx, ReservedCodeCacheSize,                                  \
3353           "Reserved code cache size (in bytes) - maximum code cache size")  \
3354                                                                             \
3355   product(uintx, CodeCacheMinimumFreeSpace, 500*K,                          \
3356           "When less than X space left, we stop compiling")                 \
3357                                                                             \
3358   product_pd(uintx, CodeCacheExpansionSize,                                 \
3359           "Code cache expansion size (in bytes)")                           \
3360                                                                             \
3361   develop_pd(uintx, CodeCacheMinBlockLength,                                \
3362           "Minimum number of segments in a code cache block")               \
3363                                                                             \
3364   notproduct(bool, ExitOnFullCodeCache, false,                              \
3365           "Exit the VM if we fill the code cache")                          \
3366                                                                             \
3367   product(bool, UseCodeCacheFlushing, true,                                 \
3368           "Remove cold/old nmethods from the code cache")                   \
3369                                                                             \
3370   /* interpreter debugging */                                               \
3371   develop(intx, BinarySwitchThreshold, 5,                                   \
3372           "Minimal number of lookupswitch entries for rewriting to binary " \
3373           "switch")                                                         \
3374                                                                             \
3375   develop(intx, StopInterpreterAt, 0,                                       \
3376           "Stop interpreter execution at specified bytecode number")        \
3377                                                                             \
3378   develop(intx, TraceBytecodesAt, 0,                                        \
3379           "Trace bytecodes starting with specified bytecode number")        \
3380                                                                             \
3381   /* compiler interface */                                                  \
3382   develop(intx, CIStart, 0,                                                 \
3383           "The id of the first compilation to permit")                      \
3384                                                                             \
3385   develop(intx, CIStop, max_jint,                                           \
3386           "The id of the last compilation to permit")                       \
3387                                                                             \
3388   develop(intx, CIStartOSR, 0,                                              \
3389           "The id of the first osr compilation to permit "                  \
3390           "(CICountOSR must be on)")                                        \
3391                                                                             \
3392   develop(intx, CIStopOSR, max_jint,                                        \
3393           "The id of the last osr compilation to permit "                   \
3394           "(CICountOSR must be on)")                                        \
3395                                                                             \
3396   develop(intx, CIBreakAtOSR, -1,                                           \
3397           "The id of osr compilation to break at")                          \
3398                                                                             \
3399   develop(intx, CIBreakAt, -1,                                              \
3400           "The id of compilation to break at")                              \
3401                                                                             \
3402   product(ccstrlist, CompileOnly, "",                                       \
3403           "List of methods (pkg/class.name) to restrict compilation to")    \
3404                                                                             \
3405   product(ccstr, CompileCommandFile, NULL,                                  \
3406           "Read compiler commands from this file [.hotspot_compiler]")      \
3407                                                                             \
3408   product(ccstrlist, CompileCommand, "",                                    \
3409           "Prepend to .hotspot_compiler; e.g. log,java/lang/String.&lt;init&gt;") \
3410                                                                             \
3411   develop(bool, ReplayCompiles, false,                                      \
3412           "Enable replay of compilations from ReplayDataFile")              \
3413                                                                             \
3414   product(ccstr, ReplayDataFile, NULL,                                      \
3415           "File containing compilation replay information"                  \
3416           "[default: ./replay_pid%p.log] (%p replaced with pid)")           \
3417                                                                             \
3418    product(ccstr, InlineDataFile, NULL,                                     \
3419           "File containing inlining replay information"                     \
3420           "[default: ./inline_pid%p.log] (%p replaced with pid)")           \
3421                                                                             \
3422   develop(intx, ReplaySuppressInitializers, 2,                              \
3423           "Control handling of class initialization during replay: "        \
3424           "0 - don't do anything special; "                                 \
3425           "1 - treat all class initializers as empty; "                     \
3426           "2 - treat class initializers for application classes as empty; " \
3427           "3 - allow all class initializers to run during bootstrap but "   \
3428           "    pretend they are empty after starting replay")               \
3429                                                                             \
3430   develop(bool, ReplayIgnoreInitErrors, false,                              \
3431           "Ignore exceptions thrown during initialization for replay")      \
3432                                                                             \
3433   product(bool, DumpReplayDataOnError, true,                                \
3434           "Record replay data for crashing compiler threads")               \
3435                                                                             \
3436   product(bool, CICompilerCountPerCPU, false,                               \
3437           "1 compiler thread for log(N CPUs)")                              \
3438                                                                             \
3439   develop(intx, CIFireOOMAt,    -1,                                         \
3440           "Fire OutOfMemoryErrors throughout CI for testing the compiler "  \
3441           "(non-negative value throws OOM after this many CI accesses "     \
3442           "in each compile)")                                               \
3443   notproduct(intx, CICrashAt, -1,                                           \
3444           "id of compilation to trigger assert in compiler thread for "     \
3445           "the purpose of testing, e.g. generation of replay data")         \
3446   notproduct(bool, CIObjectFactoryVerify, false,                            \
3447           "enable potentially expensive verification in ciObjectFactory")   \
3448                                                                             \
3449   /* Priorities */                                                          \
3450   product_pd(bool, UseThreadPriorities,  "Use native thread priorities")    \
3451                                                                             \
3452   product(intx, ThreadPriorityPolicy, 0,                                    \
3453           "0 : Normal.                                                     "\
3454           "    VM chooses priorities that are appropriate for normal       "\
3455           "    applications. On Solaris NORM_PRIORITY and above are mapped "\
3456           "    to normal native priority. Java priorities below "           \
3457           "    NORM_PRIORITY map to lower native priority values. On       "\
3458           "    Windows applications are allowed to use higher native       "\
3459           "    priorities. However, with ThreadPriorityPolicy=0, VM will   "\
3460           "    not use the highest possible native priority,               "\
3461           "    THREAD_PRIORITY_TIME_CRITICAL, as it may interfere with     "\
3462           "    system threads. On Linux thread priorities are ignored      "\
3463           "    because the OS does not support static priority in          "\
3464           "    SCHED_OTHER scheduling class which is the only choice for   "\
3465           "    non-root, non-realtime applications.                        "\
3466           "1 : Aggressive.                                                 "\
3467           "    Java thread priorities map over to the entire range of      "\
3468           "    native thread priorities. Higher Java thread priorities map "\
3469           "    to higher native thread priorities. This policy should be   "\
3470           "    used with care, as sometimes it can cause performance       "\
3471           "    degradation in the application and/or the entire system. On "\
3472           "    Linux this policy requires root privilege.")                 \
3473                                                                             \
3474   product(bool, ThreadPriorityVerbose, false,                               \
3475           "Print priority changes")                                         \
3476                                                                             \
3477   product(intx, DefaultThreadPriority, -1,                                  \
3478           "The native priority at which threads run if not elsewhere "      \
3479           "specified (-1 means no change)")                                 \
3480                                                                             \
3481   product(intx, CompilerThreadPriority, -1,                                 \
3482           "The native priority at which compiler threads should run "       \
3483           "(-1 means no change)")                                           \
3484                                                                             \
3485   product(intx, VMThreadPriority, -1,                                       \
3486           "The native priority at which the VM thread should run "          \
3487           "(-1 means no change)")                                           \
3488                                                                             \
3489   product(bool, CompilerThreadHintNoPreempt, true,                          \
3490           "(Solaris only) Give compiler threads an extra quanta")           \
3491                                                                             \
3492   product(bool, VMThreadHintNoPreempt, false,                               \
3493           "(Solaris only) Give VM thread an extra quanta")                  \
3494                                                                             \
3495   product(intx, JavaPriority1_To_OSPriority, -1,                            \
3496           "Map Java priorities to OS priorities")                           \
3497                                                                             \
3498   product(intx, JavaPriority2_To_OSPriority, -1,                            \
3499           "Map Java priorities to OS priorities")                           \
3500                                                                             \
3501   product(intx, JavaPriority3_To_OSPriority, -1,                            \
3502           "Map Java priorities to OS priorities")                           \
3503                                                                             \
3504   product(intx, JavaPriority4_To_OSPriority, -1,                            \
3505           "Map Java priorities to OS priorities")                           \
3506                                                                             \
3507   product(intx, JavaPriority5_To_OSPriority, -1,                            \
3508           "Map Java priorities to OS priorities")                           \
3509                                                                             \
3510   product(intx, JavaPriority6_To_OSPriority, -1,                            \
3511           "Map Java priorities to OS priorities")                           \
3512                                                                             \
3513   product(intx, JavaPriority7_To_OSPriority, -1,                            \
3514           "Map Java priorities to OS priorities")                           \
3515                                                                             \
3516   product(intx, JavaPriority8_To_OSPriority, -1,                            \
3517           "Map Java priorities to OS priorities")                           \
3518                                                                             \
3519   product(intx, JavaPriority9_To_OSPriority, -1,                            \
3520           "Map Java priorities to OS priorities")                           \
3521                                                                             \
3522   product(intx, JavaPriority10_To_OSPriority,-1,                            \
3523           "Map Java priorities to OS priorities")                           \
3524                                                                             \
3525   experimental(bool, UseCriticalJavaThreadPriority, false,                  \
3526           "Java thread priority 10 maps to critical scheduling priority")   \
3527                                                                             \
3528   experimental(bool, UseCriticalCompilerThreadPriority, false,              \
3529           "Compiler thread(s) run at critical scheduling priority")         \
3530                                                                             \
3531   experimental(bool, UseCriticalCMSThreadPriority, false,                   \
3532           "ConcurrentMarkSweep thread runs at critical scheduling priority")\
3533                                                                             \
3534   /* compiler debugging */                                                  \
3535   notproduct(intx, CompileTheWorldStartAt,     1,                           \
3536           "First class to consider when using +CompileTheWorld")            \
3537                                                                             \
3538   notproduct(intx, CompileTheWorldStopAt, max_jint,                         \
3539           "Last class to consider when using +CompileTheWorld")             \
3540                                                                             \
3541   develop(intx, NewCodeParameter,      0,                                   \
3542           "Testing Only: Create a dedicated integer parameter before "      \
3543           "putback")                                                        \
3544                                                                             \
3545   /* new oopmap storage allocation */                                       \
3546   develop(intx, MinOopMapAllocation,     8,                                 \
3547           "Minimum number of OopMap entries in an OopMapSet")               \
3548                                                                             \
3549   /* Background Compilation */                                              \
3550   develop(intx, LongCompileThreshold,     50,                               \
3551           "Used with +TraceLongCompiles")                                   \
3552                                                                             \
3553   product(intx, StarvationMonitorInterval,    200,                          \
3554           "Pause between each check (in milliseconds)")                     \
3555                                                                             \
3556   /* recompilation */                                                       \
3557   product_pd(intx, CompileThreshold,                                        \
3558           "number of interpreted method invocations before (re-)compiling") \
3559                                                                             \
3560   product_pd(intx, BackEdgeThreshold,                                       \
3561           "Interpreter Back edge threshold at which an OSR compilation is " \
3562           "invoked")                                                        \
3563                                                                             \
3564   product(intx, Tier0InvokeNotifyFreqLog, 7,                                \
3565           "Interpreter (tier 0) invocation notification frequency")         \
3566                                                                             \
3567   product(intx, Tier2InvokeNotifyFreqLog, 11,                               \
3568           "C1 without MDO (tier 2) invocation notification frequency")      \
3569                                                                             \
3570   product(intx, Tier3InvokeNotifyFreqLog, 10,                               \
3571           "C1 with MDO profiling (tier 3) invocation notification "         \
3572           "frequency")                                                      \
3573                                                                             \
3574   product(intx, Tier23InlineeNotifyFreqLog, 20,                             \
3575           "Inlinee invocation (tiers 2 and 3) notification frequency")      \
3576                                                                             \
3577   product(intx, Tier0BackedgeNotifyFreqLog, 10,                             \
3578           "Interpreter (tier 0) invocation notification frequency")         \
3579                                                                             \
3580   product(intx, Tier2BackedgeNotifyFreqLog, 14,                             \
3581           "C1 without MDO (tier 2) invocation notification frequency")      \
3582                                                                             \
3583   product(intx, Tier3BackedgeNotifyFreqLog, 13,                             \
3584           "C1 with MDO profiling (tier 3) invocation notification "         \
3585           "frequency")                                                      \
3586                                                                             \
3587   product(intx, Tier2CompileThreshold, 0,                                   \
3588           "threshold at which tier 2 compilation is invoked")               \
3589                                                                             \
3590   product(intx, Tier2BackEdgeThreshold, 0,                                  \
3591           "Back edge threshold at which tier 2 compilation is invoked")     \
3592                                                                             \
3593   product(intx, Tier3InvocationThreshold, 200,                              \
3594           "Compile if number of method invocations crosses this "           \
3595           "threshold")                                                      \
3596                                                                             \
3597   product(intx, Tier3MinInvocationThreshold, 100,                           \
3598           "Minimum invocation to compile at tier 3")                        \
3599                                                                             \
3600   product(intx, Tier3CompileThreshold, 2000,                                \
3601           "Threshold at which tier 3 compilation is invoked (invocation "   \
3602           "minimum must be satisfied")                                      \
3603                                                                             \
3604   product(intx, Tier3BackEdgeThreshold,  60000,                             \
3605           "Back edge threshold at which tier 3 OSR compilation is invoked") \
3606                                                                             \
3607   product(intx, Tier4InvocationThreshold, 5000,                             \
3608           "Compile if number of method invocations crosses this "           \
3609           "threshold")                                                      \
3610                                                                             \
3611   product(intx, Tier4MinInvocationThreshold, 600,                           \
3612           "Minimum invocation to compile at tier 4")                        \
3613                                                                             \
3614   product(intx, Tier4CompileThreshold, 15000,                               \
3615           "Threshold at which tier 4 compilation is invoked (invocation "   \
3616           "minimum must be satisfied")                                      \
3617                                                                             \
3618   product(intx, Tier4BackEdgeThreshold, 40000,                              \
3619           "Back edge threshold at which tier 4 OSR compilation is invoked") \
3620                                                                             \
3621   product(intx, Tier3DelayOn, 5,                                            \
3622           "If C2 queue size grows over this amount per compiler thread "    \
3623           "stop compiling at tier 3 and start compiling at tier 2")         \
3624                                                                             \
3625   product(intx, Tier3DelayOff, 2,                                           \
3626           "If C2 queue size is less than this amount per compiler thread "  \
3627           "allow methods compiled at tier 2 transition to tier 3")          \
3628                                                                             \
3629   product(intx, Tier3LoadFeedback, 5,                                       \
3630           "Tier 3 thresholds will increase twofold when C1 queue size "     \
3631           "reaches this amount per compiler thread")                        \
3632                                                                             \
3633   product(intx, Tier4LoadFeedback, 3,                                       \
3634           "Tier 4 thresholds will increase twofold when C2 queue size "     \
3635           "reaches this amount per compiler thread")                        \
3636                                                                             \
3637   product(intx, TieredCompileTaskTimeout, 50,                               \
3638           "Kill compile task if method was not used within "                \
3639           "given timeout in milliseconds")                                  \
3640                                                                             \
3641   product(intx, TieredStopAtLevel, 4,                                       \
3642           "Stop at given compilation level")                                \
3643                                                                             \
3644   product(intx, Tier0ProfilingStartPercentage, 200,                         \
3645           "Start profiling in interpreter if the counters exceed tier 3 "   \
3646           "thresholds by the specified percentage")                         \
3647                                                                             \
3648   product(uintx, IncreaseFirstTierCompileThresholdAt, 50,                   \
3649           "Increase the compile threshold for C1 compilation if the code "  \
3650           "cache is filled by the specified percentage")                    \
3651                                                                             \
3652   product(intx, TieredRateUpdateMinTime, 1,                                 \
3653           "Minimum rate sampling interval (in milliseconds)")               \
3654                                                                             \
3655   product(intx, TieredRateUpdateMaxTime, 25,                                \
3656           "Maximum rate sampling interval (in milliseconds)")               \
3657                                                                             \
3658   product_pd(bool, TieredCompilation,                                       \
3659           "Enable tiered compilation")                                      \
3660                                                                             \
3661   product(bool, PrintTieredEvents, false,                                   \
3662           "Print tiered events notifications")                              \
3663                                                                             \
3664   product_pd(intx, OnStackReplacePercentage,                                \
3665           "NON_TIERED number of method invocations/branches (expressed as " \
3666           "% of CompileThreshold) before (re-)compiling OSR code")          \
3667                                                                             \
3668   product(intx, InterpreterProfilePercentage, 33,                           \
3669           "NON_TIERED number of method invocations/branches (expressed as " \
3670           "% of CompileThreshold) before profiling in the interpreter")     \
3671                                                                             \
3672   develop(intx, MaxRecompilationSearchLength,    10,                        \
3673           "The maximum number of frames to inspect when searching for "     \
3674           "recompilee")                                                     \
3675                                                                             \
3676   develop(intx, MaxInterpretedSearchLength,     3,                          \
3677           "The maximum number of interpreted frames to skip when searching "\
3678           "for recompilee")                                                 \
3679                                                                             \
3680   develop(intx, DesiredMethodLimit,  8000,                                  \
3681           "The desired maximum method size (in bytecodes) after inlining")  \
3682                                                                             \
3683   develop(intx, HugeMethodLimit,  8000,                                     \
3684           "Don't compile methods larger than this if "                      \
3685           "+DontCompileHugeMethods")                                        \
3686                                                                             \
3687   /* New JDK 1.4 reflection implementation */                               \
3688                                                                             \
3689   develop(bool, UseNewReflection, true,                                     \
3690           "Temporary flag for transition to reflection based on dynamic "   \
3691           "bytecode generation in 1.4; can no longer be turned off in 1.4 " \
3692           "JDK, and is unneeded in 1.3 JDK, but marks most places VM "      \
3693           "changes were needed")                                            \
3694                                                                             \
3695   develop(bool, VerifyReflectionBytecodes, false,                           \
3696           "Force verification of 1.4 reflection bytecodes. Does not work "  \
3697           "in situations like that described in 4486457 or for "            \
3698           "constructors generated for serialization, so can not be enabled "\
3699           "in product.")                                                    \
3700                                                                             \
3701   product(bool, ReflectionWrapResolutionErrors, true,                       \
3702           "Temporary flag for transition to AbstractMethodError wrapped "   \
3703           "in InvocationTargetException. See 6531596")                      \
3704                                                                             \
3705   develop(intx, FastSuperclassLimit, 8,                                     \
3706           "Depth of hardwired instanceof accelerator array")                \
3707                                                                             \
3708   /* Properties for Java libraries  */                                      \
3709                                                                             \
3710   product(uintx, MaxDirectMemorySize, 0,                                    \
3711           "Maximum total size of NIO direct-buffer allocations")            \
3712                                                                             \
3713   /* temporary developer defined flags  */                                  \
3714                                                                             \
3715   diagnostic(bool, UseNewCode, false,                                       \
3716           "Testing Only: Use the new version while testing")                \
3717                                                                             \
3718   diagnostic(bool, UseNewCode2, false,                                      \
3719           "Testing Only: Use the new version while testing")                \
3720                                                                             \
3721   diagnostic(bool, UseNewCode3, false,                                      \
3722           "Testing Only: Use the new version while testing")                \
3723                                                                             \
3724   /* flags for performance data collection */                               \
3725                                                                             \
3726   product(bool, UsePerfData, falseInEmbedded,                               \
3727           "Flag to disable jvmstat instrumentation for performance testing "\
3728           "and problem isolation purposes")                                 \
3729                                                                             \
3730   product(bool, PerfDataSaveToFile, false,                                  \
3731           "Save PerfData memory to hsperfdata_&lt;pid&gt; file on exit")          \
3732                                                                             \
3733   product(ccstr, PerfDataSaveFile, NULL,                                    \
3734           "Save PerfData memory to the specified absolute pathname. "       \
3735           "The string %p in the file name (if present) "                    \
3736           "will be replaced by pid")                                        \
3737                                                                             \
3738   product(intx, PerfDataSamplingInterval, 50,                               \
3739           "Data sampling interval (in milliseconds)")                       \
3740                                                                             \
3741   develop(bool, PerfTraceDataCreation, false,                               \
3742           "Trace creation of Performance Data Entries")                     \
3743                                                                             \
3744   develop(bool, PerfTraceMemOps, false,                                     \
3745           "Trace PerfMemory create/attach/detach calls")                    \
3746                                                                             \
3747   product(bool, PerfDisableSharedMem, false,                                \
3748           "Store performance data in standard memory")                      \
3749                                                                             \
3750   product(intx, PerfDataMemorySize, 32*K,                                   \
3751           "Size of performance data memory region. Will be rounded "        \
3752           "up to a multiple of the native os page size.")                   \
3753                                                                             \
3754   product(intx, PerfMaxStringConstLength, 1024,                             \
3755           "Maximum PerfStringConstant string length before truncation")     \
3756                                                                             \
3757   product(bool, PerfAllowAtExitRegistration, false,                         \
3758           "Allow registration of atexit() methods")                         \
3759                                                                             \
3760   product(bool, PerfBypassFileSystemCheck, false,                           \
3761           "Bypass Win32 file system criteria checks (Windows Only)")        \
3762                                                                             \
3763   product(intx, UnguardOnExecutionViolation, 0,                             \
3764           "Unguard page and retry on no-execute fault (Win32 only) "        \
3765           "0=off, 1=conservative, 2=aggressive")                            \
3766                                                                             \
3767   /* Serviceability Support */                                              \
3768                                                                             \
3769   product(bool, ManagementServer, false,                                    \
3770           "Create JMX Management Server")                                   \
3771                                                                             \
3772   product(bool, DisableAttachMechanism, false,                              \
3773           "Disable mechanism that allows tools to attach to this VM")       \
3774                                                                             \
3775   product(bool, StartAttachListener, false,                                 \
3776           "Always start Attach Listener at VM startup")                     \
3777                                                                             \
3778   manageable(bool, PrintConcurrentLocks, false,                             \
3779           "Print java.util.concurrent locks in thread dump")                \
3780                                                                             \
3781   product(bool, TransmitErrorReport, false,                                 \
3782           "Enable error report transmission on erroneous termination")      \
3783                                                                             \
3784   product(ccstr, ErrorReportServer, NULL,                                   \
3785           "Override built-in error report server address")                  \
3786                                                                             \
3787   /* Shared spaces */                                                       \
3788                                                                             \
3789   product(bool, UseSharedSpaces, true,                                      \
3790           "Use shared spaces for metadata")                                 \
3791                                                                             \
3792   product(bool, VerifySharedSpaces, false,                                  \
3793           "Verify shared spaces (false for default archive, true for "      \
3794           "archive specified by -XX:SharedArchiveFile)")                    \
3795                                                                             \
3796   product(bool, RequireSharedSpaces, false,                                 \
3797           "Require shared spaces for metadata")                             \
3798                                                                             \
3799   product(bool, DumpSharedSpaces, false,                                    \
3800           "Special mode: JVM reads a class list, loads classes, builds "    \
3801           "shared spaces, and dumps the shared spaces to a file to be "     \
3802           "used in future JVM runs")                                        \
3803                                                                             \
3804   product(bool, PrintSharedSpaces, false,                                   \
3805           "Print usage of shared spaces")                                   \
3806                                                                             \
3807   product(bool, PrintSharedArchiveAndExit, false,                           \
3808           "Print shared archive file contents")                             \
3809                                                                             \
3810   product(bool, PrintSharedDictionary, false,                               \
3811           "If PrintSharedArchiveAndExit is true, also print the shared "    \
3812           "dictionary")                                                     \
3813                                                                             \
3814   product(uintx, SharedReadWriteSize,  NOT_LP64(12*M) LP64_ONLY(16*M),      \
3815           "Size of read-write space for metadata (in bytes)")               \
3816                                                                             \
3817   product(uintx, SharedReadOnlySize,  NOT_LP64(12*M) LP64_ONLY(16*M),       \
3818           "Size of read-only space for metadata (in bytes)")                \
3819                                                                             \
3820   product(uintx, SharedMiscDataSize,    NOT_LP64(2*M) LP64_ONLY(4*M),       \
3821           "Size of the shared miscellaneous data area (in bytes)")          \
3822                                                                             \
3823   product(uintx, SharedMiscCodeSize,    120*K,                              \
3824           "Size of the shared miscellaneous code area (in bytes)")          \
3825                                                                             \
3826   product(uintx, SharedBaseAddress, LP64_ONLY(32*G)                         \
3827           NOT_LP64(LINUX_ONLY(2*G) NOT_LINUX(0)),                           \
3828           "Address to allocate shared memory region for class data")        \
3829                                                                             \
3830   diagnostic(bool, EnableInvokeDynamic, true,                               \
3831           "support JSR 292 (method handles, invokedynamic, "                \
3832           "anonymous classes")                                              \
3833                                                                             \
3834   diagnostic(bool, IgnoreUnverifiableClassesDuringDump, false,              \
3835           "Do not quit -Xshare:dump even if we encounter unverifiable "     \
3836           "classes. Just exclude them from the shared dictionary.")         \
3837                                                                             \
3838   diagnostic(bool, PrintMethodHandleStubs, false,                           \
3839           "Print generated stub code for method handles")                   \
3840                                                                             \
3841   develop(bool, TraceMethodHandles, false,                                  \
3842           "trace internal method handle operations")                        \
3843                                                                             \
3844   diagnostic(bool, VerifyMethodHandles, trueInDebug,                        \
3845           "perform extra checks when constructing method handles")          \
3846                                                                             \
3847   diagnostic(bool, ShowHiddenFrames, false,                                 \
3848           "show method handle implementation frames (usually hidden)")      \
3849                                                                             \
3850   experimental(bool, TrustFinalNonStaticFields, false,                      \
3851           "trust final non-static declarations for constant folding")       \
3852                                                                             \
3853   diagnostic(bool, FoldStableValues, true,                                  \
3854           "Optimize loads from stable fields (marked w/ @Stable)")          \
3855                                                                             \
3856   develop(bool, TraceInvokeDynamic, false,                                  \
3857           "trace internal invoke dynamic operations")                       \
3858                                                                             \
3859   diagnostic(bool, PauseAtStartup,      false,                              \
3860           "Causes the VM to pause at startup time and wait for the pause "  \
3861           "file to be removed (default: ./vm.paused.&lt;pid&gt;)")                \
3862                                                                             \
3863   diagnostic(ccstr, PauseAtStartupFile, NULL,                               \
3864           "The file to create and for whose removal to await when pausing " \
3865           "at startup. (default: ./vm.paused.&lt;pid&gt;)")                       \
3866                                                                             \
3867   diagnostic(bool, PauseAtExit, false,                                      \
3868           "Pause and wait for keypress on exit if a debugger is attached")  \
3869                                                                             \
3870   product(bool, ExtendedDTraceProbes,    false,                             \
3871           "Enable performance-impacting dtrace probes")                     \
3872                                                                             \
3873   product(bool, DTraceMethodProbes, false,                                  \
3874           "Enable dtrace probes for method-entry and method-exit")          \
3875                                                                             \
3876   product(bool, DTraceAllocProbes, false,                                   \
3877           "Enable dtrace probes for object allocation")                     \
3878                                                                             \
3879   product(bool, DTraceMonitorProbes, false,                                 \
3880           "Enable dtrace probes for monitor events")                        \
3881                                                                             \
3882   product(bool, RelaxAccessControlCheck, false,                             \
3883           "Relax the access control checks in the verifier")                \
3884                                                                             \
3885   diagnostic(bool, PrintDTraceDOF, false,                                   \
3886           "Print the DTrace DOF passed to the system for JSDT probes")      \
3887                                                                             \
3888   product(uintx, StringTableSize, defaultStringTableSize,                   \
3889           "Number of buckets in the interned String table")                 \
3890                                                                             \
3891   experimental(uintx, SymbolTableSize, defaultSymbolTableSize,              \
3892           "Number of buckets in the JVM internal Symbol table")             \
3893                                                                             \
3894   product(bool, UseStringDeduplication, false,                              \
3895           "Use string deduplication")                                       \
3896                                                                             \
3897   product(bool, PrintStringDeduplicationStatistics, false,                  \
3898           "Print string deduplication statistics")                          \
3899                                                                             \
3900   product(uintx, StringDeduplicationAgeThreshold, 3,                        \
3901           "A string must reach this age (or be promoted to an old region) " \
3902           "to be considered for deduplication")                             \
3903                                                                             \
3904   diagnostic(bool, StringDeduplicationResizeALot, false,                    \
3905           "Force table resize every time the table is scanned")             \
3906                                                                             \
3907   diagnostic(bool, StringDeduplicationRehashALot, false,                    \
3908           "Force table rehash every time the table is scanned")             \
3909                                                                             \
3910   develop(bool, TraceDefaultMethods, false,                                 \
3911           "Trace the default method processing steps")                      \
3912                                                                             \
3913   develop(bool, VerifyGenericSignatures, false,                             \
3914           "Abort VM on erroneous or inconsistent generic signatures")       \
3915                                                                             \
3916   product(bool, UseVMInterruptibleIO, false,                                \
3917           "(Unstable, Solaris-specific) Thread interrupt before or with "   \
3918           "EINTR for I/O operations results in OS_INTRPT. The default "     \
3919           "value of this flag is true for JDK 6 and earlier")               \
3920                                                                             \
3921   diagnostic(bool, WhiteBoxAPI, false,                                      \
3922           "Enable internal testing APIs")                                   \
3923                                                                             \
3924   product(bool, PrintGCCause, true,                                         \
3925           "Include GC cause in GC logging")                                 \
3926                                                                             \
3927   experimental(intx, SurvivorAlignmentInBytes, 0,                           \
3928            "Default survivor space alignment in bytes")                     \
3929                                                                             \
3930   product(bool , AllowNonVirtualCalls, false,                               \
3931           "Obey the ACC_SUPER flag and allow invokenonvirtual calls")       \
3932                                                                             \
3933   product(ccstr, DumpLoadedClassList, NULL,                                 \
3934           "Dump the names all loaded classes, that could be stored into "   \
3935           "the CDS archive, in the specified file")                         \
3936                                                                             \
3937   product(ccstr, SharedClassListFile, NULL,                                 \
3938           "Override the default CDS class list")                            \
3939                                                                             \
3940   diagnostic(ccstr, SharedArchiveFile, NULL,                                \
3941           "Override the default location of the CDS archive file")          \
3942                                                                             \
3943   product(ccstr, ExtraSharedClassListFile, NULL,                            \
3944           "Extra classlist for building the CDS archive file")              \
3945                                                                             \
3946   experimental(uintx, ArrayAllocatorMallocLimit,                            \
3947           SOLARIS_ONLY(64*K) NOT_SOLARIS(max_uintx),                        \
3948           "Allocation less than this value will be allocated "              \
3949           "using malloc. Larger allocations will use mmap.")                \
3950                                                                             \
3951   product(bool, EnableTracing, false,                                       \
3952           "Enable event-based tracing")                                     \
3953                                                                             \
3954   product(bool, UseLockedTracing, false,                                    \
3955           "Use locked-tracing when doing event-based tracing")
3956 
3957 /*
3958  *  Macros for factoring of globals
3959  */
3960 
3961 // Interface macros
3962 #define DECLARE_PRODUCT_FLAG(type, name, value, doc)      extern "C" type name;
3963 #define DECLARE_PD_PRODUCT_FLAG(type, name, doc)          extern "C" type name;
3964 #define DECLARE_DIAGNOSTIC_FLAG(type, name, value, doc)   extern "C" type name;
3965 #define DECLARE_EXPERIMENTAL_FLAG(type, name, value, doc) extern "C" type name;
3966 #define DECLARE_MANAGEABLE_FLAG(type, name, value, doc)   extern "C" type name;
3967 #define DECLARE_PRODUCT_RW_FLAG(type, name, value, doc)   extern "C" type name;
3968 #ifdef PRODUCT
3969 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    extern "C" type CONST_##name; const type name = value;
3970 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        extern "C" type CONST_##name; const type name = pd_##name;
3971 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   extern "C" type CONST_##name;
3972 #else
3973 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    extern "C" type name;
3974 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        extern "C" type name;
3975 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   extern "C" type name;
3976 #endif
3977 // Special LP64 flags, product only needed for now.
3978 #ifdef _LP64
3979 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) extern "C" type name;
3980 #else
3981 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) const type name = value;
3982 #endif // _LP64
3983 
3984 // Implementation macros
3985 #define MATERIALIZE_PRODUCT_FLAG(type, name, value, doc)      type name = value;
3986 #define MATERIALIZE_PD_PRODUCT_FLAG(type, name, doc)          type name = pd_##name;
3987 #define MATERIALIZE_DIAGNOSTIC_FLAG(type, name, value, doc)   type name = value;
3988 #define MATERIALIZE_EXPERIMENTAL_FLAG(type, name, value, doc) type name = value;
3989 #define MATERIALIZE_MANAGEABLE_FLAG(type, name, value, doc)   type name = value;
3990 #define MATERIALIZE_PRODUCT_RW_FLAG(type, name, value, doc)   type name = value;
3991 #ifdef PRODUCT
3992 #define MATERIALIZE_DEVELOPER_FLAG(type, name, value, doc)    type CONST_##name = value;
3993 #define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, doc)        type CONST_##name = pd_##name;
3994 #define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, doc)   type CONST_##name = value;
3995 #else
3996 #define MATERIALIZE_DEVELOPER_FLAG(type, name, value, doc)    type name = value;
3997 #define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, doc)        type name = pd_##name;
3998 #define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, doc)   type name = value;
3999 #endif
4000 #ifdef _LP64
4001 #define MATERIALIZE_LP64_PRODUCT_FLAG(type, name, value, doc) type name = value;
4002 #else
4003 #define MATERIALIZE_LP64_PRODUCT_FLAG(type, name, value, doc) /* flag is constant */
4004 #endif // _LP64
4005 
4006 RUNTIME_FLAGS(DECLARE_DEVELOPER_FLAG, DECLARE_PD_DEVELOPER_FLAG, DECLARE_PRODUCT_FLAG, DECLARE_PD_PRODUCT_FLAG, DECLARE_DIAGNOSTIC_FLAG, DECLARE_EXPERIMENTAL_FLAG, DECLARE_NOTPRODUCT_FLAG, DECLARE_MANAGEABLE_FLAG, DECLARE_PRODUCT_RW_FLAG, DECLARE_LP64_PRODUCT_FLAG)
4007 
4008 RUNTIME_OS_FLAGS(DECLARE_DEVELOPER_FLAG, DECLARE_PD_DEVELOPER_FLAG, DECLARE_PRODUCT_FLAG, DECLARE_PD_PRODUCT_FLAG, DECLARE_DIAGNOSTIC_FLAG, DECLARE_NOTPRODUCT_FLAG)
4009 
4010 ARCH_FLAGS(DECLARE_DEVELOPER_FLAG, DECLARE_PRODUCT_FLAG, DECLARE_DIAGNOSTIC_FLAG, DECLARE_EXPERIMENTAL_FLAG, DECLARE_NOTPRODUCT_FLAG)
4011 
4012 // Extensions
4013 
4014 #include "runtime/globals_ext.hpp"
4015 
4016 #endif // SHARE_VM_RUNTIME_GLOBALS_HPP
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="8" type="hidden" /></form></body></html>
