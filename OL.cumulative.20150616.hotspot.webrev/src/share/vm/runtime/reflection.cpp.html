<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/share/vm/runtime/reflection.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "classfile/javaClasses.hpp"
  27 #include "classfile/symbolTable.hpp"
  28 #include "classfile/systemDictionary.hpp"
  29 #include "classfile/verifier.hpp"
  30 #include "classfile/vmSymbols.hpp"
  31 #include "interpreter/linkResolver.hpp"
  32 #include "memory/oopFactory.hpp"
  33 #include "memory/resourceArea.hpp"
  34 #include "memory/universe.inline.hpp"
  35 #include "oops/instanceKlass.hpp"
  36 #include "oops/objArrayKlass.hpp"
  37 #include "oops/objArrayOop.hpp"
  38 #include "prims/jvm.h"
  39 #include "runtime/arguments.hpp"
  40 #include "runtime/handles.inline.hpp"
  41 #include "runtime/javaCalls.hpp"
  42 #include "runtime/reflection.hpp"
  43 #include "runtime/reflectionUtils.hpp"
  44 #include "runtime/signature.hpp"
  45 #include "runtime/vframe.hpp"
  46 
  47 static void trace_class_resolution(Klass* to_class) {
  48   ResourceMark rm;
  49   int line_number = -1;
  50   const char * source_file = NULL;
  51   Klass* caller = NULL;
  52   JavaThread* jthread = JavaThread::current();
  53   if (jthread-&gt;has_last_Java_frame()) {
  54     vframeStream vfst(jthread);
  55     // skip over any frames belonging to java.lang.Class
  56     while (!vfst.at_end() &amp;&amp;
  57            vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class()) {
  58       vfst.next();
  59     }
  60     if (!vfst.at_end()) {
  61       // this frame is a likely suspect
  62       caller = vfst.method()-&gt;method_holder();
  63       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
  64       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
  65       if (s != NULL) {
  66         source_file = s-&gt;as_C_string();
  67       }
  68     }
  69   }
  70   if (caller != NULL) {
  71     const char * from = caller-&gt;external_name();
  72     const char * to = to_class-&gt;external_name();
  73     // print in a single call to reduce interleaving between threads
  74     if (source_file != NULL) {
  75       tty-&gt;print("RESOLVE %s %s %s:%d (reflection)\n", from, to, source_file, line_number);
  76     } else {
  77       tty-&gt;print("RESOLVE %s %s (reflection)\n", from, to);
  78     }
  79   }
  80 }
  81 
  82 
  83 oop Reflection::box(jvalue* value, BasicType type, TRAPS) {
  84   if (type == T_VOID) {
  85     return NULL;
  86   }
  87   if (type == T_OBJECT || type == T_ARRAY) {
  88     // regular objects are not boxed
  89     return (oop) value-&gt;l;
  90   }
  91   oop result = java_lang_boxing_object::create(type, value, CHECK_NULL);
  92   if (result == NULL) {
  93     THROW_(vmSymbols::java_lang_IllegalArgumentException(), result);
  94   }
  95   return result;
  96 }
  97 
  98 
  99 BasicType Reflection::unbox_for_primitive(oop box, jvalue* value, TRAPS) {
 100   if (box == NULL) {
 101     THROW_(vmSymbols::java_lang_IllegalArgumentException(), T_ILLEGAL);
 102   }
 103   return java_lang_boxing_object::get_value(box, value);
 104 }
 105 
 106 BasicType Reflection::unbox_for_regular_object(oop box, jvalue* value) {
 107   // Note:  box is really the unboxed oop.  It might even be a Short, etc.!
 108   value-&gt;l = (jobject) box;
 109   return T_OBJECT;
 110 }
 111 
 112 
 113 void Reflection::widen(jvalue* value, BasicType current_type, BasicType wide_type, TRAPS) {
 114   assert(wide_type != current_type, "widen should not be called with identical types");
 115   switch (wide_type) {
 116     case T_BOOLEAN:
 117     case T_BYTE:
 118     case T_CHAR:
 119       break;  // fail
 120     case T_SHORT:
 121       switch (current_type) {
 122         case T_BYTE:
 123           value-&gt;s = (jshort) value-&gt;b;
 124           return;
 125       }
 126       break;  // fail
 127     case T_INT:
 128       switch (current_type) {
 129         case T_BYTE:
 130           value-&gt;i = (jint) value-&gt;b;
 131           return;
 132         case T_CHAR:
 133           value-&gt;i = (jint) value-&gt;c;
 134           return;
 135         case T_SHORT:
 136           value-&gt;i = (jint) value-&gt;s;
 137           return;
 138       }
 139       break;  // fail
 140     case T_LONG:
 141       switch (current_type) {
 142         case T_BYTE:
 143           value-&gt;j = (jlong) value-&gt;b;
 144           return;
 145         case T_CHAR:
 146           value-&gt;j = (jlong) value-&gt;c;
 147           return;
 148         case T_SHORT:
 149           value-&gt;j = (jlong) value-&gt;s;
 150           return;
 151         case T_INT:
 152           value-&gt;j = (jlong) value-&gt;i;
 153           return;
 154       }
 155       break;  // fail
 156     case T_FLOAT:
 157       switch (current_type) {
 158         case T_BYTE:
 159           value-&gt;f = (jfloat) value-&gt;b;
 160           return;
 161         case T_CHAR:
 162           value-&gt;f = (jfloat) value-&gt;c;
 163           return;
 164         case T_SHORT:
 165           value-&gt;f = (jfloat) value-&gt;s;
 166           return;
 167         case T_INT:
 168           value-&gt;f = (jfloat) value-&gt;i;
 169           return;
 170         case T_LONG:
 171           value-&gt;f = (jfloat) value-&gt;j;
 172           return;
 173       }
 174       break;  // fail
 175     case T_DOUBLE:
 176       switch (current_type) {
 177         case T_BYTE:
 178           value-&gt;d = (jdouble) value-&gt;b;
 179           return;
 180         case T_CHAR:
 181           value-&gt;d = (jdouble) value-&gt;c;
 182           return;
 183         case T_SHORT:
 184           value-&gt;d = (jdouble) value-&gt;s;
 185           return;
 186         case T_INT:
 187           value-&gt;d = (jdouble) value-&gt;i;
 188           return;
 189         case T_FLOAT:
 190           value-&gt;d = (jdouble) value-&gt;f;
 191           return;
 192         case T_LONG:
 193           value-&gt;d = (jdouble) value-&gt;j;
 194           return;
 195       }
 196       break;  // fail
 197     default:
 198       break;  // fail
 199   }
 200   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "argument type mismatch");
 201 }
 202 
 203 
 204 BasicType Reflection::array_get(jvalue* value, arrayOop a, int index, TRAPS) {
 205   if (!a-&gt;is_within_bounds(index)) {
 206     THROW_(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), T_ILLEGAL);
 207   }
 208   if (a-&gt;is_objArray()) {
 209     value-&gt;l = (jobject) objArrayOop(a)-&gt;obj_at(index);
 210     return T_OBJECT;
 211   } else {
 212     assert(a-&gt;is_typeArray(), "just checking");
 213     BasicType type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 214     switch (type) {
 215       case T_BOOLEAN:
 216         value-&gt;z = typeArrayOop(a)-&gt;bool_at(index);
 217         break;
 218       case T_CHAR:
 219         value-&gt;c = typeArrayOop(a)-&gt;char_at(index);
 220         break;
 221       case T_FLOAT:
 222         value-&gt;f = typeArrayOop(a)-&gt;float_at(index);
 223         break;
 224       case T_DOUBLE:
 225         value-&gt;d = typeArrayOop(a)-&gt;double_at(index);
 226         break;
 227       case T_BYTE:
 228         value-&gt;b = typeArrayOop(a)-&gt;byte_at(index);
 229         break;
 230       case T_SHORT:
 231         value-&gt;s = typeArrayOop(a)-&gt;short_at(index);
 232         break;
 233       case T_INT:
 234         value-&gt;i = typeArrayOop(a)-&gt;int_at(index);
 235         break;
 236       case T_LONG:
 237         value-&gt;j = typeArrayOop(a)-&gt;long_at(index);
 238         break;
 239       default:
 240         return T_ILLEGAL;
 241     }
 242     return type;
 243   }
 244 }
 245 
 246 
 247 void Reflection::array_set(jvalue* value, arrayOop a, int index, BasicType value_type, TRAPS) {
 248   if (!a-&gt;is_within_bounds(index)) {
 249     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
 250   }
 251   if (a-&gt;is_objArray()) {
 252     if (value_type == T_OBJECT) {
 253       oop obj = (oop) value-&gt;l;
 254       if (obj != NULL) {
 255         Klass* element_klass = ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass();
 256         if (!obj-&gt;is_a(element_klass)) {
 257           THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "array element type mismatch");
 258         }
 259       }
 260       objArrayOop(a)-&gt;obj_at_put(index, obj);
 261     }
 262   } else {
 263     assert(a-&gt;is_typeArray(), "just checking");
 264     BasicType array_type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 265     if (array_type != value_type) {
 266       // The widen operation can potentially throw an exception, but cannot block,
 267       // so typeArrayOop a is safe if the call succeeds.
 268       widen(value, value_type, array_type, CHECK);
 269     }
 270     switch (array_type) {
 271       case T_BOOLEAN:
 272         typeArrayOop(a)-&gt;bool_at_put(index, value-&gt;z);
 273         break;
 274       case T_CHAR:
 275         typeArrayOop(a)-&gt;char_at_put(index, value-&gt;c);
 276         break;
 277       case T_FLOAT:
 278         typeArrayOop(a)-&gt;float_at_put(index, value-&gt;f);
 279         break;
 280       case T_DOUBLE:
 281         typeArrayOop(a)-&gt;double_at_put(index, value-&gt;d);
 282         break;
 283       case T_BYTE:
 284         typeArrayOop(a)-&gt;byte_at_put(index, value-&gt;b);
 285         break;
 286       case T_SHORT:
 287         typeArrayOop(a)-&gt;short_at_put(index, value-&gt;s);
 288         break;
 289       case T_INT:
 290         typeArrayOop(a)-&gt;int_at_put(index, value-&gt;i);
 291         break;
 292       case T_LONG:
 293         typeArrayOop(a)-&gt;long_at_put(index, value-&gt;j);
 294         break;
 295       default:
 296         THROW(vmSymbols::java_lang_IllegalArgumentException());
 297     }
 298   }
 299 }
 300 
 301 
 302 Klass* Reflection::basic_type_mirror_to_arrayklass(oop basic_type_mirror, TRAPS) {
 303   assert(java_lang_Class::is_primitive(basic_type_mirror), "just checking");
 304   BasicType type = java_lang_Class::primitive_type(basic_type_mirror);
 305   if (type == T_VOID) {
 306     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 307   } else {
 308     return Universe::typeArrayKlassObj(type);
 309   }
 310 }
 311 
 312 
 313 oop Reflection:: basic_type_arrayklass_to_mirror(Klass* basic_type_arrayklass, TRAPS) {
 314   BasicType type = TypeArrayKlass::cast(basic_type_arrayklass)-&gt;element_type();
 315   return Universe::java_mirror(type);
 316 }
 317 
 318 
 319 arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
 320   if (element_mirror == NULL) {
 321     THROW_0(vmSymbols::java_lang_NullPointerException());
 322   }
 323   if (length &lt; 0) {
 324     THROW_0(vmSymbols::java_lang_NegativeArraySizeException());
 325   }
 326   if (java_lang_Class::is_primitive(element_mirror)) {
 327     Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 328     return TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);
 329   } else {
 330     Klass* k = java_lang_Class::as_Klass(element_mirror);
 331     if (k-&gt;oop_is_array() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) {
 332       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 333     }
 334     return oopFactory::new_objArray(k, length, THREAD);
 335   }
 336 }
 337 
 338 
 339 arrayOop Reflection::reflect_new_multi_array(oop element_mirror, typeArrayOop dim_array, TRAPS) {
 340   assert(dim_array-&gt;is_typeArray(), "just checking");
 341   assert(TypeArrayKlass::cast(dim_array-&gt;klass())-&gt;element_type() == T_INT, "just checking");
 342 
 343   if (element_mirror == NULL) {
 344     THROW_0(vmSymbols::java_lang_NullPointerException());
 345   }
 346 
 347   int len = dim_array-&gt;length();
 348   if (len &lt;= 0 || len &gt; MAX_DIM) {
 349     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 350   }
 351 
 352   jint dimensions[MAX_DIM];   // C array copy of intArrayOop
 353   for (int i = 0; i &lt; len; i++) {
 354     int d = dim_array-&gt;int_at(i);
 355     if (d &lt; 0) {
 356       THROW_0(vmSymbols::java_lang_NegativeArraySizeException());
 357     }
 358     dimensions[i] = d;
 359   }
 360 
 361   Klass* klass;
 362   int dim = len;
 363   if (java_lang_Class::is_primitive(element_mirror)) {
 364     klass = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 365   } else {
 366     klass = java_lang_Class::as_Klass(element_mirror);
 367     if (klass-&gt;oop_is_array()) {
 368       int k_dim = ArrayKlass::cast(klass)-&gt;dimension();
 369       if (k_dim + len &gt; MAX_DIM) {
 370         THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 371       }
 372       dim += k_dim;
 373     }
 374   }
 375   klass = klass-&gt;array_klass(dim, CHECK_NULL);
 376   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(len, dimensions, CHECK_NULL);
 377   assert(obj-&gt;is_array(), "just checking");
 378   return arrayOop(obj);
 379 }
 380 
 381 
 382 oop Reflection::array_component_type(oop mirror, TRAPS) {
 383   if (java_lang_Class::is_primitive(mirror)) {
 384     return NULL;
 385   }
 386 
 387   Klass* klass = java_lang_Class::as_Klass(mirror);
 388   if (!klass-&gt;oop_is_array()) {
 389     return NULL;
 390   }
 391 
 392   oop result = ArrayKlass::cast(klass)-&gt;component_mirror();
 393 #ifdef ASSERT
 394   oop result2 = NULL;
 395   if (ArrayKlass::cast(klass)-&gt;dimension() == 1) {
 396     if (klass-&gt;oop_is_typeArray()) {
 397       result2 = basic_type_arrayklass_to_mirror(klass, CHECK_NULL);
 398     } else {
 399       result2 = ObjArrayKlass::cast(klass)-&gt;element_klass()-&gt;java_mirror();
 400     }
 401   } else {
 402     Klass* lower_dim = ArrayKlass::cast(klass)-&gt;lower_dimension();
 403     assert(lower_dim-&gt;oop_is_array(), "just checking");
 404     result2 = lower_dim-&gt;java_mirror();
 405   }
 406   assert(result == result2, "results must be consistent");
 407 #endif //ASSERT
 408   return result;
 409 }
 410 
 411 
 412 bool Reflection::reflect_check_access(Klass* field_class, AccessFlags acc, Klass* target_class, bool is_method_invoke, TRAPS) {
 413   // field_class  : declaring class
 414   // acc          : declared field access
 415   // target_class : for protected
 416 
 417   // Check if field or method is accessible to client.  Throw an
 418   // IllegalAccessException and return false if not.
 419 
 420   // The "client" is the class associated with the nearest real frame
 421   // getCallerClass already skips Method.invoke frames, so pass 0 in
 422   // that case (same as classic).
 423   ResourceMark rm(THREAD);
 424   assert(THREAD-&gt;is_Java_thread(), "sanity check");
 425   Klass* client_class = ((JavaThread *)THREAD)-&gt;security_get_caller_class(is_method_invoke ? 0 : 1);
 426 
 427   if (client_class != field_class) {
 428     if (!verify_class_access(client_class, field_class, false)
 429         || !verify_field_access(client_class,
 430                                 field_class,
 431                                 field_class,
 432                                 acc,
 433                                 false)) {
 434       THROW_(vmSymbols::java_lang_IllegalAccessException(), false);
 435     }
 436   }
 437 
 438   // Additional test for protected members: JLS 6.6.2
 439 
 440   if (acc.is_protected()) {
 441     if (target_class != client_class) {
 442       if (!is_same_class_package(client_class, field_class)) {
 443         if (!target_class-&gt;is_subclass_of(client_class)) {
 444           THROW_(vmSymbols::java_lang_IllegalAccessException(), false);
 445         }
 446       }
 447     }
 448   }
 449 
 450   // Passed all tests
 451   return true;
 452 }
 453 
 454 
 455 bool Reflection::verify_class_access(Klass* current_class, Klass* new_class, bool classloader_only) {
 456   // Verify that current_class can access new_class.  If the classloader_only
 457   // flag is set, we automatically allow any accesses in which current_class
 458   // doesn't have a classloader.
 459   if ((current_class == NULL) ||
 460       (current_class == new_class) ||
 461       (new_class-&gt;is_public()) ||
 462       is_same_class_package(current_class, new_class)) {
 463     return true;
 464   }
 465   // New (1.4) reflection implementation. Allow all accesses from
 466   // sun/reflect/MagicAccessorImpl subclasses to succeed trivially.
 467   if (   JDK_Version::is_gte_jdk14x_version()
 468       &amp;&amp; UseNewReflection
 469       &amp;&amp; current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 470     return true;
 471   }
 472 
 473   return can_relax_access_check_for(current_class, new_class, classloader_only);
 474 }
 475 
 476 static bool under_host_klass(InstanceKlass* ik, Klass* host_klass) {
 477   DEBUG_ONLY(int inf_loop_check = 1000 * 1000 * 1000);
 478   for (;;) {
 479     Klass* hc = (Klass*) ik-&gt;host_klass();
 480     if (hc == NULL)        return false;
 481     if (hc == host_klass)  return true;
 482     ik = InstanceKlass::cast(hc);
 483 
 484     // There's no way to make a host class loop short of patching memory.
 485     // Therefore there cannot be a loop here unless there's another bug.
 486     // Still, let's check for it.
 487     assert(--inf_loop_check &gt; 0, "no host_klass loop");
 488   }
 489 }
 490 
 491 bool Reflection::can_relax_access_check_for(
 492     Klass* accessor, Klass* accessee, bool classloader_only) {
 493   InstanceKlass* accessor_ik = InstanceKlass::cast(accessor);
 494   InstanceKlass* accessee_ik  = InstanceKlass::cast(accessee);
 495 
 496   // If either is on the other's host_klass chain, access is OK,
 497   // because one is inside the other.
 498   if (under_host_klass(accessor_ik, accessee) ||
 499       under_host_klass(accessee_ik, accessor))
 500     return true;
 501 
 502   if ((RelaxAccessControlCheck &amp;&amp;
 503         accessor_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION &amp;&amp;
 504         accessee_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION) ||
 505       (accessor_ik-&gt;major_version() &lt; Verifier::STRICTER_ACCESS_CTRL_CHECK_VERSION &amp;&amp;
 506        accessee_ik-&gt;major_version() &lt; Verifier::STRICTER_ACCESS_CTRL_CHECK_VERSION)) {
 507     return classloader_only &amp;&amp;
 508       Verifier::relax_verify_for(accessor_ik-&gt;class_loader()) &amp;&amp;
 509       accessor_ik-&gt;protection_domain() == accessee_ik-&gt;protection_domain() &amp;&amp;
 510       accessor_ik-&gt;class_loader() == accessee_ik-&gt;class_loader();
 511   } else {
 512     return false;
 513   }
 514 }
 515 
 516 bool Reflection::verify_field_access(Klass* current_class,
 517                                      Klass* resolved_class,
 518                                      Klass* field_class,
 519                                      AccessFlags access,
 520                                      bool classloader_only,
 521                                      bool protected_restriction) {
 522   // Verify that current_class can access a field of field_class, where that
 523   // field's access bits are "access".  We assume that we've already verified
 524   // that current_class can access field_class.
 525   //
 526   // If the classloader_only flag is set, we automatically allow any accesses
 527   // in which current_class doesn't have a classloader.
 528   //
 529   // "resolved_class" is the runtime type of "field_class". Sometimes we don't
 530   // need this distinction (e.g. if all we have is the runtime type, or during
 531   // class file parsing when we only care about the static type); in that case
 532   // callers should ensure that resolved_class == field_class.
 533   //
 534   if ((current_class == NULL) ||
 535       (current_class == field_class) ||
 536       access.is_public()) {
 537     return true;
 538   }
 539 
 540   Klass* host_class = current_class;
 541   while (host_class-&gt;oop_is_instance() &amp;&amp;
 542          InstanceKlass::cast(host_class)-&gt;is_anonymous()) {
 543     Klass* next_host_class = InstanceKlass::cast(host_class)-&gt;host_klass();
 544     if (next_host_class == NULL)  break;
 545     host_class = next_host_class;
 546   }
 547   if (host_class == field_class) {
 548     return true;
 549   }
 550 
 551   if (access.is_protected()) {
 552     if (!protected_restriction) {
 553       // See if current_class (or outermost host class) is a subclass of field_class
 554       // An interface may not access protected members of j.l.Object
 555       if (!host_class-&gt;is_interface() &amp;&amp; host_class-&gt;is_subclass_of(field_class)) {
 556         if (access.is_static() || // static fields are ok, see 6622385
 557             current_class == resolved_class ||
 558             field_class == resolved_class ||
 559             host_class-&gt;is_subclass_of(resolved_class) ||
 560             resolved_class-&gt;is_subclass_of(host_class)) {
 561           return true;
 562         }
 563       }
 564     }
 565   }
 566 
 567   if (!access.is_private() &amp;&amp; is_same_class_package(current_class, field_class)) {
 568     return true;
 569   }
 570 
 571   // New (1.4) reflection implementation. Allow all accesses from
 572   // sun/reflect/MagicAccessorImpl subclasses to succeed trivially.
 573   if (   JDK_Version::is_gte_jdk14x_version()
 574       &amp;&amp; UseNewReflection
 575       &amp;&amp; current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 576     return true;
 577   }
 578 
 579   return can_relax_access_check_for(
 580     current_class, field_class, classloader_only);
 581 }
 582 
 583 
 584 bool Reflection::is_same_class_package(Klass* class1, Klass* class2) {
 585   return InstanceKlass::cast(class1)-&gt;is_same_class_package(class2);
 586 }
 587 
 588 bool Reflection::is_same_package_member(Klass* class1, Klass* class2, TRAPS) {
 589   return InstanceKlass::cast(class1)-&gt;is_same_package_member(class2, THREAD);
 590 }
 591 
 592 
 593 // Checks that the 'outer' klass has declared 'inner' as being an inner klass. If not,
 594 // throw an incompatible class change exception
 595 // If inner_is_member, require the inner to be a member of the outer.
 596 // If !inner_is_member, require the inner to be anonymous (a non-member).
 597 // Caller is responsible for figuring out in advance which case must be true.
 598 void Reflection::check_for_inner_class(instanceKlassHandle outer, instanceKlassHandle inner,
 599                                        bool inner_is_member, TRAPS) {
 600   InnerClassesIterator iter(outer);
 601   constantPoolHandle cp   (THREAD, outer-&gt;constants());
 602   for (; !iter.done(); iter.next()) {
 603      int ioff = iter.inner_class_info_index();
 604      int ooff = iter.outer_class_info_index();
 605 
 606      if (inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff != 0) {
 607         Klass* o = cp-&gt;klass_at(ooff, CHECK);
 608         if (o == outer()) {
 609           Klass* i = cp-&gt;klass_at(ioff, CHECK);
 610           if (i == inner()) {
 611             return;
 612           }
 613         }
 614      }
 615      if (!inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff == 0 &amp;&amp;
 616          cp-&gt;klass_name_at_matches(inner, ioff)) {
 617         Klass* i = cp-&gt;klass_at(ioff, CHECK);
 618         if (i == inner()) {
 619           return;
 620         }
 621      }
 622   }
 623 
 624   // 'inner' not declared as an inner klass in outer
 625   ResourceMark rm(THREAD);
 626   Exceptions::fthrow(
 627     THREAD_AND_LOCATION,
 628     vmSymbols::java_lang_IncompatibleClassChangeError(),
 629     "%s and %s disagree on InnerClasses attribute",
 630     outer-&gt;external_name(),
 631     inner-&gt;external_name()
 632   );
 633 }
 634 
 635 // Utility method converting a single SignatureStream element into java.lang.Class instance
 636 
 637 oop get_mirror_from_signature(methodHandle method, SignatureStream* ss, TRAPS) {
 638   switch (ss-&gt;type()) {
 639     default:
 640       assert(ss-&gt;type() != T_VOID || ss-&gt;at_return_type(), "T_VOID should only appear as return type");
 641       return java_lang_Class::primitive_mirror(ss-&gt;type());
 642     case T_OBJECT:
 643     case T_ARRAY:
 644       Symbol* name        = ss-&gt;as_symbol(CHECK_NULL);
 645       oop loader            = method-&gt;method_holder()-&gt;class_loader();
 646       oop protection_domain = method-&gt;method_holder()-&gt;protection_domain();
 647       Klass* k = SystemDictionary::resolve_or_fail(
 648                                        name,
 649                                        Handle(THREAD, loader),
 650                                        Handle(THREAD, protection_domain),
 651                                        true, CHECK_NULL);
 652       if (TraceClassResolution) {
 653         trace_class_resolution(k);
 654       }
 655       return k-&gt;java_mirror();
 656   };
 657 }
 658 
 659 
 660 objArrayHandle Reflection::get_parameter_types(methodHandle method, int parameter_count, oop* return_type, TRAPS) {
 661   // Allocate array holding parameter types (java.lang.Class instances)
 662   objArrayOop m = oopFactory::new_objArray(SystemDictionary::Class_klass(), parameter_count, CHECK_(objArrayHandle()));
 663   objArrayHandle mirrors (THREAD, m);
 664   int index = 0;
 665   // Collect parameter types
 666   ResourceMark rm(THREAD);
 667   Symbol*  signature  = method-&gt;signature();
 668   SignatureStream ss(signature);
 669   while (!ss.at_return_type()) {
 670     oop mirror = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));
 671     mirrors-&gt;obj_at_put(index++, mirror);
 672     ss.next();
 673   }
 674   assert(index == parameter_count, "invalid parameter count");
 675   if (return_type != NULL) {
 676     // Collect return type as well
 677     assert(ss.at_return_type(), "return type should be present");
 678     *return_type = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));
 679   }
 680   return mirrors;
 681 }
 682 
 683 objArrayHandle Reflection::get_exception_types(methodHandle method, TRAPS) {
 684   return method-&gt;resolved_checked_exceptions(CHECK_(objArrayHandle()));
 685 }
 686 
 687 
 688 Handle Reflection::new_type(Symbol* signature, KlassHandle k, TRAPS) {
 689   // Basic types
 690   BasicType type = vmSymbols::signature_type(signature);
 691   if (type != T_OBJECT) {
 692     return Handle(THREAD, Universe::java_mirror(type));
 693   }
 694 
 695   oop loader = InstanceKlass::cast(k())-&gt;class_loader();
 696   oop protection_domain = k()-&gt;protection_domain();
 697   Klass* result = SystemDictionary::resolve_or_fail(signature,
 698                                     Handle(THREAD, loader),
 699                                     Handle(THREAD, protection_domain),
 700                                     true, CHECK_(Handle()));
 701 
 702   if (TraceClassResolution) {
 703     trace_class_resolution(result);
 704   }
 705 
 706   oop nt = result-&gt;java_mirror();
 707   return Handle(THREAD, nt);
 708 }
 709 
 710 
 711 oop Reflection::new_method(methodHandle method, bool intern_name, bool for_constant_pool_access, TRAPS) {
 712   // In jdk1.2.x, getMethods on an interface erroneously includes &lt;clinit&gt;, thus the complicated assert.
 713   // Also allow sun.reflect.ConstantPool to refer to &lt;clinit&gt; methods as java.lang.reflect.Methods.
 714   assert(!method()-&gt;is_initializer() ||
 715          (for_constant_pool_access &amp;&amp; method()-&gt;is_static()) ||
 716          (method()-&gt;name() == vmSymbols::class_initializer_name()
 717     &amp;&amp; method()-&gt;method_holder()-&gt;is_interface() &amp;&amp; JDK_Version::is_jdk12x_version()), "should call new_constructor instead");
 718   instanceKlassHandle holder (THREAD, method-&gt;method_holder());
 719   int slot = method-&gt;method_idnum();
 720 
 721   Symbol*  signature  = method-&gt;signature();
 722   int parameter_count = ArgumentCount(signature).size();
 723   oop return_type_oop = NULL;
 724   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, &amp;return_type_oop, CHECK_NULL);
 725   if (parameter_types.is_null() || return_type_oop == NULL) return NULL;
 726 
 727   Handle return_type(THREAD, return_type_oop);
 728 
 729   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 730 
 731   if (exception_types.is_null()) return NULL;
 732 
 733   Symbol*  method_name = method-&gt;name();
 734   Handle name;
 735   if (intern_name) {
 736     // intern_name is only true with UseNewReflection
 737     oop name_oop = StringTable::intern(method_name, CHECK_NULL);
 738     name = Handle(THREAD, name_oop);
 739   } else {
 740     name = java_lang_String::create_from_symbol(method_name, CHECK_NULL);
 741   }
 742   if (name == NULL) return NULL;
 743 
 744   int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 745 
 746   Handle mh = java_lang_reflect_Method::create(CHECK_NULL);
 747 
 748   java_lang_reflect_Method::set_clazz(mh(), holder-&gt;java_mirror());
 749   java_lang_reflect_Method::set_slot(mh(), slot);
 750   java_lang_reflect_Method::set_name(mh(), name());
 751   java_lang_reflect_Method::set_return_type(mh(), return_type());
 752   java_lang_reflect_Method::set_parameter_types(mh(), parameter_types());
 753   java_lang_reflect_Method::set_exception_types(mh(), exception_types());
 754   java_lang_reflect_Method::set_modifiers(mh(), modifiers);
 755   java_lang_reflect_Method::set_override(mh(), false);
 756   if (java_lang_reflect_Method::has_signature_field() &amp;&amp;
 757       method-&gt;generic_signature() != NULL) {
 758     Symbol*  gs = method-&gt;generic_signature();
 759     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 760     java_lang_reflect_Method::set_signature(mh(), sig());
 761   }
 762   if (java_lang_reflect_Method::has_annotations_field()) {
 763     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 764     java_lang_reflect_Method::set_annotations(mh(), an_oop);
 765   }
 766   if (java_lang_reflect_Method::has_parameter_annotations_field()) {
 767     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 768     java_lang_reflect_Method::set_parameter_annotations(mh(), an_oop);
 769   }
 770   if (java_lang_reflect_Method::has_annotation_default_field()) {
 771     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotation_default(), CHECK_NULL);
 772     java_lang_reflect_Method::set_annotation_default(mh(), an_oop);
 773   }
 774   if (java_lang_reflect_Method::has_type_annotations_field()) {
 775     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;type_annotations(), CHECK_NULL);
 776     java_lang_reflect_Method::set_type_annotations(mh(), an_oop);
 777   }
 778   return mh();
 779 }
 780 
 781 
 782 oop Reflection::new_constructor(methodHandle method, TRAPS) {
 783   assert(method()-&gt;is_initializer(), "should call new_method instead");
 784 
 785   instanceKlassHandle  holder (THREAD, method-&gt;method_holder());
 786   int slot = method-&gt;method_idnum();
 787 
 788   Symbol*  signature  = method-&gt;signature();
 789   int parameter_count = ArgumentCount(signature).size();
 790   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, NULL, CHECK_NULL);
 791   if (parameter_types.is_null()) return NULL;
 792 
 793   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 794   if (exception_types.is_null()) return NULL;
 795 
 796   int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 797 
 798   Handle ch = java_lang_reflect_Constructor::create(CHECK_NULL);
 799 
 800   java_lang_reflect_Constructor::set_clazz(ch(), holder-&gt;java_mirror());
 801   java_lang_reflect_Constructor::set_slot(ch(), slot);
 802   java_lang_reflect_Constructor::set_parameter_types(ch(), parameter_types());
 803   java_lang_reflect_Constructor::set_exception_types(ch(), exception_types());
 804   java_lang_reflect_Constructor::set_modifiers(ch(), modifiers);
 805   java_lang_reflect_Constructor::set_override(ch(), false);
 806   if (java_lang_reflect_Constructor::has_signature_field() &amp;&amp;
 807       method-&gt;generic_signature() != NULL) {
 808     Symbol*  gs = method-&gt;generic_signature();
 809     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 810     java_lang_reflect_Constructor::set_signature(ch(), sig());
 811   }
 812   if (java_lang_reflect_Constructor::has_annotations_field()) {
 813     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 814     java_lang_reflect_Constructor::set_annotations(ch(), an_oop);
 815   }
 816   if (java_lang_reflect_Constructor::has_parameter_annotations_field()) {
 817     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 818     java_lang_reflect_Constructor::set_parameter_annotations(ch(), an_oop);
 819   }
 820   if (java_lang_reflect_Constructor::has_type_annotations_field()) {
 821     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;type_annotations(), CHECK_NULL);
 822     java_lang_reflect_Constructor::set_type_annotations(ch(), an_oop);
 823   }
 824   return ch();
 825 }
 826 
 827 
 828 oop Reflection::new_field(fieldDescriptor* fd, bool intern_name, TRAPS) {
 829   Symbol*  field_name = fd-&gt;name();
 830   Handle name;
 831   if (intern_name) {
 832     // intern_name is only true with UseNewReflection
 833     oop name_oop = StringTable::intern(field_name, CHECK_NULL);
 834     name = Handle(THREAD, name_oop);
 835   } else {
 836     name = java_lang_String::create_from_symbol(field_name, CHECK_NULL);
 837   }
 838   Symbol*  signature  = fd-&gt;signature();
 839   instanceKlassHandle  holder    (THREAD, fd-&gt;field_holder());
 840   Handle type = new_type(signature, holder, CHECK_NULL);
 841   Handle rh  = java_lang_reflect_Field::create(CHECK_NULL);
 842 
 843   java_lang_reflect_Field::set_clazz(rh(), fd-&gt;field_holder()-&gt;java_mirror());
 844   java_lang_reflect_Field::set_slot(rh(), fd-&gt;index());
 845   java_lang_reflect_Field::set_name(rh(), name());
 846   java_lang_reflect_Field::set_type(rh(), type());
 847   // Note the ACC_ANNOTATION bit, which is a per-class access flag, is never set here.
 848   java_lang_reflect_Field::set_modifiers(rh(), fd-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS);
 849   java_lang_reflect_Field::set_override(rh(), false);
 850   if (java_lang_reflect_Field::has_signature_field() &amp;&amp;
 851       fd-&gt;has_generic_signature()) {
 852     Symbol*  gs = fd-&gt;generic_signature();
 853     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 854     java_lang_reflect_Field::set_signature(rh(), sig());
 855   }
 856   if (java_lang_reflect_Field::has_annotations_field()) {
 857     typeArrayOop an_oop = Annotations::make_java_array(fd-&gt;annotations(), CHECK_NULL);
 858     java_lang_reflect_Field::set_annotations(rh(), an_oop);
 859   }
 860   if (java_lang_reflect_Field::has_type_annotations_field()) {
 861     typeArrayOop an_oop = Annotations::make_java_array(fd-&gt;type_annotations(), CHECK_NULL);
 862     java_lang_reflect_Field::set_type_annotations(rh(), an_oop);
 863   }
 864   return rh();
 865 }
 866 
 867 oop Reflection::new_parameter(Handle method, int index, Symbol* sym,
 868                               int flags, TRAPS) {
 869   Handle name;
 870 
 871   // A null symbol here translates to the empty string
 872   if(NULL != sym) {
 873     name = java_lang_String::create_from_symbol(sym, CHECK_NULL);
 874   } else {
 875     name = java_lang_String::create_from_str("", CHECK_NULL);
 876   }
 877 
 878   Handle rh = java_lang_reflect_Parameter::create(CHECK_NULL);
 879   java_lang_reflect_Parameter::set_name(rh(), name());
 880   java_lang_reflect_Parameter::set_modifiers(rh(), flags);
 881   java_lang_reflect_Parameter::set_executable(rh(), method());
 882   java_lang_reflect_Parameter::set_index(rh(), index);
 883   return rh();
 884 }
 885 
 886 
 887 methodHandle Reflection::resolve_interface_call(instanceKlassHandle klass, methodHandle method,
 888                                                 KlassHandle recv_klass, Handle receiver, TRAPS) {
 889   assert(!method.is_null() , "method should not be null");
 890 
 891   CallInfo info;
 892   Symbol*  signature  = method-&gt;signature();
 893   Symbol*  name       = method-&gt;name();
 894   LinkResolver::resolve_interface_call(info, receiver, recv_klass, klass,
 895                                        name, signature,
 896                                        KlassHandle(), false, true,
 897                                        CHECK_(methodHandle()));
 898   return info.selected_method();
 899 }
 900 
 901 
 902 oop Reflection::invoke(instanceKlassHandle klass, methodHandle reflected_method,
 903                        Handle receiver, bool override, objArrayHandle ptypes,
 904                        BasicType rtype, objArrayHandle args, bool is_method_invoke, TRAPS) {
 905   ResourceMark rm(THREAD);
 906 
 907   methodHandle method;      // actual method to invoke
 908   KlassHandle target_klass; // target klass, receiver's klass for non-static
 909 
 910   // Ensure klass is initialized
 911   klass-&gt;initialize(CHECK_NULL);
 912 
 913   bool is_static = reflected_method-&gt;is_static();
 914   if (is_static) {
 915     // ignore receiver argument
 916     method = reflected_method;
 917     target_klass = klass;
 918   } else {
 919     // check for null receiver
 920     if (receiver.is_null()) {
 921       THROW_0(vmSymbols::java_lang_NullPointerException());
 922     }
 923     // Check class of receiver against class declaring method
 924     if (!receiver-&gt;is_a(klass())) {
 925       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "object is not an instance of declaring class");
 926     }
 927     // target klass is receiver's klass
 928     target_klass = KlassHandle(THREAD, receiver-&gt;klass());
 929     // no need to resolve if method is private or &lt;init&gt;
 930     if (reflected_method-&gt;is_private() || reflected_method-&gt;name() == vmSymbols::object_initializer_name()) {
 931       method = reflected_method;
 932     } else {
 933       // resolve based on the receiver
 934       if (reflected_method-&gt;method_holder()-&gt;is_interface()) {
 935         // resolve interface call
 936         if (ReflectionWrapResolutionErrors) {
 937           // new default: 6531596
 938           // Match resolution errors with those thrown due to reflection inlining
 939           // Linktime resolution &amp; IllegalAccessCheck already done by Class.getMethod()
 940           method = resolve_interface_call(klass, reflected_method, target_klass, receiver, THREAD);
 941           if (HAS_PENDING_EXCEPTION) {
 942           // Method resolution threw an exception; wrap it in an InvocationTargetException
 943             oop resolution_exception = PENDING_EXCEPTION;
 944             CLEAR_PENDING_EXCEPTION;
 945             JavaCallArguments args(Handle(THREAD, resolution_exception));
 946             THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
 947                 vmSymbols::throwable_void_signature(),
 948                 &amp;args);
 949           }
 950         } else {
 951           method = resolve_interface_call(klass, reflected_method, target_klass, receiver, CHECK_(NULL));
 952         }
 953       }  else {
 954         // if the method can be overridden, we resolve using the vtable index.
 955         assert(!reflected_method-&gt;has_itable_index(), "");
 956         int index = reflected_method-&gt;vtable_index();
 957         method = reflected_method;
 958         if (index != Method::nonvirtual_vtable_index) {
 959           // target_klass might be an arrayKlassOop but all vtables start at
 960           // the same place. The cast is to avoid virtual call and assertion.
 961           InstanceKlass* inst = (InstanceKlass*)target_klass();
 962           method = methodHandle(THREAD, inst-&gt;method_at_vtable(index));
 963         }
 964         if (!method.is_null()) {
 965           // Check for abstract methods as well
 966           if (method-&gt;is_abstract()) {
 967             // new default: 6531596
 968             if (ReflectionWrapResolutionErrors) {
 969               ResourceMark rm(THREAD);
 970               Handle h_origexception = Exceptions::new_exception(THREAD,
 971                      vmSymbols::java_lang_AbstractMethodError(),
 972                      Method::name_and_sig_as_C_string(target_klass(),
 973                      method-&gt;name(),
 974                      method-&gt;signature()));
 975               JavaCallArguments args(h_origexception);
 976               THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
 977                 vmSymbols::throwable_void_signature(),
 978                 &amp;args);
 979             } else {
 980               ResourceMark rm(THREAD);
 981               THROW_MSG_0(vmSymbols::java_lang_AbstractMethodError(),
 982                         Method::name_and_sig_as_C_string(target_klass(),
 983                                                                 method-&gt;name(),
 984                                                                 method-&gt;signature()));
 985             }
 986           }
 987         }
 988       }
 989     }
 990   }
 991 
 992   // I believe this is a ShouldNotGetHere case which requires
 993   // an internal vtable bug. If you ever get this please let Karen know.
 994   if (method.is_null()) {
 995     ResourceMark rm(THREAD);
 996     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(),
 997                 Method::name_and_sig_as_C_string(klass(),
 998                                                         reflected_method-&gt;name(),
 999                                                         reflected_method-&gt;signature()));
1000   }
1001 
1002   // In the JDK 1.4 reflection implementation, the security check is
1003   // done at the Java level
1004   if (!(JDK_Version::is_gte_jdk14x_version() &amp;&amp; UseNewReflection)) {
1005 
1006   // Access checking (unless overridden by Method)
1007   if (!override) {
1008     if (!(klass-&gt;is_public() &amp;&amp; reflected_method-&gt;is_public())) {
1009       bool access = Reflection::reflect_check_access(klass(), reflected_method-&gt;access_flags(), target_klass(), is_method_invoke, CHECK_NULL);
1010       if (!access) {
1011         return NULL; // exception
1012       }
1013     }
1014   }
1015 
1016   } // !(Universe::is_gte_jdk14x_version() &amp;&amp; UseNewReflection)
1017 
1018   assert(ptypes-&gt;is_objArray(), "just checking");
1019   int args_len = args.is_null() ? 0 : args-&gt;length();
1020   // Check number of arguments
1021   if (ptypes-&gt;length() != args_len) {
1022     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "wrong number of arguments");
1023   }
1024 
1025   // Create object to contain parameters for the JavaCall
1026   JavaCallArguments java_args(method-&gt;size_of_parameters());
1027 
1028   if (!is_static) {
1029     java_args.push_oop(receiver);
1030   }
1031 
1032   for (int i = 0; i &lt; args_len; i++) {
1033     oop type_mirror = ptypes-&gt;obj_at(i);
1034     oop arg = args-&gt;obj_at(i);
1035     if (java_lang_Class::is_primitive(type_mirror)) {
1036       jvalue value;
1037       BasicType ptype = basic_type_mirror_to_basic_type(type_mirror, CHECK_NULL);
1038       BasicType atype = unbox_for_primitive(arg, &amp;value, CHECK_NULL);
1039       if (ptype != atype) {
1040         widen(&amp;value, atype, ptype, CHECK_NULL);
1041       }
1042       switch (ptype) {
1043         case T_BOOLEAN:     java_args.push_int(value.z);    break;
1044         case T_CHAR:        java_args.push_int(value.c);    break;
1045         case T_BYTE:        java_args.push_int(value.b);    break;
1046         case T_SHORT:       java_args.push_int(value.s);    break;
1047         case T_INT:         java_args.push_int(value.i);    break;
1048         case T_LONG:        java_args.push_long(value.j);   break;
1049         case T_FLOAT:       java_args.push_float(value.f);  break;
1050         case T_DOUBLE:      java_args.push_double(value.d); break;
1051         default:
1052           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "argument type mismatch");
1053       }
1054     } else {
1055       if (arg != NULL) {
1056         Klass* k = java_lang_Class::as_Klass(type_mirror);
1057         if (!arg-&gt;is_a(k)) {
1058           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "argument type mismatch");
1059         }
1060       }
1061       Handle arg_handle(THREAD, arg);         // Create handle for argument
1062       java_args.push_oop(arg_handle); // Push handle
1063     }
1064   }
1065 
1066   assert(java_args.size_of_parameters() == method-&gt;size_of_parameters(), "just checking");
1067 
1068   // All oops (including receiver) is passed in as Handles. An potential oop is returned as an
1069   // oop (i.e., NOT as an handle)
1070   JavaValue result(rtype);
1071   JavaCalls::call(&amp;result, method, &amp;java_args, THREAD);
1072 
1073   if (HAS_PENDING_EXCEPTION) {
1074     // Method threw an exception; wrap it in an InvocationTargetException
1075     oop target_exception = PENDING_EXCEPTION;
1076     CLEAR_PENDING_EXCEPTION;
1077     JavaCallArguments args(Handle(THREAD, target_exception));
1078     THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1079                 vmSymbols::throwable_void_signature(),
1080                 &amp;args);
1081   } else {
1082     if (rtype == T_BOOLEAN || rtype == T_BYTE || rtype == T_CHAR || rtype == T_SHORT)
1083       narrow((jvalue*) result.get_value_addr(), rtype, CHECK_NULL);
1084     return box((jvalue*) result.get_value_addr(), rtype, CHECK_NULL);
1085   }
1086 }
1087 
1088 
1089 void Reflection::narrow(jvalue* value, BasicType narrow_type, TRAPS) {
1090   switch (narrow_type) {
1091     case T_BOOLEAN:
1092      value-&gt;z = (jboolean) value-&gt;i;
1093      return;
1094     case T_BYTE:
1095      value-&gt;b = (jbyte) value-&gt;i;
1096      return;
1097     case T_CHAR:
1098      value-&gt;c = (jchar) value-&gt;i;
1099      return;
1100     case T_SHORT:
1101      value-&gt;s = (jshort) value-&gt;i;
1102      return;
1103     default:
1104       break; // fail
1105    }
1106   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "argument type mismatch");
1107 }
1108 
1109 
1110 BasicType Reflection::basic_type_mirror_to_basic_type(oop basic_type_mirror, TRAPS) {
1111   assert(java_lang_Class::is_primitive(basic_type_mirror), "just checking");
1112   return java_lang_Class::primitive_type(basic_type_mirror);
1113 }
1114 
1115 // This would be nicer if, say, java.lang.reflect.Method was a subclass
1116 // of java.lang.reflect.Constructor
1117 
1118 oop Reflection::invoke_method(oop method_mirror, Handle receiver,
1119     objArrayHandle method_args, TRAPS) {
1120   oop mirror = java_lang_reflect_Method::clazz(method_mirror);
1121   int slot = java_lang_reflect_Method::slot(method_mirror);
1122   bool override = java_lang_reflect_Method::override(method_mirror) != 0;
1123   objArrayHandle ptypes(THREAD,
1124       objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));
1125 
1126   oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
1127   BasicType rtype;
1128   if (java_lang_Class::is_primitive(return_type_mirror)) {
1129     rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
1130   } else {
1131     rtype = T_OBJECT;
1132   }
1133 
1134   instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));
1135   Method* m = klass-&gt;method_with_idnum(slot);
1136   if (m == NULL) {
1137     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), "invoke");
1138   }
1139   methodHandle method(THREAD, m);
1140 
1141   return invoke(klass, method, receiver, override, ptypes, rtype, method_args,
1142       true, THREAD);
1143 }
1144 
1145 oop Reflection::invoke_constructor(oop ctor_mirror, objArrayHandle ctor_args,
1146     TRAPS) {
1147   oop mirror = java_lang_reflect_Constructor::clazz(ctor_mirror);
1148   int slot = java_lang_reflect_Constructor::slot(ctor_mirror);
1149   bool override = java_lang_reflect_Constructor::override(ctor_mirror) != 0;
1150   objArrayHandle ptypes(THREAD,
1151       objArrayOop(java_lang_reflect_Constructor::parameter_types(ctor_mirror)));
1152 
1153   instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));
1154   Method* m = klass-&gt;method_with_idnum(slot);
1155   if (m == NULL) {
1156     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), "invoke");
1157   }
1158   methodHandle method(THREAD, m);
1159   assert(method-&gt;name() == vmSymbols::object_initializer_name(),
1160       "invalid constructor");
1161 
1162   // Make sure we are not trying to instantiate an abstract klass
1163   klass-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1164 
1165   // Make sure klass is initialized
1166   klass-&gt;initialize(CHECK_NULL);
1167 
1168   // Create new instance (the receiver)
1169   Handle receiver = klass-&gt;allocate_instance_handle(CHECK_NULL);
1170 
1171   invoke(klass, method, receiver, override, ptypes, T_VOID, ctor_args, false,
1172       CHECK_NULL);
1173   return receiver();
1174 }
1175 
1176 oop Reflection::invoke_constructor_in_place(address obj_addr,
1177     bool is_contained, bool is_container, oop ctor_mirror,
1178     objArrayHandle ctor_args, TRAPS) {
1179   oop mirror = java_lang_reflect_Constructor::clazz(ctor_mirror);
1180   int slot = java_lang_reflect_Constructor::slot(ctor_mirror);
1181   bool override = java_lang_reflect_Constructor::override(ctor_mirror) != 0;
1182   objArrayHandle ptypes(THREAD,
1183       objArrayOop(java_lang_reflect_Constructor::parameter_types(ctor_mirror)));
1184 
1185   instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));
1186   Method* m = klass-&gt;method_with_idnum(slot);
1187   if (m == NULL) {
1188     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), "invoke");
1189   }
1190   methodHandle method(THREAD, m);
1191   assert(method-&gt;name() == vmSymbols::object_initializer_name(),
1192       "invalid constructor");
1193 
1194   // Make sure we are not trying to instantiate an abstract klass
1195   klass-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1196 
1197   // Make sure klass is initialized
1198   klass-&gt;initialize(CHECK_NULL);
1199 
1200   // Create new instance (the receiver) at the given address (in preallocated
1201   // memory region)
1202   Handle receiver = klass-&gt;allocate_instance_at_handle(obj_addr, is_contained,
1203       is_container, CHECK_NULL);
1204 
1205   invoke(klass, method, receiver, override, ptypes, T_VOID, ctor_args, false,
1206       CHECK_NULL);
1207   return receiver();
1208 }
</pre></body></html>
