<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/cpu/x86/vm/x86_64.ad</title>
<body id="SUNWwebrev">
<pre>
   1 //
   2 // Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
   3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4 //
   5 // This code is free software; you can redistribute it and/or modify it
   6 // under the terms of the GNU General Public License version 2 only, as
   7 // published by the Free Software Foundation.
   8 //
   9 // This code is distributed in the hope that it will be useful, but WITHOUT
  10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12 // version 2 for more details (a copy is included in the LICENSE file that
  13 // accompanied this code).
  14 //
  15 // You should have received a copy of the GNU General Public License version
  16 // 2 along with this work; if not, write to the Free Software Foundation,
  17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18 //
  19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20 // or visit www.oracle.com if you need additional information or have any
  21 // questions.
  22 //
  23 //
  24 
  25 // AMD64 Architecture Description File
  26 
  27 //----------REGISTER DEFINITION BLOCK------------------------------------------
  28 // This information is used by the matcher and the register allocator to
  29 // describe individual registers and classes of registers within the target
  30 // archtecture.
  31 
  32 register %{
  33 //----------Architecture Description Register Definitions----------------------
  34 // General Registers
  35 // "reg_def"  name ( register save type, C convention save type,
  36 //                   ideal register type, encoding );
  37 // Register Save Types:
  38 //
  39 // NS  = No-Save:       The register allocator assumes that these registers
  40 //                      can be used without saving upon entry to the method, &amp;
  41 //                      that they do not need to be saved at call sites.
  42 //
  43 // SOC = Save-On-Call:  The register allocator assumes that these registers
  44 //                      can be used without saving upon entry to the method,
  45 //                      but that they must be saved at call sites.
  46 //
  47 // SOE = Save-On-Entry: The register allocator assumes that these registers
  48 //                      must be saved before using them upon entry to the
  49 //                      method, but they do not need to be saved at call
  50 //                      sites.
  51 //
  52 // AS  = Always-Save:   The register allocator assumes that these registers
  53 //                      must be saved before using them upon entry to the
  54 //                      method, &amp; that they must be saved at call sites.
  55 //
  56 // Ideal Register Type is used to determine how to save &amp; restore a
  57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
  58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
  59 //
  60 // The encoding number is the actual bit-pattern placed into the opcodes.
  61 
  62 // General Registers
  63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
  64 // used as byte registers)
  65 
  66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
  67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
  68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
  69 
  70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
  71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
  72 
  73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
  74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
  75 
  76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
  77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
  78 
  79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
  80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
  81 
  82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
  83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
  84 
  85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
  86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
  87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
  88 
  89 #ifdef _WIN64
  90 
  91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
  92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  93 
  94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
  95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  96 
  97 #else
  98 
  99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
 100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
 101 
 102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
 103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
 104 
 105 #endif
 106 
 107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
 108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
 109 
 110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
 111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
 112 
 113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
 114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
 115 
 116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
 117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
 118 
 119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
 120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
 121 
 122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
 123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
 124 
 125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
 126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
 127 
 128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
 129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
 130 
 131 
 132 // Floating Point Registers
 133 
 134 // Specify priority of register selection within phases of register
 135 // allocation.  Highest priority is first.  A useful heuristic is to
 136 // give registers a low priority when they are required by machine
 137 // instructions, like EAX and EDX on I486, and choose no-save registers
 138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
 139 // which participate in fixed calling sequences should come last.
 140 // Registers which are used as pairs must fall on an even boundary.
 141 
 142 alloc_class chunk0(R10,         R10_H,
 143                    R11,         R11_H,
 144                    R8,          R8_H,
 145                    R9,          R9_H,
 146                    R12,         R12_H,
 147                    RCX,         RCX_H,
 148                    RBX,         RBX_H,
 149                    RDI,         RDI_H,
 150                    RDX,         RDX_H,
 151                    RSI,         RSI_H,
 152                    RAX,         RAX_H,
 153                    RBP,         RBP_H,
 154                    R13,         R13_H,
 155                    R14,         R14_H,
 156                    R15,         R15_H,
 157                    RSP,         RSP_H);
 158 
 159 
 160 //----------Architecture Description Register Classes--------------------------
 161 // Several register classes are automatically defined based upon information in
 162 // this architecture description.
 163 // 1) reg_class inline_cache_reg           ( /* as def'd in frame section */ )
 164 // 2) reg_class compiler_method_oop_reg    ( /* as def'd in frame section */ )
 165 // 2) reg_class interpreter_method_oop_reg ( /* as def'd in frame section */ )
 166 // 3) reg_class stack_slots( /* one chunk of stack-based "registers" */ )
 167 //
 168 
 169 // Class for all pointer registers (including RSP)
 170 reg_class any_reg(RAX, RAX_H,
 171                   RDX, RDX_H,
 172                   RBP, RBP_H,
 173                   RDI, RDI_H,
 174                   RSI, RSI_H,
 175                   RCX, RCX_H,
 176                   RBX, RBX_H,
 177                   RSP, RSP_H,
 178                   R8,  R8_H,
 179                   R9,  R9_H,
 180                   R10, R10_H,
 181                   R11, R11_H,
 182                   R12, R12_H,
 183                   R13, R13_H,
 184                   R14, R14_H,
 185                   R15, R15_H);
 186 
 187 // Class for all pointer registers except RSP
 188 reg_class ptr_reg(RAX, RAX_H,
 189                   RDX, RDX_H,
 190                   RBP, RBP_H,
 191                   RDI, RDI_H,
 192                   RSI, RSI_H,
 193                   RCX, RCX_H,
 194                   RBX, RBX_H,
 195                   R8,  R8_H,
 196                   R9,  R9_H,
 197                   R10, R10_H,
 198                   R11, R11_H,
 199                   R13, R13_H,
 200                   R14, R14_H);
 201 
 202 // Class for all pointer registers except RAX and RSP
 203 reg_class ptr_no_rax_reg(RDX, RDX_H,
 204                          RBP, RBP_H,
 205                          RDI, RDI_H,
 206                          RSI, RSI_H,
 207                          RCX, RCX_H,
 208                          RBX, RBX_H,
 209                          R8,  R8_H,
 210                          R9,  R9_H,
 211                          R10, R10_H,
 212                          R11, R11_H,
 213                          R13, R13_H,
 214                          R14, R14_H);
 215 
 216 reg_class ptr_no_rbp_reg(RDX, RDX_H,
 217                          RAX, RAX_H,
 218                          RDI, RDI_H,
 219                          RSI, RSI_H,
 220                          RCX, RCX_H,
 221                          RBX, RBX_H,
 222                          R8,  R8_H,
 223                          R9,  R9_H,
 224                          R10, R10_H,
 225                          R11, R11_H,
 226                          R13, R13_H,
 227                          R14, R14_H);
 228 
 229 // Class for all pointer registers except RAX, RBX and RSP
 230 reg_class ptr_no_rax_rbx_reg(RDX, RDX_H,
 231                              RBP, RBP_H,
 232                              RDI, RDI_H,
 233                              RSI, RSI_H,
 234                              RCX, RCX_H,
 235                              R8,  R8_H,
 236                              R9,  R9_H,
 237                              R10, R10_H,
 238                              R11, R11_H,
 239                              R13, R13_H,
 240                              R14, R14_H);
 241 
 242 // Singleton class for RAX pointer register
 243 reg_class ptr_rax_reg(RAX, RAX_H);
 244 
 245 // Singleton class for RBX pointer register
 246 reg_class ptr_rbx_reg(RBX, RBX_H);
 247 
 248 // Singleton class for RSI pointer register
 249 reg_class ptr_rsi_reg(RSI, RSI_H);
 250 
 251 // Singleton class for RDI pointer register
 252 reg_class ptr_rdi_reg(RDI, RDI_H);
 253 
 254 // Singleton class for RBP pointer register
 255 reg_class ptr_rbp_reg(RBP, RBP_H);
 256 
 257 // Singleton class for stack pointer
 258 reg_class ptr_rsp_reg(RSP, RSP_H);
 259 
 260 // Singleton class for TLS pointer
 261 reg_class ptr_r15_reg(R15, R15_H);
 262 
 263 // Class for all long registers (except RSP)
 264 reg_class long_reg(RAX, RAX_H,
 265                    RDX, RDX_H,
 266                    RBP, RBP_H,
 267                    RDI, RDI_H,
 268                    RSI, RSI_H,
 269                    RCX, RCX_H,
 270                    RBX, RBX_H,
 271                    R8,  R8_H,
 272                    R9,  R9_H,
 273                    R10, R10_H,
 274                    R11, R11_H,
 275                    R13, R13_H,
 276                    R14, R14_H);
 277 
 278 // Class for all long registers except RAX, RDX (and RSP)
 279 reg_class long_no_rax_rdx_reg(RBP, RBP_H,
 280                               RDI, RDI_H,
 281                               RSI, RSI_H,
 282                               RCX, RCX_H,
 283                               RBX, RBX_H,
 284                               R8,  R8_H,
 285                               R9,  R9_H,
 286                               R10, R10_H,
 287                               R11, R11_H,
 288                               R13, R13_H,
 289                               R14, R14_H);
 290 
 291 // Class for all long registers except RCX (and RSP)
 292 reg_class long_no_rcx_reg(RBP, RBP_H,
 293                           RDI, RDI_H,
 294                           RSI, RSI_H,
 295                           RAX, RAX_H,
 296                           RDX, RDX_H,
 297                           RBX, RBX_H,
 298                           R8,  R8_H,
 299                           R9,  R9_H,
 300                           R10, R10_H,
 301                           R11, R11_H,
 302                           R13, R13_H,
 303                           R14, R14_H);
 304 
 305 // Class for all long registers except RAX (and RSP)
 306 reg_class long_no_rax_reg(RBP, RBP_H,
 307                           RDX, RDX_H,
 308                           RDI, RDI_H,
 309                           RSI, RSI_H,
 310                           RCX, RCX_H,
 311                           RBX, RBX_H,
 312                           R8,  R8_H,
 313                           R9,  R9_H,
 314                           R10, R10_H,
 315                           R11, R11_H,
 316                           R13, R13_H,
 317                           R14, R14_H);
 318 
 319 // Singleton class for RAX long register
 320 reg_class long_rax_reg(RAX, RAX_H);
 321 
 322 // Singleton class for RCX long register
 323 reg_class long_rcx_reg(RCX, RCX_H);
 324 
 325 // Singleton class for RDX long register
 326 reg_class long_rdx_reg(RDX, RDX_H);
 327 
 328 // Class for all int registers (except RSP)
 329 reg_class int_reg(RAX,
 330                   RDX,
 331                   RBP,
 332                   RDI,
 333                   RSI,
 334                   RCX,
 335                   RBX,
 336                   R8,
 337                   R9,
 338                   R10,
 339                   R11,
 340                   R13,
 341                   R14);
 342 
 343 // Class for all int registers except RCX (and RSP)
 344 reg_class int_no_rcx_reg(RAX,
 345                          RDX,
 346                          RBP,
 347                          RDI,
 348                          RSI,
 349                          RBX,
 350                          R8,
 351                          R9,
 352                          R10,
 353                          R11,
 354                          R13,
 355                          R14);
 356 
 357 // Class for all int registers except RAX, RDX (and RSP)
 358 reg_class int_no_rax_rdx_reg(RBP,
 359                              RDI,
 360                              RSI,
 361                              RCX,
 362                              RBX,
 363                              R8,
 364                              R9,
 365                              R10,
 366                              R11,
 367                              R13,
 368                              R14);
 369 
 370 // Singleton class for RAX int register
 371 reg_class int_rax_reg(RAX);
 372 
 373 // Singleton class for RBX int register
 374 reg_class int_rbx_reg(RBX);
 375 
 376 // Singleton class for RCX int register
 377 reg_class int_rcx_reg(RCX);
 378 
 379 // Singleton class for RCX int register
 380 reg_class int_rdx_reg(RDX);
 381 
 382 // Singleton class for RCX int register
 383 reg_class int_rdi_reg(RDI);
 384 
 385 // Singleton class for instruction pointer
 386 // reg_class ip_reg(RIP);
 387 
 388 %}
 389 
 390 //----------SOURCE BLOCK-------------------------------------------------------
 391 // This is a block of C++ code which provides values, functions, and
 392 // definitions necessary in the rest of the architecture description
 393 source %{
 394 #define   RELOC_IMM64    Assembler::imm_operand
 395 #define   RELOC_DISP32   Assembler::disp32_operand
 396 
 397 #define __ _masm.
 398 
 399 static int preserve_SP_size() {
 400   return 3;  // rex.w, op, rm(reg/reg)
 401 }
 402 static int clear_avx_size() {
 403   return (Compile::current()-&gt;max_vector_size() &gt; 16) ? 3 : 0;  // vzeroupper
 404 }
 405 
 406 // !!!!! Special hack to get all types of calls to specify the byte offset
 407 //       from the start of the call to the point where the return address
 408 //       will point.
 409 int MachCallStaticJavaNode::ret_addr_offset()
 410 {
 411   int offset = 5; // 5 bytes from start of call to where return address points
 412   offset += clear_avx_size();
 413   if (_method_handle_invoke)
 414     offset += preserve_SP_size();
 415   return offset;
 416 }
 417 
 418 int MachCallDynamicJavaNode::ret_addr_offset()
 419 {
 420   int offset = 15; // 15 bytes from start of call to where return address points
 421   offset += clear_avx_size();
 422   return offset;
 423 }
 424 
 425 int MachCallRuntimeNode::ret_addr_offset() {
 426   int offset = 13; // movq r10,#addr; callq (r10)
 427   offset += clear_avx_size();
 428   return offset;
 429 }
 430 
 431 // Indicate if the safepoint node needs the polling page as an input,
 432 // it does if the polling page is more than disp32 away.
 433 bool SafePointNode::needs_polling_address_input()
 434 {
 435   return Assembler::is_polling_page_far();
 436 }
 437 
 438 //
 439 // Compute padding required for nodes which need alignment
 440 //
 441 
 442 // The address of the call instruction needs to be 4-byte aligned to
 443 // ensure that it does not span a cache line so that it can be patched.
 444 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
 445 {
 446   current_offset += clear_avx_size(); // skip vzeroupper
 447   current_offset += 1; // skip call opcode byte
 448   return round_to(current_offset, alignment_required()) - current_offset;
 449 }
 450 
 451 // The address of the call instruction needs to be 4-byte aligned to
 452 // ensure that it does not span a cache line so that it can be patched.
 453 int CallStaticJavaHandleNode::compute_padding(int current_offset) const
 454 {
 455   current_offset += preserve_SP_size();   // skip mov rbp, rsp
 456   current_offset += clear_avx_size(); // skip vzeroupper
 457   current_offset += 1; // skip call opcode byte
 458   return round_to(current_offset, alignment_required()) - current_offset;
 459 }
 460 
 461 // The address of the call instruction needs to be 4-byte aligned to
 462 // ensure that it does not span a cache line so that it can be patched.
 463 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
 464 {
 465   current_offset += clear_avx_size(); // skip vzeroupper
 466   current_offset += 11; // skip movq instruction + call opcode byte
 467   return round_to(current_offset, alignment_required()) - current_offset;
 468 }
 469 
 470 // EMIT_RM()
 471 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
 472   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
 473   cbuf.insts()-&gt;emit_int8(c);
 474 }
 475 
 476 // EMIT_CC()
 477 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
 478   unsigned char c = (unsigned char) (f1 | f2);
 479   cbuf.insts()-&gt;emit_int8(c);
 480 }
 481 
 482 // EMIT_OPCODE()
 483 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
 484   cbuf.insts()-&gt;emit_int8((unsigned char) code);
 485 }
 486 
 487 // EMIT_OPCODE() w/ relocation information
 488 void emit_opcode(CodeBuffer &amp;cbuf,
 489                  int code, relocInfo::relocType reloc, int offset, int format)
 490 {
 491   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
 492   emit_opcode(cbuf, code);
 493 }
 494 
 495 // EMIT_D8()
 496 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
 497   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
 498 }
 499 
 500 // EMIT_D16()
 501 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
 502   cbuf.insts()-&gt;emit_int16(d16);
 503 }
 504 
 505 // EMIT_D32()
 506 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
 507   cbuf.insts()-&gt;emit_int32(d32);
 508 }
 509 
 510 // EMIT_D64()
 511 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
 512   cbuf.insts()-&gt;emit_int64(d64);
 513 }
 514 
 515 // emit 32 bit value and construct relocation entry from relocInfo::relocType
 516 void emit_d32_reloc(CodeBuffer&amp; cbuf,
 517                     int d32,
 518                     relocInfo::relocType reloc,
 519                     int format)
 520 {
 521   assert(reloc != relocInfo::external_word_type, "use 2-arg emit_d32_reloc");
 522   cbuf.relocate(cbuf.insts_mark(), reloc, format);
 523   cbuf.insts()-&gt;emit_int32(d32);
 524 }
 525 
 526 // emit 32 bit value and construct relocation entry from RelocationHolder
 527 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
 528 #ifdef ASSERT
 529   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
 530       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
 531     assert(Universe::heap()-&gt;is_in_reserved((address)(intptr_t)d32), "should be real oop");
 532     assert(cast_to_oop((intptr_t)d32)-&gt;is_oop() &amp;&amp; (ScavengeRootsInCode || !cast_to_oop((intptr_t)d32)-&gt;is_scavengable()), "cannot embed scavengable oops in code");
 533   }
 534 #endif
 535   cbuf.relocate(cbuf.insts_mark(), rspec, format);
 536   cbuf.insts()-&gt;emit_int32(d32);
 537 }
 538 
 539 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
 540   address next_ip = cbuf.insts_end() + 4;
 541   emit_d32_reloc(cbuf, (int) (addr - next_ip),
 542                  external_word_Relocation::spec(addr),
 543                  RELOC_DISP32);
 544 }
 545 
 546 
 547 // emit 64 bit value and construct relocation entry from relocInfo::relocType
 548 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
 549   cbuf.relocate(cbuf.insts_mark(), reloc, format);
 550   cbuf.insts()-&gt;emit_int64(d64);
 551 }
 552 
 553 // emit 64 bit value and construct relocation entry from RelocationHolder
 554 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
 555 #ifdef ASSERT
 556   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
 557       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
 558     assert(Universe::heap()-&gt;is_in_reserved((address)d64), "should be real oop");
 559     assert(cast_to_oop(d64)-&gt;is_oop() &amp;&amp; (ScavengeRootsInCode || !cast_to_oop(d64)-&gt;is_scavengable()),
 560            "cannot embed scavengable oops in code");
 561   }
 562 #endif
 563   cbuf.relocate(cbuf.insts_mark(), rspec, format);
 564   cbuf.insts()-&gt;emit_int64(d64);
 565 }
 566 
 567 // Access stack slot for load or store
 568 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
 569 {
 570   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
 571   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
 572     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
 573     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
 574     emit_d8(cbuf, disp);     // Displacement  // R/M byte
 575   } else {
 576     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
 577     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
 578     emit_d32(cbuf, disp);     // Displacement // R/M byte
 579   }
 580 }
 581 
 582    // rRegI ereg, memory mem) %{    // emit_reg_mem
 583 void encode_RegMem(CodeBuffer &amp;cbuf,
 584                    int reg,
 585                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
 586 {
 587   assert(disp_reloc == relocInfo::none, "cannot have disp");
 588   int regenc = reg &amp; 7;
 589   int baseenc = base &amp; 7;
 590   int indexenc = index &amp; 7;
 591 
 592   // There is no index &amp; no scale, use form without SIB byte
 593   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
 594     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
 595     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
 596       emit_rm(cbuf, 0x0, regenc, baseenc); // *
 597     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
 598       // If 8-bit displacement, mode 0x1
 599       emit_rm(cbuf, 0x1, regenc, baseenc); // *
 600       emit_d8(cbuf, disp);
 601     } else {
 602       // If 32-bit displacement
 603       if (base == -1) { // Special flag for absolute address
 604         emit_rm(cbuf, 0x0, regenc, 0x5); // *
 605         if (disp_reloc != relocInfo::none) {
 606           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 607         } else {
 608           emit_d32(cbuf, disp);
 609         }
 610       } else {
 611         // Normal base + offset
 612         emit_rm(cbuf, 0x2, regenc, baseenc); // *
 613         if (disp_reloc != relocInfo::none) {
 614           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 615         } else {
 616           emit_d32(cbuf, disp);
 617         }
 618       }
 619     }
 620   } else {
 621     // Else, encode with the SIB byte
 622     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
 623     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
 624       // If no displacement
 625       emit_rm(cbuf, 0x0, regenc, 0x4); // *
 626       emit_rm(cbuf, scale, indexenc, baseenc);
 627     } else {
 628       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
 629         // If 8-bit displacement, mode 0x1
 630         emit_rm(cbuf, 0x1, regenc, 0x4); // *
 631         emit_rm(cbuf, scale, indexenc, baseenc);
 632         emit_d8(cbuf, disp);
 633       } else {
 634         // If 32-bit displacement
 635         if (base == 0x04 ) {
 636           emit_rm(cbuf, 0x2, regenc, 0x4);
 637           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
 638         } else {
 639           emit_rm(cbuf, 0x2, regenc, 0x4);
 640           emit_rm(cbuf, scale, indexenc, baseenc); // *
 641         }
 642         if (disp_reloc != relocInfo::none) {
 643           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 644         } else {
 645           emit_d32(cbuf, disp);
 646         }
 647       }
 648     }
 649   }
 650 }
 651 
 652 // This could be in MacroAssembler but it's fairly C2 specific
 653 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
 654   Label exit;
 655   __ jccb(Assembler::noParity, exit);
 656   __ pushf();
 657   //
 658   // comiss/ucomiss instructions set ZF,PF,CF flags and
 659   // zero OF,AF,SF for NaN values.
 660   // Fixup flags by zeroing ZF,PF so that compare of NaN
 661   // values returns 'less than' result (CF is set).
 662   // Leave the rest of flags unchanged.
 663   //
 664   //    7 6 5 4 3 2 1 0
 665   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
 666   //    0 0 1 0 1 0 1 1   (0x2B)
 667   //
 668   __ andq(Address(rsp, 0), 0xffffff2b);
 669   __ popf();
 670   __ bind(exit);
 671 }
 672 
 673 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
 674   Label done;
 675   __ movl(dst, -1);
 676   __ jcc(Assembler::parity, done);
 677   __ jcc(Assembler::below, done);
 678   __ setb(Assembler::notEqual, dst);
 679   __ movzbl(dst, dst);
 680   __ bind(done);
 681 }
 682 
 683 
 684 //=============================================================================
 685 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
 686 
 687 int Compile::ConstantTable::calculate_table_base_offset() const {
 688   return 0;  // absolute addressing, no offset
 689 }
 690 
 691 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 692 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 693   ShouldNotReachHere();
 694 }
 695 
 696 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 697   // Empty encoding
 698 }
 699 
 700 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 701   return 0;
 702 }
 703 
 704 #ifndef PRODUCT
 705 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 706   st-&gt;print("# MachConstantBaseNode (empty encoding)");
 707 }
 708 #endif
 709 
 710 
 711 //=============================================================================
 712 #ifndef PRODUCT
 713 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 714   Compile* C = ra_-&gt;C;
 715 
 716   int framesize = C-&gt;frame_size_in_bytes();
 717   int bangsize = C-&gt;bang_size_in_bytes();
 718   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 719   // Remove wordSize for return addr which is already pushed.
 720   framesize -= wordSize;
 721 
 722   if (C-&gt;need_stack_bang(bangsize)) {
 723     framesize -= wordSize;
 724     st-&gt;print("# stack bang (%d bytes)", bangsize);
 725     st-&gt;print("\n\t");
 726     st-&gt;print("pushq   rbp\t# Save rbp");
 727     if (framesize) {
 728       st-&gt;print("\n\t");
 729       st-&gt;print("subq    rsp, #%d\t# Create frame",framesize);
 730     }
 731   } else {
 732     st-&gt;print("subq    rsp, #%d\t# Create frame",framesize);
 733     st-&gt;print("\n\t");
 734     framesize -= wordSize;
 735     st-&gt;print("movq    [rsp + #%d], rbp\t# Save rbp",framesize);
 736   }
 737 
 738   if (VerifyStackAtCalls) {
 739     st-&gt;print("\n\t");
 740     framesize -= wordSize;
 741     st-&gt;print("movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check",framesize);
 742 #ifdef ASSERT
 743     st-&gt;print("\n\t");
 744     st-&gt;print("# stack alignment check");
 745 #endif
 746   }
 747   st-&gt;cr();
 748 }
 749 #endif
 750 
 751 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 752   Compile* C = ra_-&gt;C;
 753   MacroAssembler _masm(&amp;cbuf);
 754 
 755   int framesize = C-&gt;frame_size_in_bytes();
 756   int bangsize = C-&gt;bang_size_in_bytes();
 757 
 758   __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, false);
 759 
 760   C-&gt;set_frame_complete(cbuf.insts_size());
 761 
 762   if (C-&gt;has_mach_constant_base_node()) {
 763     // NOTE: We set the table base offset here because users might be
 764     // emitted before MachConstantBaseNode.
 765     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
 766     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 767   }
 768 }
 769 
 770 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
 771 {
 772   return MachNode::size(ra_); // too many variables; just compute it
 773                               // the hard way
 774 }
 775 
 776 int MachPrologNode::reloc() const
 777 {
 778   return 0; // a large enough number
 779 }
 780 
 781 //=============================================================================
 782 #ifndef PRODUCT
 783 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 784 {
 785   Compile* C = ra_-&gt;C;
 786   if (C-&gt;max_vector_size() &gt; 16) {
 787     st-&gt;print("vzeroupper");
 788     st-&gt;cr(); st-&gt;print("\t");
 789   }
 790 
 791   int framesize = C-&gt;frame_size_in_bytes();
 792   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 793   // Remove word for return adr already pushed
 794   // and RBP
 795   framesize -= 2*wordSize;
 796 
 797   if (framesize) {
 798     st-&gt;print_cr("addq    rsp, %d\t# Destroy frame", framesize);
 799     st-&gt;print("\t");
 800   }
 801 
 802   st-&gt;print_cr("popq   rbp");
 803   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 804     st-&gt;print("\t");
 805     if (Assembler::is_polling_page_far()) {
 806       st-&gt;print_cr("movq   rscratch1, #polling_page_address\n\t"
 807                    "testl  rax, [rscratch1]\t"
 808                    "# Safepoint: poll for GC");
 809     } else {
 810       st-&gt;print_cr("testl  rax, [rip + #offset_to_poll_page]\t"
 811                    "# Safepoint: poll for GC");
 812     }
 813   }
 814 }
 815 #endif
 816 
 817 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 818 {
 819   Compile* C = ra_-&gt;C;
 820   if (C-&gt;max_vector_size() &gt; 16) {
 821     // Clear upper bits of YMM registers when current compiled code uses
 822     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 823     MacroAssembler _masm(&amp;cbuf);
 824     __ vzeroupper();
 825   }
 826 
 827   int framesize = C-&gt;frame_size_in_bytes();
 828   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 829   // Remove word for return adr already pushed
 830   // and RBP
 831   framesize -= 2*wordSize;
 832 
 833   // Note that VerifyStackAtCalls' Majik cookie does not change the frame size popped here
 834 
 835   if (framesize) {
 836     emit_opcode(cbuf, Assembler::REX_W);
 837     if (framesize &lt; 0x80) {
 838       emit_opcode(cbuf, 0x83); // addq rsp, #framesize
 839       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
 840       emit_d8(cbuf, framesize);
 841     } else {
 842       emit_opcode(cbuf, 0x81); // addq rsp, #framesize
 843       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
 844       emit_d32(cbuf, framesize);
 845     }
 846   }
 847 
 848   // popq rbp
 849   emit_opcode(cbuf, 0x58 | RBP_enc);
 850 
 851   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 852     MacroAssembler _masm(&amp;cbuf);
 853     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
 854     if (Assembler::is_polling_page_far()) {
 855       __ lea(rscratch1, polling_page);
 856       __ relocate(relocInfo::poll_return_type);
 857       __ testl(rax, Address(rscratch1, 0));
 858     } else {
 859       __ testl(rax, polling_page);
 860     }
 861   }
 862 }
 863 
 864 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
 865 {
 866   return MachNode::size(ra_); // too many variables; just compute it
 867                               // the hard way
 868 }
 869 
 870 int MachEpilogNode::reloc() const
 871 {
 872   return 2; // a large enough number
 873 }
 874 
 875 const Pipeline* MachEpilogNode::pipeline() const
 876 {
 877   return MachNode::pipeline_class();
 878 }
 879 
 880 int MachEpilogNode::safepoint_offset() const
 881 {
 882   return 0;
 883 }
 884 
 885 //=============================================================================
 886 
 887 enum RC {
 888   rc_bad,
 889   rc_int,
 890   rc_float,
 891   rc_stack
 892 };
 893 
 894 static enum RC rc_class(OptoReg::Name reg)
 895 {
 896   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 897 
 898   if (OptoReg::is_stack(reg)) return rc_stack;
 899 
 900   VMReg r = OptoReg::as_VMReg(reg);
 901 
 902   if (r-&gt;is_Register()) return rc_int;
 903 
 904   assert(r-&gt;is_XMMRegister(), "must be");
 905   return rc_float;
 906 }
 907 
 908 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 909 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 910                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 911 
 912 static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
 913                             int stack_offset, int reg, uint ireg, outputStream* st);
 914 
 915 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 916                                       int dst_offset, uint ireg, outputStream* st) {
 917   if (cbuf) {
 918     MacroAssembler _masm(cbuf);
 919     switch (ireg) {
 920     case Op_VecS:
 921       __ movq(Address(rsp, -8), rax);
 922       __ movl(rax, Address(rsp, src_offset));
 923       __ movl(Address(rsp, dst_offset), rax);
 924       __ movq(rax, Address(rsp, -8));
 925       break;
 926     case Op_VecD:
 927       __ pushq(Address(rsp, src_offset));
 928       __ popq (Address(rsp, dst_offset));
 929       break;
 930     case Op_VecX:
 931       __ pushq(Address(rsp, src_offset));
 932       __ popq (Address(rsp, dst_offset));
 933       __ pushq(Address(rsp, src_offset+8));
 934       __ popq (Address(rsp, dst_offset+8));
 935       break;
 936     case Op_VecY:
 937       __ vmovdqu(Address(rsp, -32), xmm0);
 938       __ vmovdqu(xmm0, Address(rsp, src_offset));
 939       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 940       __ vmovdqu(xmm0, Address(rsp, -32));
 941       break;
 942     default:
 943       ShouldNotReachHere();
 944     }
 945 #ifndef PRODUCT
 946   } else {
 947     switch (ireg) {
 948     case Op_VecS:
 949       st-&gt;print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
 950                 "movl    rax, [rsp + #%d]\n\t"
 951                 "movl    [rsp + #%d], rax\n\t"
 952                 "movq    rax, [rsp - #8]",
 953                 src_offset, dst_offset);
 954       break;
 955     case Op_VecD:
 956       st-&gt;print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
 957                 "popq    [rsp + #%d]",
 958                 src_offset, dst_offset);
 959       break;
 960      case Op_VecX:
 961       st-&gt;print("pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t"
 962                 "popq    [rsp + #%d]\n\t"
 963                 "pushq   [rsp + #%d]\n\t"
 964                 "popq    [rsp + #%d]",
 965                 src_offset, dst_offset, src_offset+8, dst_offset+8);
 966       break;
 967     case Op_VecY:
 968       st-&gt;print("vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t"
 969                 "vmovdqu xmm0, [rsp + #%d]\n\t"
 970                 "vmovdqu [rsp + #%d], xmm0\n\t"
 971                 "vmovdqu xmm0, [rsp - #32]",
 972                 src_offset, dst_offset);
 973       break;
 974     default:
 975       ShouldNotReachHere();
 976     }
 977 #endif
 978   }
 979 }
 980 
 981 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
 982                                        PhaseRegAlloc* ra_,
 983                                        bool do_size,
 984                                        outputStream* st) const {
 985   assert(cbuf != NULL || st  != NULL, "sanity");
 986   // Get registers to move
 987   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 988   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 989   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
 990   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
 991 
 992   enum RC src_second_rc = rc_class(src_second);
 993   enum RC src_first_rc = rc_class(src_first);
 994   enum RC dst_second_rc = rc_class(dst_second);
 995   enum RC dst_first_rc = rc_class(dst_first);
 996 
 997   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
 998          "must move at least 1 register" );
 999 
1000   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
1001     // Self copy, no move
1002     return 0;
1003   }
1004   if (bottom_type()-&gt;isa_vect() != NULL) {
1005     uint ireg = ideal_reg();
1006     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), "sanity");
1007     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY), "sanity");
1008     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
1009       // mem -&gt; mem
1010       int src_offset = ra_-&gt;reg2offset(src_first);
1011       int dst_offset = ra_-&gt;reg2offset(dst_first);
1012       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
1013     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
1014       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
1015     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
1016       int stack_offset = ra_-&gt;reg2offset(dst_first);
1017       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
1018     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
1019       int stack_offset = ra_-&gt;reg2offset(src_first);
1020       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
1021     } else {
1022       ShouldNotReachHere();
1023     }
1024     return 0;
1025   }
1026   if (src_first_rc == rc_stack) {
1027     // mem -&gt;
1028     if (dst_first_rc == rc_stack) {
1029       // mem -&gt; mem
1030       assert(src_second != dst_first, "overlap");
1031       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1032           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1033         // 64-bit
1034         int src_offset = ra_-&gt;reg2offset(src_first);
1035         int dst_offset = ra_-&gt;reg2offset(dst_first);
1036         if (cbuf) {
1037           MacroAssembler _masm(cbuf);
1038           __ pushq(Address(rsp, src_offset));
1039           __ popq (Address(rsp, dst_offset));
1040 #ifndef PRODUCT
1041         } else {
1042           st-&gt;print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
1043                     "popq    [rsp + #%d]",
1044                      src_offset, dst_offset);
1045 #endif
1046         }
1047       } else {
1048         // 32-bit
1049         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1050         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1051         // No pushl/popl, so:
1052         int src_offset = ra_-&gt;reg2offset(src_first);
1053         int dst_offset = ra_-&gt;reg2offset(dst_first);
1054         if (cbuf) {
1055           MacroAssembler _masm(cbuf);
1056           __ movq(Address(rsp, -8), rax);
1057           __ movl(rax, Address(rsp, src_offset));
1058           __ movl(Address(rsp, dst_offset), rax);
1059           __ movq(rax, Address(rsp, -8));
1060 #ifndef PRODUCT
1061         } else {
1062           st-&gt;print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
1063                     "movl    rax, [rsp + #%d]\n\t"
1064                     "movl    [rsp + #%d], rax\n\t"
1065                     "movq    rax, [rsp - #8]",
1066                      src_offset, dst_offset);
1067 #endif
1068         }
1069       }
1070       return 0;
1071     } else if (dst_first_rc == rc_int) {
1072       // mem -&gt; gpr
1073       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1074           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1075         // 64-bit
1076         int offset = ra_-&gt;reg2offset(src_first);
1077         if (cbuf) {
1078           MacroAssembler _masm(cbuf);
1079           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1080 #ifndef PRODUCT
1081         } else {
1082           st-&gt;print("movq    %s, [rsp + #%d]\t# spill",
1083                      Matcher::regName[dst_first],
1084                      offset);
1085 #endif
1086         }
1087       } else {
1088         // 32-bit
1089         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1090         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1091         int offset = ra_-&gt;reg2offset(src_first);
1092         if (cbuf) {
1093           MacroAssembler _masm(cbuf);
1094           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1095 #ifndef PRODUCT
1096         } else {
1097           st-&gt;print("movl    %s, [rsp + #%d]\t# spill",
1098                      Matcher::regName[dst_first],
1099                      offset);
1100 #endif
1101         }
1102       }
1103       return 0;
1104     } else if (dst_first_rc == rc_float) {
1105       // mem-&gt; xmm
1106       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1107           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1108         // 64-bit
1109         int offset = ra_-&gt;reg2offset(src_first);
1110         if (cbuf) {
1111           MacroAssembler _masm(cbuf);
1112           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1113 #ifndef PRODUCT
1114         } else {
1115           st-&gt;print("%s  %s, [rsp + #%d]\t# spill",
1116                      UseXmmLoadAndClearUpper ? "movsd " : "movlpd",
1117                      Matcher::regName[dst_first],
1118                      offset);
1119 #endif
1120         }
1121       } else {
1122         // 32-bit
1123         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1124         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1125         int offset = ra_-&gt;reg2offset(src_first);
1126         if (cbuf) {
1127           MacroAssembler _masm(cbuf);
1128           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1129 #ifndef PRODUCT
1130         } else {
1131           st-&gt;print("movss   %s, [rsp + #%d]\t# spill",
1132                      Matcher::regName[dst_first],
1133                      offset);
1134 #endif
1135         }
1136       }
1137       return 0;
1138     }
1139   } else if (src_first_rc == rc_int) {
1140     // gpr -&gt;
1141     if (dst_first_rc == rc_stack) {
1142       // gpr -&gt; mem
1143       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1144           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1145         // 64-bit
1146         int offset = ra_-&gt;reg2offset(dst_first);
1147         if (cbuf) {
1148           MacroAssembler _masm(cbuf);
1149           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
1150 #ifndef PRODUCT
1151         } else {
1152           st-&gt;print("movq    [rsp + #%d], %s\t# spill",
1153                      offset,
1154                      Matcher::regName[src_first]);
1155 #endif
1156         }
1157       } else {
1158         // 32-bit
1159         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1160         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1161         int offset = ra_-&gt;reg2offset(dst_first);
1162         if (cbuf) {
1163           MacroAssembler _masm(cbuf);
1164           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
1165 #ifndef PRODUCT
1166         } else {
1167           st-&gt;print("movl    [rsp + #%d], %s\t# spill",
1168                      offset,
1169                      Matcher::regName[src_first]);
1170 #endif
1171         }
1172       }
1173       return 0;
1174     } else if (dst_first_rc == rc_int) {
1175       // gpr -&gt; gpr
1176       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1177           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1178         // 64-bit
1179         if (cbuf) {
1180           MacroAssembler _masm(cbuf);
1181           __ movq(as_Register(Matcher::_regEncode[dst_first]),
1182                   as_Register(Matcher::_regEncode[src_first]));
1183 #ifndef PRODUCT
1184         } else {
1185           st-&gt;print("movq    %s, %s\t# spill",
1186                      Matcher::regName[dst_first],
1187                      Matcher::regName[src_first]);
1188 #endif
1189         }
1190         return 0;
1191       } else {
1192         // 32-bit
1193         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1194         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1195         if (cbuf) {
1196           MacroAssembler _masm(cbuf);
1197           __ movl(as_Register(Matcher::_regEncode[dst_first]),
1198                   as_Register(Matcher::_regEncode[src_first]));
1199 #ifndef PRODUCT
1200         } else {
1201           st-&gt;print("movl    %s, %s\t# spill",
1202                      Matcher::regName[dst_first],
1203                      Matcher::regName[src_first]);
1204 #endif
1205         }
1206         return 0;
1207       }
1208     } else if (dst_first_rc == rc_float) {
1209       // gpr -&gt; xmm
1210       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1211           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1212         // 64-bit
1213         if (cbuf) {
1214           MacroAssembler _masm(cbuf);
1215           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
1216 #ifndef PRODUCT
1217         } else {
1218           st-&gt;print("movdq   %s, %s\t# spill",
1219                      Matcher::regName[dst_first],
1220                      Matcher::regName[src_first]);
1221 #endif
1222         }
1223       } else {
1224         // 32-bit
1225         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1226         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1227         if (cbuf) {
1228           MacroAssembler _masm(cbuf);
1229           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
1230 #ifndef PRODUCT
1231         } else {
1232           st-&gt;print("movdl   %s, %s\t# spill",
1233                      Matcher::regName[dst_first],
1234                      Matcher::regName[src_first]);
1235 #endif
1236         }
1237       }
1238       return 0;
1239     }
1240   } else if (src_first_rc == rc_float) {
1241     // xmm -&gt;
1242     if (dst_first_rc == rc_stack) {
1243       // xmm -&gt; mem
1244       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1245           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1246         // 64-bit
1247         int offset = ra_-&gt;reg2offset(dst_first);
1248         if (cbuf) {
1249           MacroAssembler _masm(cbuf);
1250           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
1251 #ifndef PRODUCT
1252         } else {
1253           st-&gt;print("movsd   [rsp + #%d], %s\t# spill",
1254                      offset,
1255                      Matcher::regName[src_first]);
1256 #endif
1257         }
1258       } else {
1259         // 32-bit
1260         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1261         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1262         int offset = ra_-&gt;reg2offset(dst_first);
1263         if (cbuf) {
1264           MacroAssembler _masm(cbuf);
1265           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
1266 #ifndef PRODUCT
1267         } else {
1268           st-&gt;print("movss   [rsp + #%d], %s\t# spill",
1269                      offset,
1270                      Matcher::regName[src_first]);
1271 #endif
1272         }
1273       }
1274       return 0;
1275     } else if (dst_first_rc == rc_int) {
1276       // xmm -&gt; gpr
1277       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1278           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1279         // 64-bit
1280         if (cbuf) {
1281           MacroAssembler _masm(cbuf);
1282           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1283 #ifndef PRODUCT
1284         } else {
1285           st-&gt;print("movdq   %s, %s\t# spill",
1286                      Matcher::regName[dst_first],
1287                      Matcher::regName[src_first]);
1288 #endif
1289         }
1290       } else {
1291         // 32-bit
1292         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1293         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1294         if (cbuf) {
1295           MacroAssembler _masm(cbuf);
1296           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1297 #ifndef PRODUCT
1298         } else {
1299           st-&gt;print("movdl   %s, %s\t# spill",
1300                      Matcher::regName[dst_first],
1301                      Matcher::regName[src_first]);
1302 #endif
1303         }
1304       }
1305       return 0;
1306     } else if (dst_first_rc == rc_float) {
1307       // xmm -&gt; xmm
1308       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1309           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1310         // 64-bit
1311         if (cbuf) {
1312           MacroAssembler _masm(cbuf);
1313           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1314 #ifndef PRODUCT
1315         } else {
1316           st-&gt;print("%s  %s, %s\t# spill",
1317                      UseXmmRegToRegMoveAll ? "movapd" : "movsd ",
1318                      Matcher::regName[dst_first],
1319                      Matcher::regName[src_first]);
1320 #endif
1321         }
1322       } else {
1323         // 32-bit
1324         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1325         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1326         if (cbuf) {
1327           MacroAssembler _masm(cbuf);
1328           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1329 #ifndef PRODUCT
1330         } else {
1331           st-&gt;print("%s  %s, %s\t# spill",
1332                      UseXmmRegToRegMoveAll ? "movaps" : "movss ",
1333                      Matcher::regName[dst_first],
1334                      Matcher::regName[src_first]);
1335 #endif
1336         }
1337       }
1338       return 0;
1339     }
1340   }
1341 
1342   assert(0," foo ");
1343   Unimplemented();
1344   return 0;
1345 }
1346 
1347 #ifndef PRODUCT
1348 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
1349   implementation(NULL, ra_, false, st);
1350 }
1351 #endif
1352 
1353 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1354   implementation(&amp;cbuf, ra_, false, NULL);
1355 }
1356 
1357 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
1358   return MachNode::size(ra_);
1359 }
1360 
1361 //=============================================================================
1362 #ifndef PRODUCT
1363 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
1364 {
1365   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1366   int reg = ra_-&gt;get_reg_first(this);
1367   st-&gt;print("leaq    %s, [rsp + #%d]\t# box lock",
1368             Matcher::regName[reg], offset);
1369 }
1370 #endif
1371 
1372 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
1373 {
1374   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1375   int reg = ra_-&gt;get_encode(this);
1376   if (offset &gt;= 0x80) {
1377     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
1378     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
1379     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
1380     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
1381     emit_d32(cbuf, offset);
1382   } else {
1383     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
1384     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
1385     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
1386     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
1387     emit_d8(cbuf, offset);
1388   }
1389 }
1390 
1391 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
1392 {
1393   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1394   return (offset &lt; 0x80) ? 5 : 8; // REX
1395 }
1396 
1397 //=============================================================================
1398 #ifndef PRODUCT
1399 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
1400 {
1401   if (UseCompressedClassPointers) {
1402     st-&gt;print_cr("movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass");
1403     st-&gt;print_cr("\tdecode_klass_not_null rscratch1, rscratch1");
1404     st-&gt;print_cr("\tcmpq    rax, rscratch1\t # Inline cache check");
1405   } else {
1406     st-&gt;print_cr("\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t"
1407                  "# Inline cache check");
1408   }
1409   st-&gt;print_cr("\tjne     SharedRuntime::_ic_miss_stub");
1410   st-&gt;print_cr("\tnop\t# nops to align entry point");
1411 }
1412 #endif
1413 
1414 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
1415 {
1416   MacroAssembler masm(&amp;cbuf);
1417   uint insts_size = cbuf.insts_size();
1418   if (UseCompressedClassPointers) {
1419     masm.load_klass(rscratch1, j_rarg0);
1420     masm.cmpptr(rax, rscratch1);
1421   } else {
1422     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
1423   }
1424 
1425   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
1426 
1427   /* WARNING these NOPs are critical so that verified entry point is properly
1428      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
1429   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
1430   if (OptoBreakpoint) {
1431     // Leave space for int3
1432     nops_cnt -= 1;
1433   }
1434   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
1435   if (nops_cnt &gt; 0)
1436     masm.nop(nops_cnt);
1437 }
1438 
1439 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
1440 {
1441   return MachNode::size(ra_); // too many variables; just compute it
1442                               // the hard way
1443 }
1444  
1445 
1446 //=============================================================================
1447 
1448 int Matcher::regnum_to_fpu_offset(int regnum)
1449 {
1450   return regnum - 32; // The FP registers are in the second chunk
1451 }
1452 
1453 // This is UltraSparc specific, true just means we have fast l2f conversion
1454 const bool Matcher::convL2FSupported(void) {
1455   return true;
1456 }
1457 
1458 // Is this branch offset short enough that a short branch can be used?
1459 //
1460 // NOTE: If the platform does not provide any short branch variants, then
1461 //       this method should return false for offset 0.
1462 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
1463   // The passed offset is relative to address of the branch.
1464   // On 86 a branch displacement is calculated relative to address
1465   // of a next instruction.
1466   offset -= br_size;
1467 
1468   // the short version of jmpConUCF2 contains multiple branches,
1469   // making the reach slightly less
1470   if (rule == jmpConUCF2_rule)
1471     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
1472   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
1473 }
1474 
1475 const bool Matcher::isSimpleConstant64(jlong value) {
1476   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
1477   //return value == (int) value;  // Cf. storeImmL and immL32.
1478 
1479   // Probably always true, even if a temp register is required.
1480   return true;
1481 }
1482 
1483 // The ecx parameter to rep stosq for the ClearArray node is in words.
1484 const bool Matcher::init_array_count_is_in_bytes = false;
1485 
1486 // Threshold size for cleararray.
1487 const int Matcher::init_array_short_size = 8 * BytesPerLong;
1488 
1489 // No additional cost for CMOVL.
1490 const int Matcher::long_cmove_cost() { return 0; }
1491 
1492 // No CMOVF/CMOVD with SSE2
1493 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
1494 
1495 // Does the CPU require late expand (see block.cpp for description of late expand)?
1496 const bool Matcher::require_postalloc_expand = false;
1497 
1498 // Should the Matcher clone shifts on addressing modes, expecting them
1499 // to be subsumed into complex addressing expressions or compute them
1500 // into registers?  True for Intel but false for most RISCs
1501 const bool Matcher::clone_shift_expressions = true;
1502 
1503 // Do we need to mask the count passed to shift instructions or does
1504 // the cpu only look at the lower 5/6 bits anyway?
1505 const bool Matcher::need_masked_shift_count = false;
1506 
1507 bool Matcher::narrow_oop_use_complex_address() {
1508   assert(UseCompressedOops, "only for compressed oops code");
1509   return (LogMinObjAlignmentInBytes &lt;= 3);
1510 }
1511 
1512 bool Matcher::narrow_klass_use_complex_address() {
1513   assert(UseCompressedClassPointers, "only for compressed klass code");
1514   return (LogKlassAlignmentInBytes &lt;= 3);
1515 }
1516 
1517 // Is it better to copy float constants, or load them directly from
1518 // memory?  Intel can load a float constant from a direct address,
1519 // requiring no extra registers.  Most RISCs will have to materialize
1520 // an address into a register first, so they would do better to copy
1521 // the constant from stack.
1522 const bool Matcher::rematerialize_float_constants = true; // XXX
1523 
1524 // If CPU can load and store mis-aligned doubles directly then no
1525 // fixup is needed.  Else we split the double into 2 integer pieces
1526 // and move it piece-by-piece.  Only happens when passing doubles into
1527 // C code as the Java calling convention forces doubles to be aligned.
1528 const bool Matcher::misaligned_doubles_ok = true;
1529 
1530 // No-op on amd64
1531 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
1532 
1533 // Advertise here if the CPU requires explicit rounding operations to
1534 // implement the UseStrictFP mode.
1535 const bool Matcher::strict_fp_requires_explicit_rounding = true;
1536 
1537 // Are floats conerted to double when stored to stack during deoptimization?
1538 // On x64 it is stored without convertion so we can use normal access.
1539 bool Matcher::float_in_double() { return false; }
1540 
1541 // Do ints take an entire long register or just half?
1542 const bool Matcher::int_in_long = true;
1543 
1544 // Return whether or not this register is ever used as an argument.
1545 // This function is used on startup to build the trampoline stubs in
1546 // generateOptoStub.  Registers not mentioned will be killed by the VM
1547 // call in the trampoline, and arguments in those registers not be
1548 // available to the callee.
1549 bool Matcher::can_be_java_arg(int reg)
1550 {
1551   return
1552     reg ==  RDI_num || reg == RDI_H_num ||
1553     reg ==  RSI_num || reg == RSI_H_num ||
1554     reg ==  RDX_num || reg == RDX_H_num ||
1555     reg ==  RCX_num || reg == RCX_H_num ||
1556     reg ==   R8_num || reg ==  R8_H_num ||
1557     reg ==   R9_num || reg ==  R9_H_num ||
1558     reg ==  R12_num || reg == R12_H_num ||
1559     reg == XMM0_num || reg == XMM0b_num ||
1560     reg == XMM1_num || reg == XMM1b_num ||
1561     reg == XMM2_num || reg == XMM2b_num ||
1562     reg == XMM3_num || reg == XMM3b_num ||
1563     reg == XMM4_num || reg == XMM4b_num ||
1564     reg == XMM5_num || reg == XMM5b_num ||
1565     reg == XMM6_num || reg == XMM6b_num ||
1566     reg == XMM7_num || reg == XMM7b_num;
1567 }
1568 
1569 bool Matcher::is_spillable_arg(int reg)
1570 {
1571   return can_be_java_arg(reg);
1572 }
1573 
1574 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
1575   // In 64 bit mode a code which use multiply when
1576   // devisor is constant is faster than hardware
1577   // DIV instruction (it uses MulHiL).
1578   return false;
1579 }
1580 
1581 // Register for DIVI projection of divmodI
1582 RegMask Matcher::divI_proj_mask() {
1583   return INT_RAX_REG_mask();
1584 }
1585 
1586 // Register for MODI projection of divmodI
1587 RegMask Matcher::modI_proj_mask() {
1588   return INT_RDX_REG_mask();
1589 }
1590 
1591 // Register for DIVL projection of divmodL
1592 RegMask Matcher::divL_proj_mask() {
1593   return LONG_RAX_REG_mask();
1594 }
1595 
1596 // Register for MODL projection of divmodL
1597 RegMask Matcher::modL_proj_mask() {
1598   return LONG_RDX_REG_mask();
1599 }
1600 
1601 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
1602   return PTR_RBP_REG_mask();
1603 }
1604 
1605 %}
1606 
1607 //----------ENCODING BLOCK-----------------------------------------------------
1608 // This block specifies the encoding classes used by the compiler to
1609 // output byte streams.  Encoding classes are parameterized macros
1610 // used by Machine Instruction Nodes in order to generate the bit
1611 // encoding of the instruction.  Operands specify their base encoding
1612 // interface with the interface keyword.  There are currently
1613 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
1614 // COND_INTER.  REG_INTER causes an operand to generate a function
1615 // which returns its register number when queried.  CONST_INTER causes
1616 // an operand to generate a function which returns the value of the
1617 // constant when queried.  MEMORY_INTER causes an operand to generate
1618 // four functions which return the Base Register, the Index Register,
1619 // the Scale Value, and the Offset Value of the operand when queried.
1620 // COND_INTER causes an operand to generate six functions which return
1621 // the encoding code (ie - encoding bits for the instruction)
1622 // associated with each basic boolean condition for a conditional
1623 // instruction.
1624 //
1625 // Instructions specify two basic values for encoding.  Again, a
1626 // function is available to check if the constant displacement is an
1627 // oop. They use the ins_encode keyword to specify their encoding
1628 // classes (which must be a sequence of enc_class names, and their
1629 // parameters, specified in the encoding block), and they use the
1630 // opcode keyword to specify, in order, their primary, secondary, and
1631 // tertiary opcode.  Only the opcode sections which a particular
1632 // instruction needs for encoding need to be specified.
1633 encode %{
1634   // Build emit functions for each basic byte or larger field in the
1635   // intel encoding scheme (opcode, rm, sib, immediate), and call them
1636   // from C++ code in the enc_class source block.  Emit functions will
1637   // live in the main source block for now.  In future, we can
1638   // generalize this by adding a syntax that specifies the sizes of
1639   // fields in an order, so that the adlc can build the emit functions
1640   // automagically
1641 
1642   // Emit primary opcode
1643   enc_class OpcP
1644   %{
1645     emit_opcode(cbuf, $primary);
1646   %}
1647 
1648   // Emit secondary opcode
1649   enc_class OpcS
1650   %{
1651     emit_opcode(cbuf, $secondary);
1652   %}
1653 
1654   // Emit tertiary opcode
1655   enc_class OpcT
1656   %{
1657     emit_opcode(cbuf, $tertiary);
1658   %}
1659 
1660   // Emit opcode directly
1661   enc_class Opcode(immI d8)
1662   %{
1663     emit_opcode(cbuf, $d8$$constant);
1664   %}
1665 
1666   // Emit size prefix
1667   enc_class SizePrefix
1668   %{
1669     emit_opcode(cbuf, 0x66);
1670   %}
1671 
1672   enc_class reg(rRegI reg)
1673   %{
1674     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
1675   %}
1676 
1677   enc_class reg_reg(rRegI dst, rRegI src)
1678   %{
1679     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
1680   %}
1681 
1682   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
1683   %{
1684     emit_opcode(cbuf, $opcode$$constant);
1685     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
1686   %}
1687 
1688   enc_class cdql_enc(no_rax_rdx_RegI div)
1689   %{
1690     // Full implementation of Java idiv and irem; checks for
1691     // special case as described in JVM spec., p.243 &amp; p.271.
1692     //
1693     //         normal case                           special case
1694     //
1695     // input : rax: dividend                         min_int
1696     //         reg: divisor                          -1
1697     //
1698     // output: rax: quotient  (= rax idiv reg)       min_int
1699     //         rdx: remainder (= rax irem reg)       0
1700     //
1701     //  Code sequnce:
1702     //
1703     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
1704     //    5:   75 07/08                jne    e &lt;normal&gt;
1705     //    7:   33 d2                   xor    %edx,%edx
1706     //  [div &gt;= 8 -&gt; offset + 1]
1707     //  [REX_B]
1708     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
1709     //    c:   74 03/04                je     11 &lt;done&gt;
1710     // 000000000000000e &lt;normal&gt;:
1711     //    e:   99                      cltd
1712     //  [div &gt;= 8 -&gt; offset + 1]
1713     //  [REX_B]
1714     //    f:   f7 f9                   idiv   $div
1715     // 0000000000000011 &lt;done&gt;:
1716 
1717     // cmp    $0x80000000,%eax
1718     emit_opcode(cbuf, 0x3d);
1719     emit_d8(cbuf, 0x00);
1720     emit_d8(cbuf, 0x00);
1721     emit_d8(cbuf, 0x00);
1722     emit_d8(cbuf, 0x80);
1723 
1724     // jne    e &lt;normal&gt;
1725     emit_opcode(cbuf, 0x75);
1726     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
1727 
1728     // xor    %edx,%edx
1729     emit_opcode(cbuf, 0x33);
1730     emit_d8(cbuf, 0xD2);
1731 
1732     // cmp    $0xffffffffffffffff,%ecx
1733     if ($div$$reg &gt;= 8) {
1734       emit_opcode(cbuf, Assembler::REX_B);
1735     }
1736     emit_opcode(cbuf, 0x83);
1737     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
1738     emit_d8(cbuf, 0xFF);
1739 
1740     // je     11 &lt;done&gt;
1741     emit_opcode(cbuf, 0x74);
1742     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
1743 
1744     // &lt;normal&gt;
1745     // cltd
1746     emit_opcode(cbuf, 0x99);
1747 
1748     // idivl (note: must be emitted by the user of this rule)
1749     // &lt;done&gt;
1750   %}
1751 
1752   enc_class cdqq_enc(no_rax_rdx_RegL div)
1753   %{
1754     // Full implementation of Java ldiv and lrem; checks for
1755     // special case as described in JVM spec., p.243 &amp; p.271.
1756     //
1757     //         normal case                           special case
1758     //
1759     // input : rax: dividend                         min_long
1760     //         reg: divisor                          -1
1761     //
1762     // output: rax: quotient  (= rax idiv reg)       min_long
1763     //         rdx: remainder (= rax irem reg)       0
1764     //
1765     //  Code sequnce:
1766     //
1767     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
1768     //    7:   00 00 80
1769     //    a:   48 39 d0                cmp    %rdx,%rax
1770     //    d:   75 08                   jne    17 &lt;normal&gt;
1771     //    f:   33 d2                   xor    %edx,%edx
1772     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
1773     //   15:   74 05                   je     1c &lt;done&gt;
1774     // 0000000000000017 &lt;normal&gt;:
1775     //   17:   48 99                   cqto
1776     //   19:   48 f7 f9                idiv   $div
1777     // 000000000000001c &lt;done&gt;:
1778 
1779     // mov    $0x8000000000000000,%rdx
1780     emit_opcode(cbuf, Assembler::REX_W);
1781     emit_opcode(cbuf, 0xBA);
1782     emit_d8(cbuf, 0x00);
1783     emit_d8(cbuf, 0x00);
1784     emit_d8(cbuf, 0x00);
1785     emit_d8(cbuf, 0x00);
1786     emit_d8(cbuf, 0x00);
1787     emit_d8(cbuf, 0x00);
1788     emit_d8(cbuf, 0x00);
1789     emit_d8(cbuf, 0x80);
1790 
1791     // cmp    %rdx,%rax
1792     emit_opcode(cbuf, Assembler::REX_W);
1793     emit_opcode(cbuf, 0x39);
1794     emit_d8(cbuf, 0xD0);
1795 
1796     // jne    17 &lt;normal&gt;
1797     emit_opcode(cbuf, 0x75);
1798     emit_d8(cbuf, 0x08);
1799 
1800     // xor    %edx,%edx
1801     emit_opcode(cbuf, 0x33);
1802     emit_d8(cbuf, 0xD2);
1803 
1804     // cmp    $0xffffffffffffffff,$div
1805     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
1806     emit_opcode(cbuf, 0x83);
1807     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
1808     emit_d8(cbuf, 0xFF);
1809 
1810     // je     1e &lt;done&gt;
1811     emit_opcode(cbuf, 0x74);
1812     emit_d8(cbuf, 0x05);
1813 
1814     // &lt;normal&gt;
1815     // cqto
1816     emit_opcode(cbuf, Assembler::REX_W);
1817     emit_opcode(cbuf, 0x99);
1818 
1819     // idivq (note: must be emitted by the user of this rule)
1820     // &lt;done&gt;
1821   %}
1822 
1823   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
1824   enc_class OpcSE(immI imm)
1825   %{
1826     // Emit primary opcode and set sign-extend bit
1827     // Check for 8-bit immediate, and set sign extend bit in opcode
1828     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
1829       emit_opcode(cbuf, $primary | 0x02);
1830     } else {
1831       // 32-bit immediate
1832       emit_opcode(cbuf, $primary);
1833     }
1834   %}
1835 
1836   enc_class OpcSErm(rRegI dst, immI imm)
1837   %{
1838     // OpcSEr/m
1839     int dstenc = $dst$$reg;
1840     if (dstenc &gt;= 8) {
1841       emit_opcode(cbuf, Assembler::REX_B);
1842       dstenc -= 8;
1843     }
1844     // Emit primary opcode and set sign-extend bit
1845     // Check for 8-bit immediate, and set sign extend bit in opcode
1846     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
1847       emit_opcode(cbuf, $primary | 0x02);
1848     } else {
1849       // 32-bit immediate
1850       emit_opcode(cbuf, $primary);
1851     }
1852     // Emit r/m byte with secondary opcode, after primary opcode.
1853     emit_rm(cbuf, 0x3, $secondary, dstenc);
1854   %}
1855 
1856   enc_class OpcSErm_wide(rRegL dst, immI imm)
1857   %{
1858     // OpcSEr/m
1859     int dstenc = $dst$$reg;
1860     if (dstenc &lt; 8) {
1861       emit_opcode(cbuf, Assembler::REX_W);
1862     } else {
1863       emit_opcode(cbuf, Assembler::REX_WB);
1864       dstenc -= 8;
1865     }
1866     // Emit primary opcode and set sign-extend bit
1867     // Check for 8-bit immediate, and set sign extend bit in opcode
1868     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
1869       emit_opcode(cbuf, $primary | 0x02);
1870     } else {
1871       // 32-bit immediate
1872       emit_opcode(cbuf, $primary);
1873     }
1874     // Emit r/m byte with secondary opcode, after primary opcode.
1875     emit_rm(cbuf, 0x3, $secondary, dstenc);
1876   %}
1877 
1878   enc_class Con8or32(immI imm)
1879   %{
1880     // Check for 8-bit immediate, and set sign extend bit in opcode
1881     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
1882       $$$emit8$imm$$constant;
1883     } else {
1884       // 32-bit immediate
1885       $$$emit32$imm$$constant;
1886     }
1887   %}
1888 
1889   enc_class opc2_reg(rRegI dst)
1890   %{
1891     // BSWAP
1892     emit_cc(cbuf, $secondary, $dst$$reg);
1893   %}
1894 
1895   enc_class opc3_reg(rRegI dst)
1896   %{
1897     // BSWAP
1898     emit_cc(cbuf, $tertiary, $dst$$reg);
1899   %}
1900 
1901   enc_class reg_opc(rRegI div)
1902   %{
1903     // INC, DEC, IDIV, IMOD, JMP indirect, ...
1904     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
1905   %}
1906 
1907   enc_class enc_cmov(cmpOp cop)
1908   %{
1909     // CMOV
1910     $$$emit8$primary;
1911     emit_cc(cbuf, $secondary, $cop$$cmpcode);
1912   %}
1913 
1914   enc_class enc_PartialSubtypeCheck()
1915   %{
1916     Register Rrdi = as_Register(RDI_enc); // result register
1917     Register Rrax = as_Register(RAX_enc); // super class
1918     Register Rrcx = as_Register(RCX_enc); // killed
1919     Register Rrsi = as_Register(RSI_enc); // sub class
1920     Label miss;
1921     const bool set_cond_codes = true;
1922 
1923     MacroAssembler _masm(&amp;cbuf);
1924     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
1925                                      NULL, &amp;miss,
1926                                      /*set_cond_codes:*/ true);
1927     if ($primary) {
1928       __ xorptr(Rrdi, Rrdi);
1929     }
1930     __ bind(miss);
1931   %}
1932 
1933   enc_class clear_avx %{
1934     debug_only(int off0 = cbuf.insts_size());
1935     if (ra_-&gt;C-&gt;max_vector_size() &gt; 16) {
1936       // Clear upper bits of YMM registers when current compiled code uses
1937       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
1938       MacroAssembler _masm(&amp;cbuf);
1939       __ vzeroupper();
1940     }
1941     debug_only(int off1 = cbuf.insts_size());
1942     assert(off1 - off0 == clear_avx_size(), "correct size prediction");
1943   %}
1944 
1945   enc_class Java_To_Runtime(method meth) %{
1946     // No relocation needed
1947     MacroAssembler _masm(&amp;cbuf);
1948     __ mov64(r10, (int64_t) $meth$$method);
1949     __ call(r10);
1950   %}
1951 
1952   enc_class Java_To_Interpreter(method meth)
1953   %{
1954     // CALL Java_To_Interpreter
1955     // This is the instruction starting address for relocation info.
1956     cbuf.set_insts_mark();
1957     $$$emit8$primary;
1958     // CALL directly to the runtime
1959     emit_d32_reloc(cbuf,
1960                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
1961                    runtime_call_Relocation::spec(),
1962                    RELOC_DISP32);
1963   %}
1964 
1965   enc_class Java_Static_Call(method meth)
1966   %{
1967     // JAVA STATIC CALL
1968     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
1969     // determine who we intended to call.
1970     cbuf.set_insts_mark();
1971     $$$emit8$primary;
1972 
1973     if (!_method) {
1974       emit_d32_reloc(cbuf,
1975                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
1976                      runtime_call_Relocation::spec(),
1977                      RELOC_DISP32);
1978     } else if (_optimized_virtual) {
1979       emit_d32_reloc(cbuf,
1980                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
1981                      opt_virtual_call_Relocation::spec(),
1982                      RELOC_DISP32);
1983     } else {
1984       emit_d32_reloc(cbuf,
1985                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
1986                      static_call_Relocation::spec(),
1987                      RELOC_DISP32);
1988     }
1989     if (_method) {
1990       // Emit stub for static call.
1991       CompiledStaticCall::emit_to_interp_stub(cbuf);
1992     }
1993   %}
1994 
1995   enc_class Java_Dynamic_Call(method meth) %{
1996     MacroAssembler _masm(&amp;cbuf);
1997     __ ic_call((address)$meth$$method);
1998   %}
1999 
2000   enc_class Java_Compiled_Call(method meth)
2001   %{
2002     // JAVA COMPILED CALL
2003     int disp = in_bytes(Method:: from_compiled_offset());
2004 
2005     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
2006     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, "compiled_code_offset isn't small");
2007 
2008     // callq *disp(%rax)
2009     cbuf.set_insts_mark();
2010     $$$emit8$primary;
2011     if (disp &lt; 0x80) {
2012       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
2013       emit_d8(cbuf, disp); // Displacement
2014     } else {
2015       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
2016       emit_d32(cbuf, disp); // Displacement
2017     }
2018   %}
2019 
2020   enc_class reg_opc_imm(rRegI dst, immI8 shift)
2021   %{
2022     // SAL, SAR, SHR
2023     int dstenc = $dst$$reg;
2024     if (dstenc &gt;= 8) {
2025       emit_opcode(cbuf, Assembler::REX_B);
2026       dstenc -= 8;
2027     }
2028     $$$emit8$primary;
2029     emit_rm(cbuf, 0x3, $secondary, dstenc);
2030     $$$emit8$shift$$constant;
2031   %}
2032 
2033   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
2034   %{
2035     // SAL, SAR, SHR
2036     int dstenc = $dst$$reg;
2037     if (dstenc &lt; 8) {
2038       emit_opcode(cbuf, Assembler::REX_W);
2039     } else {
2040       emit_opcode(cbuf, Assembler::REX_WB);
2041       dstenc -= 8;
2042     }
2043     $$$emit8$primary;
2044     emit_rm(cbuf, 0x3, $secondary, dstenc);
2045     $$$emit8$shift$$constant;
2046   %}
2047 
2048   enc_class load_immI(rRegI dst, immI src)
2049   %{
2050     int dstenc = $dst$$reg;
2051     if (dstenc &gt;= 8) {
2052       emit_opcode(cbuf, Assembler::REX_B);
2053       dstenc -= 8;
2054     }
2055     emit_opcode(cbuf, 0xB8 | dstenc);
2056     $$$emit32$src$$constant;
2057   %}
2058 
2059   enc_class load_immL(rRegL dst, immL src)
2060   %{
2061     int dstenc = $dst$$reg;
2062     if (dstenc &lt; 8) {
2063       emit_opcode(cbuf, Assembler::REX_W);
2064     } else {
2065       emit_opcode(cbuf, Assembler::REX_WB);
2066       dstenc -= 8;
2067     }
2068     emit_opcode(cbuf, 0xB8 | dstenc);
2069     emit_d64(cbuf, $src$$constant);
2070   %}
2071 
2072   enc_class load_immUL32(rRegL dst, immUL32 src)
2073   %{
2074     // same as load_immI, but this time we care about zeroes in the high word
2075     int dstenc = $dst$$reg;
2076     if (dstenc &gt;= 8) {
2077       emit_opcode(cbuf, Assembler::REX_B);
2078       dstenc -= 8;
2079     }
2080     emit_opcode(cbuf, 0xB8 | dstenc);
2081     $$$emit32$src$$constant;
2082   %}
2083 
2084   enc_class load_immL32(rRegL dst, immL32 src)
2085   %{
2086     int dstenc = $dst$$reg;
2087     if (dstenc &lt; 8) {
2088       emit_opcode(cbuf, Assembler::REX_W);
2089     } else {
2090       emit_opcode(cbuf, Assembler::REX_WB);
2091       dstenc -= 8;
2092     }
2093     emit_opcode(cbuf, 0xC7);
2094     emit_rm(cbuf, 0x03, 0x00, dstenc);
2095     $$$emit32$src$$constant;
2096   %}
2097 
2098   enc_class load_immP31(rRegP dst, immP32 src)
2099   %{
2100     // same as load_immI, but this time we care about zeroes in the high word
2101     int dstenc = $dst$$reg;
2102     if (dstenc &gt;= 8) {
2103       emit_opcode(cbuf, Assembler::REX_B);
2104       dstenc -= 8;
2105     }
2106     emit_opcode(cbuf, 0xB8 | dstenc);
2107     $$$emit32$src$$constant;
2108   %}
2109 
2110   enc_class load_immP(rRegP dst, immP src)
2111   %{
2112     int dstenc = $dst$$reg;
2113     if (dstenc &lt; 8) {
2114       emit_opcode(cbuf, Assembler::REX_W);
2115     } else {
2116       emit_opcode(cbuf, Assembler::REX_WB);
2117       dstenc -= 8;
2118     }
2119     emit_opcode(cbuf, 0xB8 | dstenc);
2120     // This next line should be generated from ADLC
2121     if ($src-&gt;constant_reloc() != relocInfo::none) {
2122       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
2123     } else {
2124       emit_d64(cbuf, $src$$constant);
2125     }
2126   %}
2127 
2128   enc_class Con32(immI src)
2129   %{
2130     // Output immediate
2131     $$$emit32$src$$constant;
2132   %}
2133 
2134   enc_class Con32F_as_bits(immF src)
2135   %{
2136     // Output Float immediate bits
2137     jfloat jf = $src$$constant;
2138     jint jf_as_bits = jint_cast(jf);
2139     emit_d32(cbuf, jf_as_bits);
2140   %}
2141 
2142   enc_class Con16(immI src)
2143   %{
2144     // Output immediate
2145     $$$emit16$src$$constant;
2146   %}
2147 
2148   // How is this different from Con32??? XXX
2149   enc_class Con_d32(immI src)
2150   %{
2151     emit_d32(cbuf,$src$$constant);
2152   %}
2153 
2154   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
2155     // Output immediate memory reference
2156     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
2157     emit_d32(cbuf, 0x00);
2158   %}
2159 
2160   enc_class lock_prefix()
2161   %{
2162     if (os::is_MP()) {
2163       emit_opcode(cbuf, 0xF0); // lock
2164     }
2165   %}
2166 
2167   enc_class REX_mem(memory mem)
2168   %{
2169     if ($mem$$base &gt;= 8) {
2170       if ($mem$$index &lt; 8) {
2171         emit_opcode(cbuf, Assembler::REX_B);
2172       } else {
2173         emit_opcode(cbuf, Assembler::REX_XB);
2174       }
2175     } else {
2176       if ($mem$$index &gt;= 8) {
2177         emit_opcode(cbuf, Assembler::REX_X);
2178       }
2179     }
2180   %}
2181 
2182   enc_class REX_mem_wide(memory mem)
2183   %{
2184     if ($mem$$base &gt;= 8) {
2185       if ($mem$$index &lt; 8) {
2186         emit_opcode(cbuf, Assembler::REX_WB);
2187       } else {
2188         emit_opcode(cbuf, Assembler::REX_WXB);
2189       }
2190     } else {
2191       if ($mem$$index &lt; 8) {
2192         emit_opcode(cbuf, Assembler::REX_W);
2193       } else {
2194         emit_opcode(cbuf, Assembler::REX_WX);
2195       }
2196     }
2197   %}
2198 
2199   // for byte regs
2200   enc_class REX_breg(rRegI reg)
2201   %{
2202     if ($reg$$reg &gt;= 4) {
2203       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
2204     }
2205   %}
2206 
2207   // for byte regs
2208   enc_class REX_reg_breg(rRegI dst, rRegI src)
2209   %{
2210     if ($dst$$reg &lt; 8) {
2211       if ($src$$reg &gt;= 4) {
2212         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
2213       }
2214     } else {
2215       if ($src$$reg &lt; 8) {
2216         emit_opcode(cbuf, Assembler::REX_R);
2217       } else {
2218         emit_opcode(cbuf, Assembler::REX_RB);
2219       }
2220     }
2221   %}
2222 
2223   // for byte regs
2224   enc_class REX_breg_mem(rRegI reg, memory mem)
2225   %{
2226     if ($reg$$reg &lt; 8) {
2227       if ($mem$$base &lt; 8) {
2228         if ($mem$$index &gt;= 8) {
2229           emit_opcode(cbuf, Assembler::REX_X);
2230         } else if ($reg$$reg &gt;= 4) {
2231           emit_opcode(cbuf, Assembler::REX);
2232         }
2233       } else {
2234         if ($mem$$index &lt; 8) {
2235           emit_opcode(cbuf, Assembler::REX_B);
2236         } else {
2237           emit_opcode(cbuf, Assembler::REX_XB);
2238         }
2239       }
2240     } else {
2241       if ($mem$$base &lt; 8) {
2242         if ($mem$$index &lt; 8) {
2243           emit_opcode(cbuf, Assembler::REX_R);
2244         } else {
2245           emit_opcode(cbuf, Assembler::REX_RX);
2246         }
2247       } else {
2248         if ($mem$$index &lt; 8) {
2249           emit_opcode(cbuf, Assembler::REX_RB);
2250         } else {
2251           emit_opcode(cbuf, Assembler::REX_RXB);
2252         }
2253       }
2254     }
2255   %}
2256 
2257   enc_class REX_reg(rRegI reg)
2258   %{
2259     if ($reg$$reg &gt;= 8) {
2260       emit_opcode(cbuf, Assembler::REX_B);
2261     }
2262   %}
2263 
2264   enc_class REX_reg_wide(rRegI reg)
2265   %{
2266     if ($reg$$reg &lt; 8) {
2267       emit_opcode(cbuf, Assembler::REX_W);
2268     } else {
2269       emit_opcode(cbuf, Assembler::REX_WB);
2270     }
2271   %}
2272 
2273   enc_class REX_reg_reg(rRegI dst, rRegI src)
2274   %{
2275     if ($dst$$reg &lt; 8) {
2276       if ($src$$reg &gt;= 8) {
2277         emit_opcode(cbuf, Assembler::REX_B);
2278       }
2279     } else {
2280       if ($src$$reg &lt; 8) {
2281         emit_opcode(cbuf, Assembler::REX_R);
2282       } else {
2283         emit_opcode(cbuf, Assembler::REX_RB);
2284       }
2285     }
2286   %}
2287 
2288   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
2289   %{
2290     if ($dst$$reg &lt; 8) {
2291       if ($src$$reg &lt; 8) {
2292         emit_opcode(cbuf, Assembler::REX_W);
2293       } else {
2294         emit_opcode(cbuf, Assembler::REX_WB);
2295       }
2296     } else {
2297       if ($src$$reg &lt; 8) {
2298         emit_opcode(cbuf, Assembler::REX_WR);
2299       } else {
2300         emit_opcode(cbuf, Assembler::REX_WRB);
2301       }
2302     }
2303   %}
2304 
2305   enc_class REX_reg_mem(rRegI reg, memory mem)
2306   %{
2307     if ($reg$$reg &lt; 8) {
2308       if ($mem$$base &lt; 8) {
2309         if ($mem$$index &gt;= 8) {
2310           emit_opcode(cbuf, Assembler::REX_X);
2311         }
2312       } else {
2313         if ($mem$$index &lt; 8) {
2314           emit_opcode(cbuf, Assembler::REX_B);
2315         } else {
2316           emit_opcode(cbuf, Assembler::REX_XB);
2317         }
2318       }
2319     } else {
2320       if ($mem$$base &lt; 8) {
2321         if ($mem$$index &lt; 8) {
2322           emit_opcode(cbuf, Assembler::REX_R);
2323         } else {
2324           emit_opcode(cbuf, Assembler::REX_RX);
2325         }
2326       } else {
2327         if ($mem$$index &lt; 8) {
2328           emit_opcode(cbuf, Assembler::REX_RB);
2329         } else {
2330           emit_opcode(cbuf, Assembler::REX_RXB);
2331         }
2332       }
2333     }
2334   %}
2335 
2336   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
2337   %{
2338     if ($reg$$reg &lt; 8) {
2339       if ($mem$$base &lt; 8) {
2340         if ($mem$$index &lt; 8) {
2341           emit_opcode(cbuf, Assembler::REX_W);
2342         } else {
2343           emit_opcode(cbuf, Assembler::REX_WX);
2344         }
2345       } else {
2346         if ($mem$$index &lt; 8) {
2347           emit_opcode(cbuf, Assembler::REX_WB);
2348         } else {
2349           emit_opcode(cbuf, Assembler::REX_WXB);
2350         }
2351       }
2352     } else {
2353       if ($mem$$base &lt; 8) {
2354         if ($mem$$index &lt; 8) {
2355           emit_opcode(cbuf, Assembler::REX_WR);
2356         } else {
2357           emit_opcode(cbuf, Assembler::REX_WRX);
2358         }
2359       } else {
2360         if ($mem$$index &lt; 8) {
2361           emit_opcode(cbuf, Assembler::REX_WRB);
2362         } else {
2363           emit_opcode(cbuf, Assembler::REX_WRXB);
2364         }
2365       }
2366     }
2367   %}
2368 
2369   enc_class reg_mem(rRegI ereg, memory mem)
2370   %{
2371     // High registers handle in encode_RegMem
2372     int reg = $ereg$$reg;
2373     int base = $mem$$base;
2374     int index = $mem$$index;
2375     int scale = $mem$$scale;
2376     int disp = $mem$$disp;
2377     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
2378 
2379     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
2380   %}
2381 
2382   enc_class RM_opc_mem(immI rm_opcode, memory mem)
2383   %{
2384     int rm_byte_opcode = $rm_opcode$$constant;
2385 
2386     // High registers handle in encode_RegMem
2387     int base = $mem$$base;
2388     int index = $mem$$index;
2389     int scale = $mem$$scale;
2390     int displace = $mem$$disp;
2391 
2392     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
2393                                             // working with static
2394                                             // globals
2395     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
2396                   disp_reloc);
2397   %}
2398 
2399   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
2400   %{
2401     int reg_encoding = $dst$$reg;
2402     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
2403     int index        = 0x04;            // 0x04 indicates no index
2404     int scale        = 0x00;            // 0x00 indicates no scale
2405     int displace     = $src1$$constant; // 0x00 indicates no displacement
2406     relocInfo::relocType disp_reloc = relocInfo::none;
2407     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
2408                   disp_reloc);
2409   %}
2410 
2411   enc_class neg_reg(rRegI dst)
2412   %{
2413     int dstenc = $dst$$reg;
2414     if (dstenc &gt;= 8) {
2415       emit_opcode(cbuf, Assembler::REX_B);
2416       dstenc -= 8;
2417     }
2418     // NEG $dst
2419     emit_opcode(cbuf, 0xF7);
2420     emit_rm(cbuf, 0x3, 0x03, dstenc);
2421   %}
2422 
2423   enc_class neg_reg_wide(rRegI dst)
2424   %{
2425     int dstenc = $dst$$reg;
2426     if (dstenc &lt; 8) {
2427       emit_opcode(cbuf, Assembler::REX_W);
2428     } else {
2429       emit_opcode(cbuf, Assembler::REX_WB);
2430       dstenc -= 8;
2431     }
2432     // NEG $dst
2433     emit_opcode(cbuf, 0xF7);
2434     emit_rm(cbuf, 0x3, 0x03, dstenc);
2435   %}
2436 
2437   enc_class setLT_reg(rRegI dst)
2438   %{
2439     int dstenc = $dst$$reg;
2440     if (dstenc &gt;= 8) {
2441       emit_opcode(cbuf, Assembler::REX_B);
2442       dstenc -= 8;
2443     } else if (dstenc &gt;= 4) {
2444       emit_opcode(cbuf, Assembler::REX);
2445     }
2446     // SETLT $dst
2447     emit_opcode(cbuf, 0x0F);
2448     emit_opcode(cbuf, 0x9C);
2449     emit_rm(cbuf, 0x3, 0x0, dstenc);
2450   %}
2451 
2452   enc_class setNZ_reg(rRegI dst)
2453   %{
2454     int dstenc = $dst$$reg;
2455     if (dstenc &gt;= 8) {
2456       emit_opcode(cbuf, Assembler::REX_B);
2457       dstenc -= 8;
2458     } else if (dstenc &gt;= 4) {
2459       emit_opcode(cbuf, Assembler::REX);
2460     }
2461     // SETNZ $dst
2462     emit_opcode(cbuf, 0x0F);
2463     emit_opcode(cbuf, 0x95);
2464     emit_rm(cbuf, 0x3, 0x0, dstenc);
2465   %}
2466 
2467 
2468   // Compare the lonogs and set -1, 0, or 1 into dst
2469   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
2470   %{
2471     int src1enc = $src1$$reg;
2472     int src2enc = $src2$$reg;
2473     int dstenc = $dst$$reg;
2474 
2475     // cmpq $src1, $src2
2476     if (src1enc &lt; 8) {
2477       if (src2enc &lt; 8) {
2478         emit_opcode(cbuf, Assembler::REX_W);
2479       } else {
2480         emit_opcode(cbuf, Assembler::REX_WB);
2481       }
2482     } else {
2483       if (src2enc &lt; 8) {
2484         emit_opcode(cbuf, Assembler::REX_WR);
2485       } else {
2486         emit_opcode(cbuf, Assembler::REX_WRB);
2487       }
2488     }
2489     emit_opcode(cbuf, 0x3B);
2490     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
2491 
2492     // movl $dst, -1
2493     if (dstenc &gt;= 8) {
2494       emit_opcode(cbuf, Assembler::REX_B);
2495     }
2496     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
2497     emit_d32(cbuf, -1);
2498 
2499     // jl,s done
2500     emit_opcode(cbuf, 0x7C);
2501     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
2502 
2503     // setne $dst
2504     if (dstenc &gt;= 4) {
2505       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
2506     }
2507     emit_opcode(cbuf, 0x0F);
2508     emit_opcode(cbuf, 0x95);
2509     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
2510 
2511     // movzbl $dst, $dst
2512     if (dstenc &gt;= 4) {
2513       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
2514     }
2515     emit_opcode(cbuf, 0x0F);
2516     emit_opcode(cbuf, 0xB6);
2517     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
2518   %}
2519 
2520   enc_class Push_ResultXD(regD dst) %{
2521     MacroAssembler _masm(&amp;cbuf);
2522     __ fstp_d(Address(rsp, 0));
2523     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
2524     __ addptr(rsp, 8);
2525   %}
2526 
2527   enc_class Push_SrcXD(regD src) %{
2528     MacroAssembler _masm(&amp;cbuf);
2529     __ subptr(rsp, 8);
2530     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
2531     __ fld_d(Address(rsp, 0));
2532   %}
2533 
2534 
2535   enc_class enc_rethrow()
2536   %{
2537     cbuf.set_insts_mark();
2538     emit_opcode(cbuf, 0xE9); // jmp entry
2539     emit_d32_reloc(cbuf,
2540                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
2541                    runtime_call_Relocation::spec(),
2542                    RELOC_DISP32);
2543   %}
2544 
2545 %}
2546 
2547 
2548 
2549 //----------FRAME--------------------------------------------------------------
2550 // Definition of frame structure and management information.
2551 //
2552 //  S T A C K   L A Y O U T    Allocators stack-slot number
2553 //                             |   (to get allocators register number
2554 //  G  Owned by    |        |  v    add OptoReg::stack0())
2555 //  r   CALLER     |        |
2556 //  o     |        +--------+      pad to even-align allocators stack-slot
2557 //  w     V        |  pad0  |        numbers; owned by CALLER
2558 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
2559 //  h     ^        |   in   |  5
2560 //        |        |  args  |  4   Holes in incoming args owned by SELF
2561 //  |     |        |        |  3
2562 //  |     |        +--------+
2563 //  V     |        | old out|      Empty on Intel, window on Sparc
2564 //        |    old |preserve|      Must be even aligned.
2565 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
2566 //        |        |   in   |  3   area for Intel ret address
2567 //     Owned by    |preserve|      Empty on Sparc.
2568 //       SELF      +--------+
2569 //        |        |  pad2  |  2   pad to align old SP
2570 //        |        +--------+  1
2571 //        |        | locks  |  0
2572 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
2573 //        |        |  pad1  | 11   pad to align new SP
2574 //        |        +--------+
2575 //        |        |        | 10
2576 //        |        | spills |  9   spills
2577 //        V        |        |  8   (pad0 slot for callee)
2578 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
2579 //        ^        |  out   |  7
2580 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
2581 //     Owned by    +--------+
2582 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
2583 //        |    new |preserve|      Must be even-aligned.
2584 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
2585 //        |        |        |
2586 //
2587 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
2588 //         known from SELF's arguments and the Java calling convention.
2589 //         Region 6-7 is determined per call site.
2590 // Note 2: If the calling convention leaves holes in the incoming argument
2591 //         area, those holes are owned by SELF.  Holes in the outgoing area
2592 //         are owned by the CALLEE.  Holes should not be nessecary in the
2593 //         incoming area, as the Java calling convention is completely under
2594 //         the control of the AD file.  Doubles can be sorted and packed to
2595 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
2596 //         varargs C calling conventions.
2597 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
2598 //         even aligned with pad0 as needed.
2599 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
2600 //         region 6-11 is even aligned; it may be padded out more so that
2601 //         the region from SP to FP meets the minimum stack alignment.
2602 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
2603 //         alignment.  Region 11, pad1, may be dynamically extended so that
2604 //         SP meets the minimum alignment.
2605 
2606 frame
2607 %{
2608   // What direction does stack grow in (assumed to be same for C &amp; Java)
2609   stack_direction(TOWARDS_LOW);
2610 
2611   // These three registers define part of the calling convention
2612   // between compiled code and the interpreter.
2613   inline_cache_reg(RAX);                // Inline Cache Register
2614   interpreter_method_oop_reg(RBX);      // Method Oop Register when
2615                                         // calling interpreter
2616 
2617   // Optional: name the operand used by cisc-spilling to access
2618   // [stack_pointer + offset]
2619   cisc_spilling_operand_name(indOffset32);
2620 
2621   // Number of stack slots consumed by locking an object
2622   sync_stack_slots(2);
2623 
2624   // Compiled code's Frame Pointer
2625   frame_pointer(RSP);
2626 
2627   // Interpreter stores its frame pointer in a register which is
2628   // stored to the stack by I2CAdaptors.
2629   // I2CAdaptors convert from interpreted java to compiled java.
2630   interpreter_frame_pointer(RBP);
2631 
2632   // Stack alignment requirement
2633   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
2634 
2635   // Number of stack slots between incoming argument block and the start of
2636   // a new frame.  The PROLOG must add this many slots to the stack.  The
2637   // EPILOG must remove this many slots.  amd64 needs two slots for
2638   // return address.
2639   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
2640 
2641   // Number of outgoing stack slots killed above the out_preserve_stack_slots
2642   // for calls to C.  Supports the var-args backing area for register parms.
2643   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
2644 
2645   // The after-PROLOG location of the return address.  Location of
2646   // return address specifies a type (REG or STACK) and a number
2647   // representing the register number (i.e. - use a register name) or
2648   // stack slot.
2649   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
2650   // Otherwise, it is above the locks and verification slot and alignment word
2651   return_addr(STACK - 2 +
2652               round_to((Compile::current()-&gt;in_preserve_stack_slots() +
2653                         Compile::current()-&gt;fixed_slots()),
2654                        stack_alignment_in_slots()));
2655 
2656   // Body of function which returns an integer array locating
2657   // arguments either in registers or in stack slots.  Passed an array
2658   // of ideal registers called "sig" and a "length" count.  Stack-slot
2659   // offsets are based on outgoing arguments, i.e. a CALLER setting up
2660   // arguments for a CALLEE.  Incoming stack arguments are
2661   // automatically biased by the preserve_stack_slots field above.
2662 
2663   calling_convention
2664   %{
2665     // No difference between ingoing/outgoing just pass false
2666     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
2667   %}
2668 
2669   c_calling_convention
2670   %{
2671     // This is obviously always outgoing
2672     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
2673   %}
2674 
2675   // Location of compiled Java return values.  Same as C for now.
2676   return_value
2677   %{
2678     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
2679            "only return normal values");
2680 
2681     static const int lo[Op_RegL + 1] = {
2682       0,
2683       0,
2684       RAX_num,  // Op_RegN
2685       RAX_num,  // Op_RegI
2686       RAX_num,  // Op_RegP
2687       XMM0_num, // Op_RegF
2688       XMM0_num, // Op_RegD
2689       RAX_num   // Op_RegL
2690     };
2691     static const int hi[Op_RegL + 1] = {
2692       0,
2693       0,
2694       OptoReg::Bad, // Op_RegN
2695       OptoReg::Bad, // Op_RegI
2696       RAX_H_num,    // Op_RegP
2697       OptoReg::Bad, // Op_RegF
2698       XMM0b_num,    // Op_RegD
2699       RAX_H_num     // Op_RegL
2700     };
2701     // Excluded flags and vector registers.
2702     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 5, "missing type");
2703     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
2704   %}
2705 %}
2706 
2707 //----------ATTRIBUTES---------------------------------------------------------
2708 //----------Operand Attributes-------------------------------------------------
2709 op_attrib op_cost(0);        // Required cost attribute
2710 
2711 //----------Instruction Attributes---------------------------------------------
2712 ins_attrib ins_cost(100);       // Required cost attribute
2713 ins_attrib ins_size(8);         // Required size attribute (in bits)
2714 ins_attrib ins_short_branch(0); // Required flag: is this instruction
2715                                 // a non-matching short branch variant
2716                                 // of some long branch?
2717 ins_attrib ins_alignment(1);    // Required alignment attribute (must
2718                                 // be a power of 2) specifies the
2719                                 // alignment that some part of the
2720                                 // instruction (not necessarily the
2721                                 // start) requires.  If &gt; 1, a
2722                                 // compute_padding() function must be
2723                                 // provided for the instruction
2724 
2725 //----------OPERANDS-----------------------------------------------------------
2726 // Operand definitions must precede instruction definitions for correct parsing
2727 // in the ADLC because operands constitute user defined types which are used in
2728 // instruction definitions.
2729 
2730 //----------Simple Operands----------------------------------------------------
2731 // Immediate Operands
2732 // Integer Immediate
2733 operand immI()
2734 %{
2735   match(ConI);
2736 
2737   op_cost(10);
2738   format %{ %}
2739   interface(CONST_INTER);
2740 %}
2741 
2742 // Constant for test vs zero
2743 operand immI0()
2744 %{
2745   predicate(n-&gt;get_int() == 0);
2746   match(ConI);
2747 
2748   op_cost(0);
2749   format %{ %}
2750   interface(CONST_INTER);
2751 %}
2752 
2753 // Constant for increment
2754 operand immI1()
2755 %{
2756   predicate(n-&gt;get_int() == 1);
2757   match(ConI);
2758 
2759   op_cost(0);
2760   format %{ %}
2761   interface(CONST_INTER);
2762 %}
2763 
2764 // Constant for decrement
2765 operand immI_M1()
2766 %{
2767   predicate(n-&gt;get_int() == -1);
2768   match(ConI);
2769 
2770   op_cost(0);
2771   format %{ %}
2772   interface(CONST_INTER);
2773 %}
2774 
2775 // Valid scale values for addressing modes
2776 operand immI2()
2777 %{
2778   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
2779   match(ConI);
2780 
2781   format %{ %}
2782   interface(CONST_INTER);
2783 %}
2784 
2785 operand immI8()
2786 %{
2787   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
2788   match(ConI);
2789 
2790   op_cost(5);
2791   format %{ %}
2792   interface(CONST_INTER);
2793 %}
2794 
2795 operand immI16()
2796 %{
2797   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
2798   match(ConI);
2799 
2800   op_cost(10);
2801   format %{ %}
2802   interface(CONST_INTER);
2803 %}
2804 
2805 // Int Immediate non-negative
2806 operand immU31()
2807 %{
2808   predicate(n-&gt;get_int() &gt;= 0);
2809   match(ConI);
2810 
2811   op_cost(0);
2812   format %{ %}
2813   interface(CONST_INTER);
2814 %}
2815 
2816 // Constant for long shifts
2817 operand immI_32()
2818 %{
2819   predicate( n-&gt;get_int() == 32 );
2820   match(ConI);
2821 
2822   op_cost(0);
2823   format %{ %}
2824   interface(CONST_INTER);
2825 %}
2826 
2827 // Constant for long shifts
2828 operand immI_64()
2829 %{
2830   predicate( n-&gt;get_int() == 64 );
2831   match(ConI);
2832 
2833   op_cost(0);
2834   format %{ %}
2835   interface(CONST_INTER);
2836 %}
2837 
2838 // Pointer Immediate
2839 operand immP()
2840 %{
2841   match(ConP);
2842 
2843   op_cost(10);
2844   format %{ %}
2845   interface(CONST_INTER);
2846 %}
2847 
2848 // NULL Pointer Immediate
2849 operand immP0()
2850 %{
2851   predicate(n-&gt;get_ptr() == 0);
2852   match(ConP);
2853 
2854   op_cost(5);
2855   format %{ %}
2856   interface(CONST_INTER);
2857 %}
2858 
2859 // Pointer Immediate
2860 operand immN() %{
2861   match(ConN);
2862 
2863   op_cost(10);
2864   format %{ %}
2865   interface(CONST_INTER);
2866 %}
2867 
2868 operand immNKlass() %{
2869   match(ConNKlass);
2870 
2871   op_cost(10);
2872   format %{ %}
2873   interface(CONST_INTER);
2874 %}
2875 
2876 // NULL Pointer Immediate
2877 operand immN0() %{
2878   predicate(n-&gt;get_narrowcon() == 0);
2879   match(ConN);
2880 
2881   op_cost(5);
2882   format %{ %}
2883   interface(CONST_INTER);
2884 %}
2885 
2886 operand immP31()
2887 %{
2888   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
2889             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
2890   match(ConP);
2891 
2892   op_cost(5);
2893   format %{ %}
2894   interface(CONST_INTER);
2895 %}
2896 
2897 
2898 // Long Immediate
2899 operand immL()
2900 %{
2901   match(ConL);
2902 
2903   op_cost(20);
2904   format %{ %}
2905   interface(CONST_INTER);
2906 %}
2907 
2908 // Long Immediate 8-bit
2909 operand immL8()
2910 %{
2911   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
2912   match(ConL);
2913 
2914   op_cost(5);
2915   format %{ %}
2916   interface(CONST_INTER);
2917 %}
2918 
2919 // Long Immediate 32-bit unsigned
2920 operand immUL32()
2921 %{
2922   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
2923   match(ConL);
2924 
2925   op_cost(10);
2926   format %{ %}
2927   interface(CONST_INTER);
2928 %}
2929 
2930 // Long Immediate 32-bit signed
2931 operand immL32()
2932 %{
2933   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
2934   match(ConL);
2935 
2936   op_cost(15);
2937   format %{ %}
2938   interface(CONST_INTER);
2939 %}
2940 
2941 // Long Immediate zero
2942 operand immL0()
2943 %{
2944   predicate(n-&gt;get_long() == 0L);
2945   match(ConL);
2946 
2947   op_cost(10);
2948   format %{ %}
2949   interface(CONST_INTER);
2950 %}
2951 
2952 // Constant for increment
2953 operand immL1()
2954 %{
2955   predicate(n-&gt;get_long() == 1);
2956   match(ConL);
2957 
2958   format %{ %}
2959   interface(CONST_INTER);
2960 %}
2961 
2962 // Constant for decrement
2963 operand immL_M1()
2964 %{
2965   predicate(n-&gt;get_long() == -1);
2966   match(ConL);
2967 
2968   format %{ %}
2969   interface(CONST_INTER);
2970 %}
2971 
2972 // Long Immediate: the value 10
2973 operand immL10()
2974 %{
2975   predicate(n-&gt;get_long() == 10);
2976   match(ConL);
2977 
2978   format %{ %}
2979   interface(CONST_INTER);
2980 %}
2981 
2982 // Long immediate from 0 to 127.
2983 // Used for a shorter form of long mul by 10.
2984 operand immL_127()
2985 %{
2986   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
2987   match(ConL);
2988 
2989   op_cost(10);
2990   format %{ %}
2991   interface(CONST_INTER);
2992 %}
2993 
2994 // Long Immediate: low 32-bit mask
2995 operand immL_32bits()
2996 %{
2997   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
2998   match(ConL);
2999   op_cost(20);
3000 
3001   format %{ %}
3002   interface(CONST_INTER);
3003 %}
3004 
3005 // Float Immediate zero
3006 operand immF0()
3007 %{
3008   predicate(jint_cast(n-&gt;getf()) == 0);
3009   match(ConF);
3010 
3011   op_cost(5);
3012   format %{ %}
3013   interface(CONST_INTER);
3014 %}
3015 
3016 // Float Immediate
3017 operand immF()
3018 %{
3019   match(ConF);
3020 
3021   op_cost(15);
3022   format %{ %}
3023   interface(CONST_INTER);
3024 %}
3025 
3026 // Double Immediate zero
3027 operand immD0()
3028 %{
3029   predicate(jlong_cast(n-&gt;getd()) == 0);
3030   match(ConD);
3031 
3032   op_cost(5);
3033   format %{ %}
3034   interface(CONST_INTER);
3035 %}
3036 
3037 // Double Immediate
3038 operand immD()
3039 %{
3040   match(ConD);
3041 
3042   op_cost(15);
3043   format %{ %}
3044   interface(CONST_INTER);
3045 %}
3046 
3047 // Immediates for special shifts (sign extend)
3048 
3049 // Constants for increment
3050 operand immI_16()
3051 %{
3052   predicate(n-&gt;get_int() == 16);
3053   match(ConI);
3054 
3055   format %{ %}
3056   interface(CONST_INTER);
3057 %}
3058 
3059 operand immI_24()
3060 %{
3061   predicate(n-&gt;get_int() == 24);
3062   match(ConI);
3063 
3064   format %{ %}
3065   interface(CONST_INTER);
3066 %}
3067 
3068 // Constant for byte-wide masking
3069 operand immI_255()
3070 %{
3071   predicate(n-&gt;get_int() == 255);
3072   match(ConI);
3073 
3074   format %{ %}
3075   interface(CONST_INTER);
3076 %}
3077 
3078 // Constant for short-wide masking
3079 operand immI_65535()
3080 %{
3081   predicate(n-&gt;get_int() == 65535);
3082   match(ConI);
3083 
3084   format %{ %}
3085   interface(CONST_INTER);
3086 %}
3087 
3088 // Constant for byte-wide masking
3089 operand immL_255()
3090 %{
3091   predicate(n-&gt;get_long() == 255);
3092   match(ConL);
3093 
3094   format %{ %}
3095   interface(CONST_INTER);
3096 %}
3097 
3098 // Constant for short-wide masking
3099 operand immL_65535()
3100 %{
3101   predicate(n-&gt;get_long() == 65535);
3102   match(ConL);
3103 
3104   format %{ %}
3105   interface(CONST_INTER);
3106 %}
3107 
3108 // Register Operands
3109 // Integer Register
3110 operand rRegI()
3111 %{
3112   constraint(ALLOC_IN_RC(int_reg));
3113   match(RegI);
3114 
3115   match(rax_RegI);
3116   match(rbx_RegI);
3117   match(rcx_RegI);
3118   match(rdx_RegI);
3119   match(rdi_RegI);
3120 
3121   format %{ %}
3122   interface(REG_INTER);
3123 %}
3124 
3125 // Special Registers
3126 operand rax_RegI()
3127 %{
3128   constraint(ALLOC_IN_RC(int_rax_reg));
3129   match(RegI);
3130   match(rRegI);
3131 
3132   format %{ "RAX" %}
3133   interface(REG_INTER);
3134 %}
3135 
3136 // Special Registers
3137 operand rbx_RegI()
3138 %{
3139   constraint(ALLOC_IN_RC(int_rbx_reg));
3140   match(RegI);
3141   match(rRegI);
3142 
3143   format %{ "RBX" %}
3144   interface(REG_INTER);
3145 %}
3146 
3147 operand rcx_RegI()
3148 %{
3149   constraint(ALLOC_IN_RC(int_rcx_reg));
3150   match(RegI);
3151   match(rRegI);
3152 
3153   format %{ "RCX" %}
3154   interface(REG_INTER);
3155 %}
3156 
3157 operand rdx_RegI()
3158 %{
3159   constraint(ALLOC_IN_RC(int_rdx_reg));
3160   match(RegI);
3161   match(rRegI);
3162 
3163   format %{ "RDX" %}
3164   interface(REG_INTER);
3165 %}
3166 
3167 operand rdi_RegI()
3168 %{
3169   constraint(ALLOC_IN_RC(int_rdi_reg));
3170   match(RegI);
3171   match(rRegI);
3172 
3173   format %{ "RDI" %}
3174   interface(REG_INTER);
3175 %}
3176 
3177 operand no_rcx_RegI()
3178 %{
3179   constraint(ALLOC_IN_RC(int_no_rcx_reg));
3180   match(RegI);
3181   match(rax_RegI);
3182   match(rbx_RegI);
3183   match(rdx_RegI);
3184   match(rdi_RegI);
3185 
3186   format %{ %}
3187   interface(REG_INTER);
3188 %}
3189 
3190 operand no_rax_rdx_RegI()
3191 %{
3192   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
3193   match(RegI);
3194   match(rbx_RegI);
3195   match(rcx_RegI);
3196   match(rdi_RegI);
3197 
3198   format %{ %}
3199   interface(REG_INTER);
3200 %}
3201 
3202 // Pointer Register
3203 operand any_RegP()
3204 %{
3205   constraint(ALLOC_IN_RC(any_reg));
3206   match(RegP);
3207   match(rax_RegP);
3208   match(rbx_RegP);
3209   match(rdi_RegP);
3210   match(rsi_RegP);
3211   match(rbp_RegP);
3212   match(r15_RegP);
3213   match(rRegP);
3214 
3215   format %{ %}
3216   interface(REG_INTER);
3217 %}
3218 
3219 operand rRegP()
3220 %{
3221   constraint(ALLOC_IN_RC(ptr_reg));
3222   match(RegP);
3223   match(rax_RegP);
3224   match(rbx_RegP);
3225   match(rdi_RegP);
3226   match(rsi_RegP);
3227   match(rbp_RegP);
3228   match(r15_RegP);  // See Q&amp;A below about r15_RegP.
3229 
3230   format %{ %}
3231   interface(REG_INTER);
3232 %}
3233 
3234 operand rRegN() %{
3235   constraint(ALLOC_IN_RC(int_reg));
3236   match(RegN);
3237 
3238   format %{ %}
3239   interface(REG_INTER);
3240 %}
3241 
3242 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
3243 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
3244 // It's fine for an instruction input which expects rRegP to match a r15_RegP.
3245 // The output of an instruction is controlled by the allocator, which respects
3246 // register class masks, not match rules.  Unless an instruction mentions
3247 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
3248 // by the allocator as an input.
3249 
3250 operand no_rax_RegP()
3251 %{
3252   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
3253   match(RegP);
3254   match(rbx_RegP);
3255   match(rsi_RegP);
3256   match(rdi_RegP);
3257 
3258   format %{ %}
3259   interface(REG_INTER);
3260 %}
3261 
3262 operand no_rbp_RegP()
3263 %{
3264   constraint(ALLOC_IN_RC(ptr_no_rbp_reg));
3265   match(RegP);
3266   match(rbx_RegP);
3267   match(rsi_RegP);
3268   match(rdi_RegP);
3269 
3270   format %{ %}
3271   interface(REG_INTER);
3272 %}
3273 
3274 operand no_rax_rbx_RegP()
3275 %{
3276   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
3277   match(RegP);
3278   match(rsi_RegP);
3279   match(rdi_RegP);
3280 
3281   format %{ %}
3282   interface(REG_INTER);
3283 %}
3284 
3285 // Special Registers
3286 // Return a pointer value
3287 operand rax_RegP()
3288 %{
3289   constraint(ALLOC_IN_RC(ptr_rax_reg));
3290   match(RegP);
3291   match(rRegP);
3292 
3293   format %{ %}
3294   interface(REG_INTER);
3295 %}
3296 
3297 // Special Registers
3298 // Return a compressed pointer value
3299 operand rax_RegN()
3300 %{
3301   constraint(ALLOC_IN_RC(int_rax_reg));
3302   match(RegN);
3303   match(rRegN);
3304 
3305   format %{ %}
3306   interface(REG_INTER);
3307 %}
3308 
3309 // Used in AtomicAdd
3310 operand rbx_RegP()
3311 %{
3312   constraint(ALLOC_IN_RC(ptr_rbx_reg));
3313   match(RegP);
3314   match(rRegP);
3315 
3316   format %{ %}
3317   interface(REG_INTER);
3318 %}
3319 
3320 operand rsi_RegP()
3321 %{
3322   constraint(ALLOC_IN_RC(ptr_rsi_reg));
3323   match(RegP);
3324   match(rRegP);
3325 
3326   format %{ %}
3327   interface(REG_INTER);
3328 %}
3329 
3330 // Used in rep stosq
3331 operand rdi_RegP()
3332 %{
3333   constraint(ALLOC_IN_RC(ptr_rdi_reg));
3334   match(RegP);
3335   match(rRegP);
3336 
3337   format %{ %}
3338   interface(REG_INTER);
3339 %}
3340 
3341 operand rbp_RegP()
3342 %{
3343   constraint(ALLOC_IN_RC(ptr_rbp_reg));
3344   match(RegP);
3345   match(rRegP);
3346 
3347   format %{ %}
3348   interface(REG_INTER);
3349 %}
3350 
3351 operand r15_RegP()
3352 %{
3353   constraint(ALLOC_IN_RC(ptr_r15_reg));
3354   match(RegP);
3355   match(rRegP);
3356 
3357   format %{ %}
3358   interface(REG_INTER);
3359 %}
3360 
3361 operand rRegL()
3362 %{
3363   constraint(ALLOC_IN_RC(long_reg));
3364   match(RegL);
3365   match(rax_RegL);
3366   match(rdx_RegL);
3367 
3368   format %{ %}
3369   interface(REG_INTER);
3370 %}
3371 
3372 // Special Registers
3373 operand no_rax_rdx_RegL()
3374 %{
3375   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
3376   match(RegL);
3377   match(rRegL);
3378 
3379   format %{ %}
3380   interface(REG_INTER);
3381 %}
3382 
3383 operand no_rax_RegL()
3384 %{
3385   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
3386   match(RegL);
3387   match(rRegL);
3388   match(rdx_RegL);
3389 
3390   format %{ %}
3391   interface(REG_INTER);
3392 %}
3393 
3394 operand no_rcx_RegL()
3395 %{
3396   constraint(ALLOC_IN_RC(long_no_rcx_reg));
3397   match(RegL);
3398   match(rRegL);
3399 
3400   format %{ %}
3401   interface(REG_INTER);
3402 %}
3403 
3404 operand rax_RegL()
3405 %{
3406   constraint(ALLOC_IN_RC(long_rax_reg));
3407   match(RegL);
3408   match(rRegL);
3409 
3410   format %{ "RAX" %}
3411   interface(REG_INTER);
3412 %}
3413 
3414 operand rcx_RegL()
3415 %{
3416   constraint(ALLOC_IN_RC(long_rcx_reg));
3417   match(RegL);
3418   match(rRegL);
3419 
3420   format %{ %}
3421   interface(REG_INTER);
3422 %}
3423 
3424 operand rdx_RegL()
3425 %{
3426   constraint(ALLOC_IN_RC(long_rdx_reg));
3427   match(RegL);
3428   match(rRegL);
3429 
3430   format %{ %}
3431   interface(REG_INTER);
3432 %}
3433 
3434 // Flags register, used as output of compare instructions
3435 operand rFlagsReg()
3436 %{
3437   constraint(ALLOC_IN_RC(int_flags));
3438   match(RegFlags);
3439 
3440   format %{ "RFLAGS" %}
3441   interface(REG_INTER);
3442 %}
3443 
3444 // Flags register, used as output of FLOATING POINT compare instructions
3445 operand rFlagsRegU()
3446 %{
3447   constraint(ALLOC_IN_RC(int_flags));
3448   match(RegFlags);
3449 
3450   format %{ "RFLAGS_U" %}
3451   interface(REG_INTER);
3452 %}
3453 
3454 operand rFlagsRegUCF() %{
3455   constraint(ALLOC_IN_RC(int_flags));
3456   match(RegFlags);
3457   predicate(false);
3458 
3459   format %{ "RFLAGS_U_CF" %}
3460   interface(REG_INTER);
3461 %}
3462 
3463 // Float register operands
3464 operand regF()
3465 %{
3466   constraint(ALLOC_IN_RC(float_reg));
3467   match(RegF);
3468 
3469   format %{ %}
3470   interface(REG_INTER);
3471 %}
3472 
3473 // Double register operands
3474 operand regD()
3475 %{
3476   constraint(ALLOC_IN_RC(double_reg));
3477   match(RegD);
3478 
3479   format %{ %}
3480   interface(REG_INTER);
3481 %}
3482 
3483 //----------Memory Operands----------------------------------------------------
3484 // Direct Memory Operand
3485 // operand direct(immP addr)
3486 // %{
3487 //   match(addr);
3488 
3489 //   format %{ "[$addr]" %}
3490 //   interface(MEMORY_INTER) %{
3491 //     base(0xFFFFFFFF);
3492 //     index(0x4);
3493 //     scale(0x0);
3494 //     disp($addr);
3495 //   %}
3496 // %}
3497 
3498 // Indirect Memory Operand
3499 operand indirect(any_RegP reg)
3500 %{
3501   constraint(ALLOC_IN_RC(ptr_reg));
3502   match(reg);
3503 
3504   format %{ "[$reg]" %}
3505   interface(MEMORY_INTER) %{
3506     base($reg);
3507     index(0x4);
3508     scale(0x0);
3509     disp(0x0);
3510   %}
3511 %}
3512 
3513 // Indirect Memory Plus Short Offset Operand
3514 operand indOffset8(any_RegP reg, immL8 off)
3515 %{
3516   constraint(ALLOC_IN_RC(ptr_reg));
3517   match(AddP reg off);
3518 
3519   format %{ "[$reg + $off (8-bit)]" %}
3520   interface(MEMORY_INTER) %{
3521     base($reg);
3522     index(0x4);
3523     scale(0x0);
3524     disp($off);
3525   %}
3526 %}
3527 
3528 // Indirect Memory Plus Long Offset Operand
3529 operand indOffset32(any_RegP reg, immL32 off)
3530 %{
3531   constraint(ALLOC_IN_RC(ptr_reg));
3532   match(AddP reg off);
3533 
3534   format %{ "[$reg + $off (32-bit)]" %}
3535   interface(MEMORY_INTER) %{
3536     base($reg);
3537     index(0x4);
3538     scale(0x0);
3539     disp($off);
3540   %}
3541 %}
3542 
3543 // Indirect Memory Plus Index Register Plus Offset Operand
3544 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
3545 %{
3546   constraint(ALLOC_IN_RC(ptr_reg));
3547   match(AddP (AddP reg lreg) off);
3548 
3549   op_cost(10);
3550   format %{"[$reg + $off + $lreg]" %}
3551   interface(MEMORY_INTER) %{
3552     base($reg);
3553     index($lreg);
3554     scale(0x0);
3555     disp($off);
3556   %}
3557 %}
3558 
3559 // Indirect Memory Plus Index Register Plus Offset Operand
3560 operand indIndex(any_RegP reg, rRegL lreg)
3561 %{
3562   constraint(ALLOC_IN_RC(ptr_reg));
3563   match(AddP reg lreg);
3564 
3565   op_cost(10);
3566   format %{"[$reg + $lreg]" %}
3567   interface(MEMORY_INTER) %{
3568     base($reg);
3569     index($lreg);
3570     scale(0x0);
3571     disp(0x0);
3572   %}
3573 %}
3574 
3575 // Indirect Memory Times Scale Plus Index Register
3576 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
3577 %{
3578   constraint(ALLOC_IN_RC(ptr_reg));
3579   match(AddP reg (LShiftL lreg scale));
3580 
3581   op_cost(10);
3582   format %{"[$reg + $lreg &lt;&lt; $scale]" %}
3583   interface(MEMORY_INTER) %{
3584     base($reg);
3585     index($lreg);
3586     scale($scale);
3587     disp(0x0);
3588   %}
3589 %}
3590 
3591 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
3592 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
3593 %{
3594   constraint(ALLOC_IN_RC(ptr_reg));
3595   match(AddP (AddP reg (LShiftL lreg scale)) off);
3596 
3597   op_cost(10);
3598   format %{"[$reg + $off + $lreg &lt;&lt; $scale]" %}
3599   interface(MEMORY_INTER) %{
3600     base($reg);
3601     index($lreg);
3602     scale($scale);
3603     disp($off);
3604   %}
3605 %}
3606 
3607 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
3608 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
3609 %{
3610   constraint(ALLOC_IN_RC(ptr_reg));
3611   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3612   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
3613 
3614   op_cost(10);
3615   format %{"[$reg + $off + $idx &lt;&lt; $scale]" %}
3616   interface(MEMORY_INTER) %{
3617     base($reg);
3618     index($idx);
3619     scale($scale);
3620     disp($off);
3621   %}
3622 %}
3623 
3624 // Indirect Narrow Oop Plus Offset Operand
3625 // Note: x86 architecture doesn't support "scale * index + offset" without a base
3626 // we can't free r12 even with Universe::narrow_oop_base() == NULL.
3627 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
3628   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() == Address::times_8));
3629   constraint(ALLOC_IN_RC(ptr_reg));
3630   match(AddP (DecodeN reg) off);
3631 
3632   op_cost(10);
3633   format %{"[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)" %}
3634   interface(MEMORY_INTER) %{
3635     base(0xc); // R12
3636     index($reg);
3637     scale(0x3);
3638     disp($off);
3639   %}
3640 %}
3641 
3642 // Indirect Memory Operand
3643 operand indirectNarrow(rRegN reg)
3644 %{
3645   predicate(Universe::narrow_oop_shift() == 0);
3646   constraint(ALLOC_IN_RC(ptr_reg));
3647   match(DecodeN reg);
3648 
3649   format %{ "[$reg]" %}
3650   interface(MEMORY_INTER) %{
3651     base($reg);
3652     index(0x4);
3653     scale(0x0);
3654     disp(0x0);
3655   %}
3656 %}
3657 
3658 // Indirect Memory Plus Short Offset Operand
3659 operand indOffset8Narrow(rRegN reg, immL8 off)
3660 %{
3661   predicate(Universe::narrow_oop_shift() == 0);
3662   constraint(ALLOC_IN_RC(ptr_reg));
3663   match(AddP (DecodeN reg) off);
3664 
3665   format %{ "[$reg + $off (8-bit)]" %}
3666   interface(MEMORY_INTER) %{
3667     base($reg);
3668     index(0x4);
3669     scale(0x0);
3670     disp($off);
3671   %}
3672 %}
3673 
3674 // Indirect Memory Plus Long Offset Operand
3675 operand indOffset32Narrow(rRegN reg, immL32 off)
3676 %{
3677   predicate(Universe::narrow_oop_shift() == 0);
3678   constraint(ALLOC_IN_RC(ptr_reg));
3679   match(AddP (DecodeN reg) off);
3680 
3681   format %{ "[$reg + $off (32-bit)]" %}
3682   interface(MEMORY_INTER) %{
3683     base($reg);
3684     index(0x4);
3685     scale(0x0);
3686     disp($off);
3687   %}
3688 %}
3689 
3690 // Indirect Memory Plus Index Register Plus Offset Operand
3691 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
3692 %{
3693   predicate(Universe::narrow_oop_shift() == 0);
3694   constraint(ALLOC_IN_RC(ptr_reg));
3695   match(AddP (AddP (DecodeN reg) lreg) off);
3696 
3697   op_cost(10);
3698   format %{"[$reg + $off + $lreg]" %}
3699   interface(MEMORY_INTER) %{
3700     base($reg);
3701     index($lreg);
3702     scale(0x0);
3703     disp($off);
3704   %}
3705 %}
3706 
3707 // Indirect Memory Plus Index Register Plus Offset Operand
3708 operand indIndexNarrow(rRegN reg, rRegL lreg)
3709 %{
3710   predicate(Universe::narrow_oop_shift() == 0);
3711   constraint(ALLOC_IN_RC(ptr_reg));
3712   match(AddP (DecodeN reg) lreg);
3713 
3714   op_cost(10);
3715   format %{"[$reg + $lreg]" %}
3716   interface(MEMORY_INTER) %{
3717     base($reg);
3718     index($lreg);
3719     scale(0x0);
3720     disp(0x0);
3721   %}
3722 %}
3723 
3724 // Indirect Memory Times Scale Plus Index Register
3725 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
3726 %{
3727   predicate(Universe::narrow_oop_shift() == 0);
3728   constraint(ALLOC_IN_RC(ptr_reg));
3729   match(AddP (DecodeN reg) (LShiftL lreg scale));
3730 
3731   op_cost(10);
3732   format %{"[$reg + $lreg &lt;&lt; $scale]" %}
3733   interface(MEMORY_INTER) %{
3734     base($reg);
3735     index($lreg);
3736     scale($scale);
3737     disp(0x0);
3738   %}
3739 %}
3740 
3741 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
3742 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
3743 %{
3744   predicate(Universe::narrow_oop_shift() == 0);
3745   constraint(ALLOC_IN_RC(ptr_reg));
3746   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
3747 
3748   op_cost(10);
3749   format %{"[$reg + $off + $lreg &lt;&lt; $scale]" %}
3750   interface(MEMORY_INTER) %{
3751     base($reg);
3752     index($lreg);
3753     scale($scale);
3754     disp($off);
3755   %}
3756 %}
3757 
3758 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
3759 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
3760 %{
3761   constraint(ALLOC_IN_RC(ptr_reg));
3762   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3763   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
3764 
3765   op_cost(10);
3766   format %{"[$reg + $off + $idx &lt;&lt; $scale]" %}
3767   interface(MEMORY_INTER) %{
3768     base($reg);
3769     index($idx);
3770     scale($scale);
3771     disp($off);
3772   %}
3773 %}
3774 
3775 //----------Special Memory Operands--------------------------------------------
3776 // Stack Slot Operand - This operand is used for loading and storing temporary
3777 //                      values on the stack where a match requires a value to
3778 //                      flow through memory.
3779 operand stackSlotP(sRegP reg)
3780 %{
3781   constraint(ALLOC_IN_RC(stack_slots));
3782   // No match rule because this operand is only generated in matching
3783 
3784   format %{ "[$reg]" %}
3785   interface(MEMORY_INTER) %{
3786     base(0x4);   // RSP
3787     index(0x4);  // No Index
3788     scale(0x0);  // No Scale
3789     disp($reg);  // Stack Offset
3790   %}
3791 %}
3792 
3793 operand stackSlotI(sRegI reg)
3794 %{
3795   constraint(ALLOC_IN_RC(stack_slots));
3796   // No match rule because this operand is only generated in matching
3797 
3798   format %{ "[$reg]" %}
3799   interface(MEMORY_INTER) %{
3800     base(0x4);   // RSP
3801     index(0x4);  // No Index
3802     scale(0x0);  // No Scale
3803     disp($reg);  // Stack Offset
3804   %}
3805 %}
3806 
3807 operand stackSlotF(sRegF reg)
3808 %{
3809   constraint(ALLOC_IN_RC(stack_slots));
3810   // No match rule because this operand is only generated in matching
3811 
3812   format %{ "[$reg]" %}
3813   interface(MEMORY_INTER) %{
3814     base(0x4);   // RSP
3815     index(0x4);  // No Index
3816     scale(0x0);  // No Scale
3817     disp($reg);  // Stack Offset
3818   %}
3819 %}
3820 
3821 operand stackSlotD(sRegD reg)
3822 %{
3823   constraint(ALLOC_IN_RC(stack_slots));
3824   // No match rule because this operand is only generated in matching
3825 
3826   format %{ "[$reg]" %}
3827   interface(MEMORY_INTER) %{
3828     base(0x4);   // RSP
3829     index(0x4);  // No Index
3830     scale(0x0);  // No Scale
3831     disp($reg);  // Stack Offset
3832   %}
3833 %}
3834 operand stackSlotL(sRegL reg)
3835 %{
3836   constraint(ALLOC_IN_RC(stack_slots));
3837   // No match rule because this operand is only generated in matching
3838 
3839   format %{ "[$reg]" %}
3840   interface(MEMORY_INTER) %{
3841     base(0x4);   // RSP
3842     index(0x4);  // No Index
3843     scale(0x0);  // No Scale
3844     disp($reg);  // Stack Offset
3845   %}
3846 %}
3847 
3848 //----------Conditional Branch Operands----------------------------------------
3849 // Comparison Op  - This is the operation of the comparison, and is limited to
3850 //                  the following set of codes:
3851 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
3852 //
3853 // Other attributes of the comparison, such as unsignedness, are specified
3854 // by the comparison instruction that sets a condition code flags register.
3855 // That result is represented by a flags operand whose subtype is appropriate
3856 // to the unsignedness (etc.) of the comparison.
3857 //
3858 // Later, the instruction which matches both the Comparison Op (a Bool) and
3859 // the flags (produced by the Cmp) specifies the coding of the comparison op
3860 // by matching a specific subtype of Bool operand below, such as cmpOpU.
3861 
3862 // Comparision Code
3863 operand cmpOp()
3864 %{
3865   match(Bool);
3866 
3867   format %{ "" %}
3868   interface(COND_INTER) %{
3869     equal(0x4, "e");
3870     not_equal(0x5, "ne");
3871     less(0xC, "l");
3872     greater_equal(0xD, "ge");
3873     less_equal(0xE, "le");
3874     greater(0xF, "g");
3875     overflow(0x0, "o");
3876     no_overflow(0x1, "no");
3877   %}
3878 %}
3879 
3880 // Comparison Code, unsigned compare.  Used by FP also, with
3881 // C2 (unordered) turned into GT or LT already.  The other bits
3882 // C0 and C3 are turned into Carry &amp; Zero flags.
3883 operand cmpOpU()
3884 %{
3885   match(Bool);
3886 
3887   format %{ "" %}
3888   interface(COND_INTER) %{
3889     equal(0x4, "e");
3890     not_equal(0x5, "ne");
3891     less(0x2, "b");
3892     greater_equal(0x3, "nb");
3893     less_equal(0x6, "be");
3894     greater(0x7, "nbe");
3895     overflow(0x0, "o");
3896     no_overflow(0x1, "no");
3897   %}
3898 %}
3899 
3900 
3901 // Floating comparisons that don't require any fixup for the unordered case
3902 operand cmpOpUCF() %{
3903   match(Bool);
3904   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
3905             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
3906             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
3907             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
3908   format %{ "" %}
3909   interface(COND_INTER) %{
3910     equal(0x4, "e");
3911     not_equal(0x5, "ne");
3912     less(0x2, "b");
3913     greater_equal(0x3, "nb");
3914     less_equal(0x6, "be");
3915     greater(0x7, "nbe");
3916     overflow(0x0, "o");
3917     no_overflow(0x1, "no");
3918   %}
3919 %}
3920 
3921 
3922 // Floating comparisons that can be fixed up with extra conditional jumps
3923 operand cmpOpUCF2() %{
3924   match(Bool);
3925   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
3926             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
3927   format %{ "" %}
3928   interface(COND_INTER) %{
3929     equal(0x4, "e");
3930     not_equal(0x5, "ne");
3931     less(0x2, "b");
3932     greater_equal(0x3, "nb");
3933     less_equal(0x6, "be");
3934     greater(0x7, "nbe");
3935     overflow(0x0, "o");
3936     no_overflow(0x1, "no");
3937   %}
3938 %}
3939 
3940 
3941 //----------OPERAND CLASSES----------------------------------------------------
3942 // Operand Classes are groups of operands that are used as to simplify
3943 // instruction definitions by not requiring the AD writer to specify separate
3944 // instructions for every form of operand when the instruction accepts
3945 // multiple operand types with the same basic encoding and format.  The classic
3946 // case of this is memory operands.
3947 
3948 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
3949                indIndexScale, indIndexScaleOffset, indPosIndexScaleOffset,
3950                indCompressedOopOffset,
3951                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
3952                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
3953                indIndexScaleOffsetNarrow, indPosIndexScaleOffsetNarrow);
3954 
3955 //----------PIPELINE-----------------------------------------------------------
3956 // Rules which define the behavior of the target architectures pipeline.
3957 pipeline %{
3958 
3959 //----------ATTRIBUTES---------------------------------------------------------
3960 attributes %{
3961   variable_size_instructions;        // Fixed size instructions
3962   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
3963   instruction_unit_size = 1;         // An instruction is 1 bytes long
3964   instruction_fetch_unit_size = 16;  // The processor fetches one line
3965   instruction_fetch_units = 1;       // of 16 bytes
3966 
3967   // List of nop instructions
3968   nops( MachNop );
3969 %}
3970 
3971 //----------RESOURCES----------------------------------------------------------
3972 // Resources are the functional units available to the machine
3973 
3974 // Generic P2/P3 pipeline
3975 // 3 decoders, only D0 handles big operands; a "bundle" is the limit of
3976 // 3 instructions decoded per cycle.
3977 // 2 load/store ops per cycle, 1 branch, 1 FPU,
3978 // 3 ALU op, only ALU0 handles mul instructions.
3979 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
3980            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
3981            BR, FPU,
3982            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
3983 
3984 //----------PIPELINE DESCRIPTION-----------------------------------------------
3985 // Pipeline Description specifies the stages in the machine's pipeline
3986 
3987 // Generic P2/P3 pipeline
3988 pipe_desc(S0, S1, S2, S3, S4, S5);
3989 
3990 //----------PIPELINE CLASSES---------------------------------------------------
3991 // Pipeline Classes describe the stages in which input and output are
3992 // referenced by the hardware pipeline.
3993 
3994 // Naming convention: ialu or fpu
3995 // Then: _reg
3996 // Then: _reg if there is a 2nd register
3997 // Then: _long if it's a pair of instructions implementing a long
3998 // Then: _fat if it requires the big decoder
3999 //   Or: _mem if it requires the big decoder and a memory unit.
4000 
4001 // Integer ALU reg operation
4002 pipe_class ialu_reg(rRegI dst)
4003 %{
4004     single_instruction;
4005     dst    : S4(write);
4006     dst    : S3(read);
4007     DECODE : S0;        // any decoder
4008     ALU    : S3;        // any alu
4009 %}
4010 
4011 // Long ALU reg operation
4012 pipe_class ialu_reg_long(rRegL dst)
4013 %{
4014     instruction_count(2);
4015     dst    : S4(write);
4016     dst    : S3(read);
4017     DECODE : S0(2);     // any 2 decoders
4018     ALU    : S3(2);     // both alus
4019 %}
4020 
4021 // Integer ALU reg operation using big decoder
4022 pipe_class ialu_reg_fat(rRegI dst)
4023 %{
4024     single_instruction;
4025     dst    : S4(write);
4026     dst    : S3(read);
4027     D0     : S0;        // big decoder only
4028     ALU    : S3;        // any alu
4029 %}
4030 
4031 // Long ALU reg operation using big decoder
4032 pipe_class ialu_reg_long_fat(rRegL dst)
4033 %{
4034     instruction_count(2);
4035     dst    : S4(write);
4036     dst    : S3(read);
4037     D0     : S0(2);     // big decoder only; twice
4038     ALU    : S3(2);     // any 2 alus
4039 %}
4040 
4041 // Integer ALU reg-reg operation
4042 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
4043 %{
4044     single_instruction;
4045     dst    : S4(write);
4046     src    : S3(read);
4047     DECODE : S0;        // any decoder
4048     ALU    : S3;        // any alu
4049 %}
4050 
4051 // Long ALU reg-reg operation
4052 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
4053 %{
4054     instruction_count(2);
4055     dst    : S4(write);
4056     src    : S3(read);
4057     DECODE : S0(2);     // any 2 decoders
4058     ALU    : S3(2);     // both alus
4059 %}
4060 
4061 // Integer ALU reg-reg operation
4062 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
4063 %{
4064     single_instruction;
4065     dst    : S4(write);
4066     src    : S3(read);
4067     D0     : S0;        // big decoder only
4068     ALU    : S3;        // any alu
4069 %}
4070 
4071 // Long ALU reg-reg operation
4072 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
4073 %{
4074     instruction_count(2);
4075     dst    : S4(write);
4076     src    : S3(read);
4077     D0     : S0(2);     // big decoder only; twice
4078     ALU    : S3(2);     // both alus
4079 %}
4080 
4081 // Integer ALU reg-mem operation
4082 pipe_class ialu_reg_mem(rRegI dst, memory mem)
4083 %{
4084     single_instruction;
4085     dst    : S5(write);
4086     mem    : S3(read);
4087     D0     : S0;        // big decoder only
4088     ALU    : S4;        // any alu
4089     MEM    : S3;        // any mem
4090 %}
4091 
4092 // Integer mem operation (prefetch)
4093 pipe_class ialu_mem(memory mem)
4094 %{
4095     single_instruction;
4096     mem    : S3(read);
4097     D0     : S0;        // big decoder only
4098     MEM    : S3;        // any mem
4099 %}
4100 
4101 // Integer Store to Memory
4102 pipe_class ialu_mem_reg(memory mem, rRegI src)
4103 %{
4104     single_instruction;
4105     mem    : S3(read);
4106     src    : S5(read);
4107     D0     : S0;        // big decoder only
4108     ALU    : S4;        // any alu
4109     MEM    : S3;
4110 %}
4111 
4112 // // Long Store to Memory
4113 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
4114 // %{
4115 //     instruction_count(2);
4116 //     mem    : S3(read);
4117 //     src    : S5(read);
4118 //     D0     : S0(2);          // big decoder only; twice
4119 //     ALU    : S4(2);     // any 2 alus
4120 //     MEM    : S3(2);  // Both mems
4121 // %}
4122 
4123 // Integer Store to Memory
4124 pipe_class ialu_mem_imm(memory mem)
4125 %{
4126     single_instruction;
4127     mem    : S3(read);
4128     D0     : S0;        // big decoder only
4129     ALU    : S4;        // any alu
4130     MEM    : S3;
4131 %}
4132 
4133 // Integer ALU0 reg-reg operation
4134 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
4135 %{
4136     single_instruction;
4137     dst    : S4(write);
4138     src    : S3(read);
4139     D0     : S0;        // Big decoder only
4140     ALU0   : S3;        // only alu0
4141 %}
4142 
4143 // Integer ALU0 reg-mem operation
4144 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
4145 %{
4146     single_instruction;
4147     dst    : S5(write);
4148     mem    : S3(read);
4149     D0     : S0;        // big decoder only
4150     ALU0   : S4;        // ALU0 only
4151     MEM    : S3;        // any mem
4152 %}
4153 
4154 // Integer ALU reg-reg operation
4155 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
4156 %{
4157     single_instruction;
4158     cr     : S4(write);
4159     src1   : S3(read);
4160     src2   : S3(read);
4161     DECODE : S0;        // any decoder
4162     ALU    : S3;        // any alu
4163 %}
4164 
4165 // Integer ALU reg-imm operation
4166 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
4167 %{
4168     single_instruction;
4169     cr     : S4(write);
4170     src1   : S3(read);
4171     DECODE : S0;        // any decoder
4172     ALU    : S3;        // any alu
4173 %}
4174 
4175 // Integer ALU reg-mem operation
4176 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
4177 %{
4178     single_instruction;
4179     cr     : S4(write);
4180     src1   : S3(read);
4181     src2   : S3(read);
4182     D0     : S0;        // big decoder only
4183     ALU    : S4;        // any alu
4184     MEM    : S3;
4185 %}
4186 
4187 // Conditional move reg-reg
4188 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
4189 %{
4190     instruction_count(4);
4191     y      : S4(read);
4192     q      : S3(read);
4193     p      : S3(read);
4194     DECODE : S0(4);     // any decoder
4195 %}
4196 
4197 // Conditional move reg-reg
4198 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
4199 %{
4200     single_instruction;
4201     dst    : S4(write);
4202     src    : S3(read);
4203     cr     : S3(read);
4204     DECODE : S0;        // any decoder
4205 %}
4206 
4207 // Conditional move reg-mem
4208 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
4209 %{
4210     single_instruction;
4211     dst    : S4(write);
4212     src    : S3(read);
4213     cr     : S3(read);
4214     DECODE : S0;        // any decoder
4215     MEM    : S3;
4216 %}
4217 
4218 // Conditional move reg-reg long
4219 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
4220 %{
4221     single_instruction;
4222     dst    : S4(write);
4223     src    : S3(read);
4224     cr     : S3(read);
4225     DECODE : S0(2);     // any 2 decoders
4226 %}
4227 
4228 // XXX
4229 // // Conditional move double reg-reg
4230 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
4231 // %{
4232 //     single_instruction;
4233 //     dst    : S4(write);
4234 //     src    : S3(read);
4235 //     cr     : S3(read);
4236 //     DECODE : S0;     // any decoder
4237 // %}
4238 
4239 // Float reg-reg operation
4240 pipe_class fpu_reg(regD dst)
4241 %{
4242     instruction_count(2);
4243     dst    : S3(read);
4244     DECODE : S0(2);     // any 2 decoders
4245     FPU    : S3;
4246 %}
4247 
4248 // Float reg-reg operation
4249 pipe_class fpu_reg_reg(regD dst, regD src)
4250 %{
4251     instruction_count(2);
4252     dst    : S4(write);
4253     src    : S3(read);
4254     DECODE : S0(2);     // any 2 decoders
4255     FPU    : S3;
4256 %}
4257 
4258 // Float reg-reg operation
4259 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
4260 %{
4261     instruction_count(3);
4262     dst    : S4(write);
4263     src1   : S3(read);
4264     src2   : S3(read);
4265     DECODE : S0(3);     // any 3 decoders
4266     FPU    : S3(2);
4267 %}
4268 
4269 // Float reg-reg operation
4270 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
4271 %{
4272     instruction_count(4);
4273     dst    : S4(write);
4274     src1   : S3(read);
4275     src2   : S3(read);
4276     src3   : S3(read);
4277     DECODE : S0(4);     // any 3 decoders
4278     FPU    : S3(2);
4279 %}
4280 
4281 // Float reg-reg operation
4282 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
4283 %{
4284     instruction_count(4);
4285     dst    : S4(write);
4286     src1   : S3(read);
4287     src2   : S3(read);
4288     src3   : S3(read);
4289     DECODE : S1(3);     // any 3 decoders
4290     D0     : S0;        // Big decoder only
4291     FPU    : S3(2);
4292     MEM    : S3;
4293 %}
4294 
4295 // Float reg-mem operation
4296 pipe_class fpu_reg_mem(regD dst, memory mem)
4297 %{
4298     instruction_count(2);
4299     dst    : S5(write);
4300     mem    : S3(read);
4301     D0     : S0;        // big decoder only
4302     DECODE : S1;        // any decoder for FPU POP
4303     FPU    : S4;
4304     MEM    : S3;        // any mem
4305 %}
4306 
4307 // Float reg-mem operation
4308 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
4309 %{
4310     instruction_count(3);
4311     dst    : S5(write);
4312     src1   : S3(read);
4313     mem    : S3(read);
4314     D0     : S0;        // big decoder only
4315     DECODE : S1(2);     // any decoder for FPU POP
4316     FPU    : S4;
4317     MEM    : S3;        // any mem
4318 %}
4319 
4320 // Float mem-reg operation
4321 pipe_class fpu_mem_reg(memory mem, regD src)
4322 %{
4323     instruction_count(2);
4324     src    : S5(read);
4325     mem    : S3(read);
4326     DECODE : S0;        // any decoder for FPU PUSH
4327     D0     : S1;        // big decoder only
4328     FPU    : S4;
4329     MEM    : S3;        // any mem
4330 %}
4331 
4332 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
4333 %{
4334     instruction_count(3);
4335     src1   : S3(read);
4336     src2   : S3(read);
4337     mem    : S3(read);
4338     DECODE : S0(2);     // any decoder for FPU PUSH
4339     D0     : S1;        // big decoder only
4340     FPU    : S4;
4341     MEM    : S3;        // any mem
4342 %}
4343 
4344 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
4345 %{
4346     instruction_count(3);
4347     src1   : S3(read);
4348     src2   : S3(read);
4349     mem    : S4(read);
4350     DECODE : S0;        // any decoder for FPU PUSH
4351     D0     : S0(2);     // big decoder only
4352     FPU    : S4;
4353     MEM    : S3(2);     // any mem
4354 %}
4355 
4356 pipe_class fpu_mem_mem(memory dst, memory src1)
4357 %{
4358     instruction_count(2);
4359     src1   : S3(read);
4360     dst    : S4(read);
4361     D0     : S0(2);     // big decoder only
4362     MEM    : S3(2);     // any mem
4363 %}
4364 
4365 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
4366 %{
4367     instruction_count(3);
4368     src1   : S3(read);
4369     src2   : S3(read);
4370     dst    : S4(read);
4371     D0     : S0(3);     // big decoder only
4372     FPU    : S4;
4373     MEM    : S3(3);     // any mem
4374 %}
4375 
4376 pipe_class fpu_mem_reg_con(memory mem, regD src1)
4377 %{
4378     instruction_count(3);
4379     src1   : S4(read);
4380     mem    : S4(read);
4381     DECODE : S0;        // any decoder for FPU PUSH
4382     D0     : S0(2);     // big decoder only
4383     FPU    : S4;
4384     MEM    : S3(2);     // any mem
4385 %}
4386 
4387 // Float load constant
4388 pipe_class fpu_reg_con(regD dst)
4389 %{
4390     instruction_count(2);
4391     dst    : S5(write);
4392     D0     : S0;        // big decoder only for the load
4393     DECODE : S1;        // any decoder for FPU POP
4394     FPU    : S4;
4395     MEM    : S3;        // any mem
4396 %}
4397 
4398 // Float load constant
4399 pipe_class fpu_reg_reg_con(regD dst, regD src)
4400 %{
4401     instruction_count(3);
4402     dst    : S5(write);
4403     src    : S3(read);
4404     D0     : S0;        // big decoder only for the load
4405     DECODE : S1(2);     // any decoder for FPU POP
4406     FPU    : S4;
4407     MEM    : S3;        // any mem
4408 %}
4409 
4410 // UnConditional branch
4411 pipe_class pipe_jmp(label labl)
4412 %{
4413     single_instruction;
4414     BR   : S3;
4415 %}
4416 
4417 // Conditional branch
4418 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
4419 %{
4420     single_instruction;
4421     cr    : S1(read);
4422     BR    : S3;
4423 %}
4424 
4425 // Allocation idiom
4426 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
4427 %{
4428     instruction_count(1); force_serialization;
4429     fixed_latency(6);
4430     heap_ptr : S3(read);
4431     DECODE   : S0(3);
4432     D0       : S2;
4433     MEM      : S3;
4434     ALU      : S3(2);
4435     dst      : S5(write);
4436     BR       : S5;
4437 %}
4438 
4439 // Generic big/slow expanded idiom
4440 pipe_class pipe_slow()
4441 %{
4442     instruction_count(10); multiple_bundles; force_serialization;
4443     fixed_latency(100);
4444     D0  : S0(2);
4445     MEM : S3(2);
4446 %}
4447 
4448 // The real do-nothing guy
4449 pipe_class empty()
4450 %{
4451     instruction_count(0);
4452 %}
4453 
4454 // Define the class for the Nop node
4455 define
4456 %{
4457    MachNop = empty;
4458 %}
4459 
4460 %}
4461 
4462 //----------INSTRUCTIONS-------------------------------------------------------
4463 //
4464 // match      -- States which machine-independent subtree may be replaced
4465 //               by this instruction.
4466 // ins_cost   -- The estimated cost of this instruction is used by instruction
4467 //               selection to identify a minimum cost tree of machine
4468 //               instructions that matches a tree of machine-independent
4469 //               instructions.
4470 // format     -- A string providing the disassembly for this instruction.
4471 //               The value of an instruction's operand may be inserted
4472 //               by referring to it with a '$' prefix.
4473 // opcode     -- Three instruction opcodes may be provided.  These are referred
4474 //               to within an encode class as $primary, $secondary, and $tertiary
4475 //               rrspectively.  The primary opcode is commonly used to
4476 //               indicate the type of machine instruction, while secondary
4477 //               and tertiary are often used for prefix options or addressing
4478 //               modes.
4479 // ins_encode -- A list of encode classes with parameters. The encode class
4480 //               name must have been defined in an 'enc_class' specification
4481 //               in the encode section of the architecture description.
4482 
4483 
4484 //----------Load/Store/Move Instructions---------------------------------------
4485 //----------Load Instructions--------------------------------------------------
4486 
4487 // Load Byte (8 bit signed)
4488 instruct loadB(rRegI dst, memory mem)
4489 %{
4490   match(Set dst (LoadB mem));
4491 
4492   ins_cost(125);
4493   format %{ "movsbl  $dst, $mem\t# byte" %}
4494 
4495   ins_encode %{
4496     __ movsbl($dst$$Register, $mem$$Address);
4497   %}
4498 
4499   ins_pipe(ialu_reg_mem);
4500 %}
4501 
4502 // Load Byte (8 bit signed) into Long Register
4503 instruct loadB2L(rRegL dst, memory mem)
4504 %{
4505   match(Set dst (ConvI2L (LoadB mem)));
4506 
4507   ins_cost(125);
4508   format %{ "movsbq  $dst, $mem\t# byte -&gt; long" %}
4509 
4510   ins_encode %{
4511     __ movsbq($dst$$Register, $mem$$Address);
4512   %}
4513 
4514   ins_pipe(ialu_reg_mem);
4515 %}
4516 
4517 // Load Unsigned Byte (8 bit UNsigned)
4518 instruct loadUB(rRegI dst, memory mem)
4519 %{
4520   match(Set dst (LoadUB mem));
4521 
4522   ins_cost(125);
4523   format %{ "movzbl  $dst, $mem\t# ubyte" %}
4524 
4525   ins_encode %{
4526     __ movzbl($dst$$Register, $mem$$Address);
4527   %}
4528 
4529   ins_pipe(ialu_reg_mem);
4530 %}
4531 
4532 // Load Unsigned Byte (8 bit UNsigned) into Long Register
4533 instruct loadUB2L(rRegL dst, memory mem)
4534 %{
4535   match(Set dst (ConvI2L (LoadUB mem)));
4536 
4537   ins_cost(125);
4538   format %{ "movzbq  $dst, $mem\t# ubyte -&gt; long" %}
4539 
4540   ins_encode %{
4541     __ movzbq($dst$$Register, $mem$$Address);
4542   %}
4543 
4544   ins_pipe(ialu_reg_mem);
4545 %}
4546 
4547 // Load Unsigned Byte (8 bit UNsigned) with a 8-bit mask into Long Register
4548 instruct loadUB2L_immI8(rRegL dst, memory mem, immI8 mask, rFlagsReg cr) %{
4549   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
4550   effect(KILL cr);
4551 
4552   format %{ "movzbq  $dst, $mem\t# ubyte &amp; 8-bit mask -&gt; long\n\t"
4553             "andl    $dst, $mask" %}
4554   ins_encode %{
4555     Register Rdst = $dst$$Register;
4556     __ movzbq(Rdst, $mem$$Address);
4557     __ andl(Rdst, $mask$$constant);
4558   %}
4559   ins_pipe(ialu_reg_mem);
4560 %}
4561 
4562 // Load Short (16 bit signed)
4563 instruct loadS(rRegI dst, memory mem)
4564 %{
4565   match(Set dst (LoadS mem));
4566 
4567   ins_cost(125);
4568   format %{ "movswl $dst, $mem\t# short" %}
4569 
4570   ins_encode %{
4571     __ movswl($dst$$Register, $mem$$Address);
4572   %}
4573 
4574   ins_pipe(ialu_reg_mem);
4575 %}
4576 
4577 // Load Short (16 bit signed) to Byte (8 bit signed)
4578 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4579   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
4580 
4581   ins_cost(125);
4582   format %{ "movsbl $dst, $mem\t# short -&gt; byte" %}
4583   ins_encode %{
4584     __ movsbl($dst$$Register, $mem$$Address);
4585   %}
4586   ins_pipe(ialu_reg_mem);
4587 %}
4588 
4589 // Load Short (16 bit signed) into Long Register
4590 instruct loadS2L(rRegL dst, memory mem)
4591 %{
4592   match(Set dst (ConvI2L (LoadS mem)));
4593 
4594   ins_cost(125);
4595   format %{ "movswq $dst, $mem\t# short -&gt; long" %}
4596 
4597   ins_encode %{
4598     __ movswq($dst$$Register, $mem$$Address);
4599   %}
4600 
4601   ins_pipe(ialu_reg_mem);
4602 %}
4603 
4604 // Load Unsigned Short/Char (16 bit UNsigned)
4605 instruct loadUS(rRegI dst, memory mem)
4606 %{
4607   match(Set dst (LoadUS mem));
4608 
4609   ins_cost(125);
4610   format %{ "movzwl  $dst, $mem\t# ushort/char" %}
4611 
4612   ins_encode %{
4613     __ movzwl($dst$$Register, $mem$$Address);
4614   %}
4615 
4616   ins_pipe(ialu_reg_mem);
4617 %}
4618 
4619 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
4620 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4621   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
4622 
4623   ins_cost(125);
4624   format %{ "movsbl $dst, $mem\t# ushort -&gt; byte" %}
4625   ins_encode %{
4626     __ movsbl($dst$$Register, $mem$$Address);
4627   %}
4628   ins_pipe(ialu_reg_mem);
4629 %}
4630 
4631 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
4632 instruct loadUS2L(rRegL dst, memory mem)
4633 %{
4634   match(Set dst (ConvI2L (LoadUS mem)));
4635 
4636   ins_cost(125);
4637   format %{ "movzwq  $dst, $mem\t# ushort/char -&gt; long" %}
4638 
4639   ins_encode %{
4640     __ movzwq($dst$$Register, $mem$$Address);
4641   %}
4642 
4643   ins_pipe(ialu_reg_mem);
4644 %}
4645 
4646 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
4647 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
4648   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
4649 
4650   format %{ "movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long" %}
4651   ins_encode %{
4652     __ movzbq($dst$$Register, $mem$$Address);
4653   %}
4654   ins_pipe(ialu_reg_mem);
4655 %}
4656 
4657 // Load Unsigned Short/Char (16 bit UNsigned) with mask into Long Register
4658 instruct loadUS2L_immI16(rRegL dst, memory mem, immI16 mask, rFlagsReg cr) %{
4659   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
4660   effect(KILL cr);
4661 
4662   format %{ "movzwq  $dst, $mem\t# ushort/char &amp; 16-bit mask -&gt; long\n\t"
4663             "andl    $dst, $mask" %}
4664   ins_encode %{
4665     Register Rdst = $dst$$Register;
4666     __ movzwq(Rdst, $mem$$Address);
4667     __ andl(Rdst, $mask$$constant);
4668   %}
4669   ins_pipe(ialu_reg_mem);
4670 %}
4671 
4672 // Load Integer
4673 instruct loadI(rRegI dst, memory mem)
4674 %{
4675   match(Set dst (LoadI mem));
4676 
4677   ins_cost(125);
4678   format %{ "movl    $dst, $mem\t# int" %}
4679 
4680   ins_encode %{
4681     __ movl($dst$$Register, $mem$$Address);
4682   %}
4683 
4684   ins_pipe(ialu_reg_mem);
4685 %}
4686 
4687 // Load Integer (32 bit signed) to Byte (8 bit signed)
4688 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4689   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
4690 
4691   ins_cost(125);
4692   format %{ "movsbl  $dst, $mem\t# int -&gt; byte" %}
4693   ins_encode %{
4694     __ movsbl($dst$$Register, $mem$$Address);
4695   %}
4696   ins_pipe(ialu_reg_mem);
4697 %}
4698 
4699 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
4700 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
4701   match(Set dst (AndI (LoadI mem) mask));
4702 
4703   ins_cost(125);
4704   format %{ "movzbl  $dst, $mem\t# int -&gt; ubyte" %}
4705   ins_encode %{
4706     __ movzbl($dst$$Register, $mem$$Address);
4707   %}
4708   ins_pipe(ialu_reg_mem);
4709 %}
4710 
4711 // Load Integer (32 bit signed) to Short (16 bit signed)
4712 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
4713   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
4714 
4715   ins_cost(125);
4716   format %{ "movswl  $dst, $mem\t# int -&gt; short" %}
4717   ins_encode %{
4718     __ movswl($dst$$Register, $mem$$Address);
4719   %}
4720   ins_pipe(ialu_reg_mem);
4721 %}
4722 
4723 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
4724 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
4725   match(Set dst (AndI (LoadI mem) mask));
4726 
4727   ins_cost(125);
4728   format %{ "movzwl  $dst, $mem\t# int -&gt; ushort/char" %}
4729   ins_encode %{
4730     __ movzwl($dst$$Register, $mem$$Address);
4731   %}
4732   ins_pipe(ialu_reg_mem);
4733 %}
4734 
4735 // Load Integer into Long Register
4736 instruct loadI2L(rRegL dst, memory mem)
4737 %{
4738   match(Set dst (ConvI2L (LoadI mem)));
4739 
4740   ins_cost(125);
4741   format %{ "movslq  $dst, $mem\t# int -&gt; long" %}
4742 
4743   ins_encode %{
4744     __ movslq($dst$$Register, $mem$$Address);
4745   %}
4746 
4747   ins_pipe(ialu_reg_mem);
4748 %}
4749 
4750 // Load Integer with mask 0xFF into Long Register
4751 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
4752   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4753 
4754   format %{ "movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long" %}
4755   ins_encode %{
4756     __ movzbq($dst$$Register, $mem$$Address);
4757   %}
4758   ins_pipe(ialu_reg_mem);
4759 %}
4760 
4761 // Load Integer with mask 0xFFFF into Long Register
4762 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
4763   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4764 
4765   format %{ "movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long" %}
4766   ins_encode %{
4767     __ movzwq($dst$$Register, $mem$$Address);
4768   %}
4769   ins_pipe(ialu_reg_mem);
4770 %}
4771 
4772 // Load Integer with a 31-bit mask into Long Register
4773 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
4774   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4775   effect(KILL cr);
4776 
4777   format %{ "movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t"
4778             "andl    $dst, $mask" %}
4779   ins_encode %{
4780     Register Rdst = $dst$$Register;
4781     __ movl(Rdst, $mem$$Address);
4782     __ andl(Rdst, $mask$$constant);
4783   %}
4784   ins_pipe(ialu_reg_mem);
4785 %}
4786 
4787 // Load Unsigned Integer into Long Register
4788 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask) 
4789 %{
4790   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
4791 
4792   ins_cost(125);
4793   format %{ "movl    $dst, $mem\t# uint -&gt; long" %}
4794 
4795   ins_encode %{
4796     __ movl($dst$$Register, $mem$$Address);
4797   %}
4798 
4799   ins_pipe(ialu_reg_mem);
4800 %}
4801 
4802 // Load Long
4803 instruct loadL(rRegL dst, memory mem)
4804 %{
4805   match(Set dst (LoadL mem));
4806 
4807   ins_cost(125);
4808   format %{ "movq    $dst, $mem\t# long" %}
4809 
4810   ins_encode %{
4811     __ movq($dst$$Register, $mem$$Address);
4812   %}
4813 
4814   ins_pipe(ialu_reg_mem); // XXX
4815 %}
4816 
4817 // Load Range
4818 instruct loadRange(rRegI dst, memory mem)
4819 %{
4820   match(Set dst (LoadRange mem));
4821 
4822   ins_cost(125); // XXX
4823   format %{ "movl    $dst, $mem\t# range" %}
4824   opcode(0x8B);
4825   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
4826   ins_pipe(ialu_reg_mem);
4827 %}
4828 
4829 // Load Pointer
4830 instruct loadP(rRegP dst, memory mem)
4831 %{
4832   match(Set dst (LoadP mem));
4833 
4834   ins_cost(125); // XXX
4835   format %{ "movq    $dst, $mem\t# ptr" %}
4836   opcode(0x8B);
4837   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
4838   ins_pipe(ialu_reg_mem); // XXX
4839 %}
4840 
4841 // Load Compressed Pointer
4842 instruct loadN(rRegN dst, memory mem)
4843 %{
4844    match(Set dst (LoadN mem));
4845 
4846    ins_cost(125); // XXX
4847    format %{ "movl    $dst, $mem\t# compressed ptr" %}
4848    ins_encode %{
4849      __ movl($dst$$Register, $mem$$Address);
4850    %}
4851    ins_pipe(ialu_reg_mem); // XXX
4852 %}
4853 
4854 
4855 // Load Klass Pointer
4856 instruct loadKlass(rRegP dst, memory mem)
4857 %{
4858   match(Set dst (LoadKlass mem));
4859 
4860   ins_cost(125); // XXX
4861   format %{ "movq    $dst, $mem\t# class" %}
4862   opcode(0x8B);
4863   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
4864   ins_pipe(ialu_reg_mem); // XXX
4865 %}
4866 
4867 // Load narrow Klass Pointer
4868 instruct loadNKlass(rRegN dst, memory mem)
4869 %{
4870   match(Set dst (LoadNKlass mem));
4871 
4872   ins_cost(125); // XXX
4873   format %{ "movl    $dst, $mem\t# compressed klass ptr" %}
4874   ins_encode %{
4875     __ movl($dst$$Register, $mem$$Address);
4876   %}
4877   ins_pipe(ialu_reg_mem); // XXX
4878 %}
4879 
4880 // Load Float
4881 instruct loadF(regF dst, memory mem)
4882 %{
4883   match(Set dst (LoadF mem));
4884 
4885   ins_cost(145); // XXX
4886   format %{ "movss   $dst, $mem\t# float" %}
4887   ins_encode %{
4888     __ movflt($dst$$XMMRegister, $mem$$Address);
4889   %}
4890   ins_pipe(pipe_slow); // XXX
4891 %}
4892 
4893 // Load Double
4894 instruct loadD_partial(regD dst, memory mem)
4895 %{
4896   predicate(!UseXmmLoadAndClearUpper);
4897   match(Set dst (LoadD mem));
4898 
4899   ins_cost(145); // XXX
4900   format %{ "movlpd  $dst, $mem\t# double" %}
4901   ins_encode %{
4902     __ movdbl($dst$$XMMRegister, $mem$$Address);
4903   %}
4904   ins_pipe(pipe_slow); // XXX
4905 %}
4906 
4907 instruct loadD(regD dst, memory mem)
4908 %{
4909   predicate(UseXmmLoadAndClearUpper);
4910   match(Set dst (LoadD mem));
4911 
4912   ins_cost(145); // XXX
4913   format %{ "movsd   $dst, $mem\t# double" %}
4914   ins_encode %{
4915     __ movdbl($dst$$XMMRegister, $mem$$Address);
4916   %}
4917   ins_pipe(pipe_slow); // XXX
4918 %}
4919 
4920 // Load Effective Address
4921 instruct leaP8(rRegP dst, indOffset8 mem)
4922 %{
4923   match(Set dst mem);
4924 
4925   ins_cost(110); // XXX
4926   format %{ "leaq    $dst, $mem\t# ptr 8" %}
4927   opcode(0x8D);
4928   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
4929   ins_pipe(ialu_reg_reg_fat);
4930 %}
4931 
4932 instruct leaP32(rRegP dst, indOffset32 mem)
4933 %{
4934   match(Set dst mem);
4935 
4936   ins_cost(110);
4937   format %{ "leaq    $dst, $mem\t# ptr 32" %}
4938   opcode(0x8D);
4939   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
4940   ins_pipe(ialu_reg_reg_fat);
4941 %}
4942 
4943 // instruct leaPIdx(rRegP dst, indIndex mem)
4944 // %{
4945 //   match(Set dst mem);
4946 
4947 //   ins_cost(110);
4948 //   format %{ "leaq    $dst, $mem\t# ptr idx" %}
4949 //   opcode(0x8D);
4950 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
4951 //   ins_pipe(ialu_reg_reg_fat);
4952 // %}
4953 
4954 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
4955 %{
4956   match(Set dst mem);
4957 
4958   ins_cost(110);
4959   format %{ "leaq    $dst, $mem\t# ptr idxoff" %}
4960   opcode(0x8D);
4961   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
4962   ins_pipe(ialu_reg_reg_fat);
4963 %}
4964 
4965 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
4966 %{
4967   match(Set dst mem);
4968 
4969   ins_cost(110);
4970   format %{ "leaq    $dst, $mem\t# ptr idxscale" %}
4971   opcode(0x8D);
4972   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
4973   ins_pipe(ialu_reg_reg_fat);
4974 %}
4975 
4976 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
4977 %{
4978   match(Set dst mem);
4979 
4980   ins_cost(110);
4981   format %{ "leaq    $dst, $mem\t# ptr idxscaleoff" %}
4982   opcode(0x8D);
4983   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
4984   ins_pipe(ialu_reg_reg_fat);
4985 %}
4986 
4987 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
4988 %{
4989   match(Set dst mem);
4990 
4991   ins_cost(110);
4992   format %{ "leaq    $dst, $mem\t# ptr posidxscaleoff" %}
4993   opcode(0x8D);
4994   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
4995   ins_pipe(ialu_reg_reg_fat);
4996 %}
4997 
4998 // Load Effective Address which uses Narrow (32-bits) oop
4999 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
5000 %{
5001   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() != 0));
5002   match(Set dst mem);
5003 
5004   ins_cost(110);
5005   format %{ "leaq    $dst, $mem\t# ptr compressedoopoff32" %}
5006   opcode(0x8D);
5007   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5008   ins_pipe(ialu_reg_reg_fat);
5009 %}
5010 
5011 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
5012 %{
5013   predicate(Universe::narrow_oop_shift() == 0);
5014   match(Set dst mem);
5015 
5016   ins_cost(110); // XXX
5017   format %{ "leaq    $dst, $mem\t# ptr off8narrow" %}
5018   opcode(0x8D);
5019   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5020   ins_pipe(ialu_reg_reg_fat);
5021 %}
5022 
5023 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
5024 %{
5025   predicate(Universe::narrow_oop_shift() == 0);
5026   match(Set dst mem);
5027 
5028   ins_cost(110);
5029   format %{ "leaq    $dst, $mem\t# ptr off32narrow" %}
5030   opcode(0x8D);
5031   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5032   ins_pipe(ialu_reg_reg_fat);
5033 %}
5034 
5035 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
5036 %{
5037   predicate(Universe::narrow_oop_shift() == 0);
5038   match(Set dst mem);
5039 
5040   ins_cost(110);
5041   format %{ "leaq    $dst, $mem\t# ptr idxoffnarrow" %}
5042   opcode(0x8D);
5043   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5044   ins_pipe(ialu_reg_reg_fat);
5045 %}
5046 
5047 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
5048 %{
5049   predicate(Universe::narrow_oop_shift() == 0);
5050   match(Set dst mem);
5051 
5052   ins_cost(110);
5053   format %{ "leaq    $dst, $mem\t# ptr idxscalenarrow" %}
5054   opcode(0x8D);
5055   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5056   ins_pipe(ialu_reg_reg_fat);
5057 %}
5058 
5059 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
5060 %{
5061   predicate(Universe::narrow_oop_shift() == 0);
5062   match(Set dst mem);
5063 
5064   ins_cost(110);
5065   format %{ "leaq    $dst, $mem\t# ptr idxscaleoffnarrow" %}
5066   opcode(0x8D);
5067   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5068   ins_pipe(ialu_reg_reg_fat);
5069 %}
5070 
5071 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
5072 %{
5073   predicate(Universe::narrow_oop_shift() == 0);
5074   match(Set dst mem);
5075 
5076   ins_cost(110);
5077   format %{ "leaq    $dst, $mem\t# ptr posidxscaleoffnarrow" %}
5078   opcode(0x8D);
5079   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5080   ins_pipe(ialu_reg_reg_fat);
5081 %}
5082 
5083 instruct loadConI(rRegI dst, immI src)
5084 %{
5085   match(Set dst src);
5086 
5087   format %{ "movl    $dst, $src\t# int" %}
5088   ins_encode(load_immI(dst, src));
5089   ins_pipe(ialu_reg_fat); // XXX
5090 %}
5091 
5092 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
5093 %{
5094   match(Set dst src);
5095   effect(KILL cr);
5096 
5097   ins_cost(50);
5098   format %{ "xorl    $dst, $dst\t# int" %}
5099   opcode(0x33); /* + rd */
5100   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5101   ins_pipe(ialu_reg);
5102 %}
5103 
5104 instruct loadConL(rRegL dst, immL src)
5105 %{
5106   match(Set dst src);
5107 
5108   ins_cost(150);
5109   format %{ "movq    $dst, $src\t# long" %}
5110   ins_encode(load_immL(dst, src));
5111   ins_pipe(ialu_reg);
5112 %}
5113 
5114 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
5115 %{
5116   match(Set dst src);
5117   effect(KILL cr);
5118 
5119   ins_cost(50);
5120   format %{ "xorl    $dst, $dst\t# long" %}
5121   opcode(0x33); /* + rd */
5122   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5123   ins_pipe(ialu_reg); // XXX
5124 %}
5125 
5126 instruct loadConUL32(rRegL dst, immUL32 src)
5127 %{
5128   match(Set dst src);
5129 
5130   ins_cost(60);
5131   format %{ "movl    $dst, $src\t# long (unsigned 32-bit)" %}
5132   ins_encode(load_immUL32(dst, src));
5133   ins_pipe(ialu_reg);
5134 %}
5135 
5136 instruct loadConL32(rRegL dst, immL32 src)
5137 %{
5138   match(Set dst src);
5139 
5140   ins_cost(70);
5141   format %{ "movq    $dst, $src\t# long (32-bit)" %}
5142   ins_encode(load_immL32(dst, src));
5143   ins_pipe(ialu_reg);
5144 %}
5145 
5146 instruct loadConP(rRegP dst, immP con) %{
5147   match(Set dst con);
5148 
5149   format %{ "movq    $dst, $con\t# ptr" %}
5150   ins_encode(load_immP(dst, con));
5151   ins_pipe(ialu_reg_fat); // XXX
5152 %}
5153 
5154 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
5155 %{
5156   match(Set dst src);
5157   effect(KILL cr);
5158 
5159   ins_cost(50);
5160   format %{ "xorl    $dst, $dst\t# ptr" %}
5161   opcode(0x33); /* + rd */
5162   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5163   ins_pipe(ialu_reg);
5164 %}
5165 
5166 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
5167 %{
5168   match(Set dst src);
5169   effect(KILL cr);
5170 
5171   ins_cost(60);
5172   format %{ "movl    $dst, $src\t# ptr (positive 32-bit)" %}
5173   ins_encode(load_immP31(dst, src));
5174   ins_pipe(ialu_reg);
5175 %}
5176 
5177 instruct loadConF(regF dst, immF con) %{
5178   match(Set dst con);
5179   ins_cost(125);
5180   format %{ "movss   $dst, [$constantaddress]\t# load from constant table: float=$con" %}
5181   ins_encode %{
5182     __ movflt($dst$$XMMRegister, $constantaddress($con));
5183   %}
5184   ins_pipe(pipe_slow);
5185 %}
5186 
5187 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
5188   match(Set dst src);
5189   effect(KILL cr);
5190   format %{ "xorq    $dst, $src\t# compressed NULL ptr" %}
5191   ins_encode %{
5192     __ xorq($dst$$Register, $dst$$Register);
5193   %}
5194   ins_pipe(ialu_reg);
5195 %}
5196 
5197 instruct loadConN(rRegN dst, immN src) %{
5198   match(Set dst src);
5199 
5200   ins_cost(125);
5201   format %{ "movl    $dst, $src\t# compressed ptr" %}
5202   ins_encode %{
5203     address con = (address)$src$$constant;
5204     if (con == NULL) {
5205       ShouldNotReachHere();
5206     } else {
5207       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
5208     }
5209   %}
5210   ins_pipe(ialu_reg_fat); // XXX
5211 %}
5212 
5213 instruct loadConNKlass(rRegN dst, immNKlass src) %{
5214   match(Set dst src);
5215 
5216   ins_cost(125);
5217   format %{ "movl    $dst, $src\t# compressed klass ptr" %}
5218   ins_encode %{
5219     address con = (address)$src$$constant;
5220     if (con == NULL) {
5221       ShouldNotReachHere();
5222     } else {
5223       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
5224     }
5225   %}
5226   ins_pipe(ialu_reg_fat); // XXX
5227 %}
5228 
5229 instruct loadConF0(regF dst, immF0 src)
5230 %{
5231   match(Set dst src);
5232   ins_cost(100);
5233 
5234   format %{ "xorps   $dst, $dst\t# float 0.0" %}
5235   ins_encode %{
5236     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
5237   %}
5238   ins_pipe(pipe_slow);
5239 %}
5240 
5241 // Use the same format since predicate() can not be used here.
5242 instruct loadConD(regD dst, immD con) %{
5243   match(Set dst con);
5244   ins_cost(125);
5245   format %{ "movsd   $dst, [$constantaddress]\t# load from constant table: double=$con" %}
5246   ins_encode %{
5247     __ movdbl($dst$$XMMRegister, $constantaddress($con));
5248   %}
5249   ins_pipe(pipe_slow);
5250 %}
5251 
5252 instruct loadConD0(regD dst, immD0 src)
5253 %{
5254   match(Set dst src);
5255   ins_cost(100);
5256 
5257   format %{ "xorpd   $dst, $dst\t# double 0.0" %}
5258   ins_encode %{
5259     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
5260   %}
5261   ins_pipe(pipe_slow);
5262 %}
5263 
5264 instruct loadSSI(rRegI dst, stackSlotI src)
5265 %{
5266   match(Set dst src);
5267 
5268   ins_cost(125);
5269   format %{ "movl    $dst, $src\t# int stk" %}
5270   opcode(0x8B);
5271   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
5272   ins_pipe(ialu_reg_mem);
5273 %}
5274 
5275 instruct loadSSL(rRegL dst, stackSlotL src)
5276 %{
5277   match(Set dst src);
5278 
5279   ins_cost(125);
5280   format %{ "movq    $dst, $src\t# long stk" %}
5281   opcode(0x8B);
5282   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
5283   ins_pipe(ialu_reg_mem);
5284 %}
5285 
5286 instruct loadSSP(rRegP dst, stackSlotP src)
5287 %{
5288   match(Set dst src);
5289 
5290   ins_cost(125);
5291   format %{ "movq    $dst, $src\t# ptr stk" %}
5292   opcode(0x8B);
5293   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
5294   ins_pipe(ialu_reg_mem);
5295 %}
5296 
5297 instruct loadSSF(regF dst, stackSlotF src)
5298 %{
5299   match(Set dst src);
5300 
5301   ins_cost(125);
5302   format %{ "movss   $dst, $src\t# float stk" %}
5303   ins_encode %{
5304     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
5305   %}
5306   ins_pipe(pipe_slow); // XXX
5307 %}
5308 
5309 // Use the same format since predicate() can not be used here.
5310 instruct loadSSD(regD dst, stackSlotD src)
5311 %{
5312   match(Set dst src);
5313 
5314   ins_cost(125);
5315   format %{ "movsd   $dst, $src\t# double stk" %}
5316   ins_encode  %{
5317     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
5318   %}
5319   ins_pipe(pipe_slow); // XXX
5320 %}
5321 
5322 // Prefetch instructions.
5323 // Must be safe to execute with invalid address (cannot fault).
5324 
5325 instruct prefetchr( memory mem ) %{
5326   predicate(ReadPrefetchInstr==3);
5327   match(PrefetchRead mem);
5328   ins_cost(125);
5329 
5330   format %{ "PREFETCHR $mem\t# Prefetch into level 1 cache" %}
5331   ins_encode %{
5332     __ prefetchr($mem$$Address);
5333   %}
5334   ins_pipe(ialu_mem);
5335 %}
5336 
5337 instruct prefetchrNTA( memory mem ) %{
5338   predicate(ReadPrefetchInstr==0);
5339   match(PrefetchRead mem);
5340   ins_cost(125);
5341 
5342   format %{ "PREFETCHNTA $mem\t# Prefetch into non-temporal cache for read" %}
5343   ins_encode %{
5344     __ prefetchnta($mem$$Address);
5345   %}
5346   ins_pipe(ialu_mem);
5347 %}
5348 
5349 instruct prefetchrT0( memory mem ) %{
5350   predicate(ReadPrefetchInstr==1);
5351   match(PrefetchRead mem);
5352   ins_cost(125);
5353 
5354   format %{ "PREFETCHT0 $mem\t# prefetch into L1 and L2 caches for read" %}
5355   ins_encode %{
5356     __ prefetcht0($mem$$Address);
5357   %}
5358   ins_pipe(ialu_mem);
5359 %}
5360 
5361 instruct prefetchrT2( memory mem ) %{
5362   predicate(ReadPrefetchInstr==2);
5363   match(PrefetchRead mem);
5364   ins_cost(125);
5365 
5366   format %{ "PREFETCHT2 $mem\t# prefetch into L2 caches for read" %}
5367   ins_encode %{
5368     __ prefetcht2($mem$$Address);
5369   %}
5370   ins_pipe(ialu_mem);
5371 %}
5372 
5373 instruct prefetchwNTA( memory mem ) %{
5374   match(PrefetchWrite mem);
5375   ins_cost(125);
5376 
5377   format %{ "PREFETCHNTA $mem\t# Prefetch to non-temporal cache for write" %}
5378   ins_encode %{
5379     __ prefetchnta($mem$$Address);
5380   %}
5381   ins_pipe(ialu_mem);
5382 %}
5383 
5384 // Prefetch instructions for allocation.
5385 
5386 instruct prefetchAlloc( memory mem ) %{
5387   predicate(AllocatePrefetchInstr==3);
5388   match(PrefetchAllocation mem);
5389   ins_cost(125);
5390 
5391   format %{ "PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified" %}
5392   ins_encode %{
5393     __ prefetchw($mem$$Address);
5394   %}
5395   ins_pipe(ialu_mem);
5396 %}
5397 
5398 instruct prefetchAllocNTA( memory mem ) %{
5399   predicate(AllocatePrefetchInstr==0);
5400   match(PrefetchAllocation mem);
5401   ins_cost(125);
5402 
5403   format %{ "PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write" %}
5404   ins_encode %{
5405     __ prefetchnta($mem$$Address);
5406   %}
5407   ins_pipe(ialu_mem);
5408 %}
5409 
5410 instruct prefetchAllocT0( memory mem ) %{
5411   predicate(AllocatePrefetchInstr==1);
5412   match(PrefetchAllocation mem);
5413   ins_cost(125);
5414 
5415   format %{ "PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write" %}
5416   ins_encode %{
5417     __ prefetcht0($mem$$Address);
5418   %}
5419   ins_pipe(ialu_mem);
5420 %}
5421 
5422 instruct prefetchAllocT2( memory mem ) %{
5423   predicate(AllocatePrefetchInstr==2);
5424   match(PrefetchAllocation mem);
5425   ins_cost(125);
5426 
5427   format %{ "PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write" %}
5428   ins_encode %{
5429     __ prefetcht2($mem$$Address);
5430   %}
5431   ins_pipe(ialu_mem);
5432 %}
5433 
5434 //----------Store Instructions-------------------------------------------------
5435 
5436 // Store Byte
5437 instruct storeB(memory mem, rRegI src)
5438 %{
5439   match(Set mem (StoreB mem src));
5440 
5441   ins_cost(125); // XXX
5442   format %{ "movb    $mem, $src\t# byte" %}
5443   opcode(0x88);
5444   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
5445   ins_pipe(ialu_mem_reg);
5446 %}
5447 
5448 // Store Char/Short
5449 instruct storeC(memory mem, rRegI src)
5450 %{
5451   match(Set mem (StoreC mem src));
5452 
5453   ins_cost(125); // XXX
5454   format %{ "movw    $mem, $src\t# char/short" %}
5455   opcode(0x89);
5456   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
5457   ins_pipe(ialu_mem_reg);
5458 %}
5459 
5460 // Store Integer
5461 instruct storeI(memory mem, rRegI src)
5462 %{
5463   match(Set mem (StoreI mem src));
5464 
5465   ins_cost(125); // XXX
5466   format %{ "movl    $mem, $src\t# int" %}
5467   opcode(0x89);
5468   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
5469   ins_pipe(ialu_mem_reg);
5470 %}
5471 
5472 // Store Long
5473 instruct storeL(memory mem, rRegL src)
5474 %{
5475   match(Set mem (StoreL mem src));
5476 
5477   ins_cost(125); // XXX
5478   format %{ "movq    $mem, $src\t# long" %}
5479   opcode(0x89);
5480   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
5481   ins_pipe(ialu_mem_reg); // XXX
5482 %}
5483 
5484 // Store Pointer
5485 instruct storeP(memory mem, any_RegP src)
5486 %{
5487   match(Set mem (StoreP mem src));
5488 
5489   ins_cost(125); // XXX
5490   format %{ "movq    $mem, $src\t# ptr" %}
5491   opcode(0x89);
5492   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
5493   ins_pipe(ialu_mem_reg);
5494 %}
5495 
5496 instruct storeImmP0(memory mem, immP0 zero)
5497 %{
5498   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5499   match(Set mem (StoreP mem zero));
5500 
5501   ins_cost(125); // XXX
5502   format %{ "movq    $mem, R12\t# ptr (R12_heapbase==0)" %}
5503   ins_encode %{
5504     __ movq($mem$$Address, r12);
5505   %}
5506   ins_pipe(ialu_mem_reg);
5507 %}
5508 
5509 // Store NULL Pointer, mark word, or other simple pointer constant.
5510 instruct storeImmP(memory mem, immP31 src)
5511 %{
5512   match(Set mem (StoreP mem src));
5513 
5514   ins_cost(150); // XXX
5515   format %{ "movq    $mem, $src\t# ptr" %}
5516   opcode(0xC7); /* C7 /0 */
5517   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5518   ins_pipe(ialu_mem_imm);
5519 %}
5520 
5521 // Store Compressed Pointer
5522 instruct storeN(memory mem, rRegN src)
5523 %{
5524   match(Set mem (StoreN mem src));
5525 
5526   ins_cost(125); // XXX
5527   format %{ "movl    $mem, $src\t# compressed ptr" %}
5528   ins_encode %{
5529     __ movl($mem$$Address, $src$$Register);
5530   %}
5531   ins_pipe(ialu_mem_reg);
5532 %}
5533 
5534 instruct storeNKlass(memory mem, rRegN src)
5535 %{
5536   match(Set mem (StoreNKlass mem src));
5537 
5538   ins_cost(125); // XXX
5539   format %{ "movl    $mem, $src\t# compressed klass ptr" %}
5540   ins_encode %{
5541     __ movl($mem$$Address, $src$$Register);
5542   %}
5543   ins_pipe(ialu_mem_reg);
5544 %}
5545 
5546 instruct storeImmN0(memory mem, immN0 zero)
5547 %{
5548   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_klass_base() == NULL);
5549   match(Set mem (StoreN mem zero));
5550 
5551   ins_cost(125); // XXX
5552   format %{ "movl    $mem, R12\t# compressed ptr (R12_heapbase==0)" %}
5553   ins_encode %{
5554     __ movl($mem$$Address, r12);
5555   %}
5556   ins_pipe(ialu_mem_reg);
5557 %}
5558 
5559 instruct storeImmN(memory mem, immN src)
5560 %{
5561   match(Set mem (StoreN mem src));
5562 
5563   ins_cost(150); // XXX
5564   format %{ "movl    $mem, $src\t# compressed ptr" %}
5565   ins_encode %{
5566     address con = (address)$src$$constant;
5567     if (con == NULL) {
5568       __ movl($mem$$Address, (int32_t)0);
5569     } else {
5570       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
5571     }
5572   %}
5573   ins_pipe(ialu_mem_imm);
5574 %}
5575 
5576 instruct storeImmNKlass(memory mem, immNKlass src)
5577 %{
5578   match(Set mem (StoreNKlass mem src));
5579 
5580   ins_cost(150); // XXX
5581   format %{ "movl    $mem, $src\t# compressed klass ptr" %}
5582   ins_encode %{
5583     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
5584   %}
5585   ins_pipe(ialu_mem_imm);
5586 %}
5587 
5588 // Store Integer Immediate
5589 instruct storeImmI0(memory mem, immI0 zero)
5590 %{
5591   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5592   match(Set mem (StoreI mem zero));
5593 
5594   ins_cost(125); // XXX
5595   format %{ "movl    $mem, R12\t# int (R12_heapbase==0)" %}
5596   ins_encode %{
5597     __ movl($mem$$Address, r12);
5598   %}
5599   ins_pipe(ialu_mem_reg);
5600 %}
5601 
5602 instruct storeImmI(memory mem, immI src)
5603 %{
5604   match(Set mem (StoreI mem src));
5605 
5606   ins_cost(150);
5607   format %{ "movl    $mem, $src\t# int" %}
5608   opcode(0xC7); /* C7 /0 */
5609   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5610   ins_pipe(ialu_mem_imm);
5611 %}
5612 
5613 // Store Long Immediate
5614 instruct storeImmL0(memory mem, immL0 zero)
5615 %{
5616   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5617   match(Set mem (StoreL mem zero));
5618 
5619   ins_cost(125); // XXX
5620   format %{ "movq    $mem, R12\t# long (R12_heapbase==0)" %}
5621   ins_encode %{
5622     __ movq($mem$$Address, r12);
5623   %}
5624   ins_pipe(ialu_mem_reg);
5625 %}
5626 
5627 instruct storeImmL(memory mem, immL32 src)
5628 %{
5629   match(Set mem (StoreL mem src));
5630 
5631   ins_cost(150);
5632   format %{ "movq    $mem, $src\t# long" %}
5633   opcode(0xC7); /* C7 /0 */
5634   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5635   ins_pipe(ialu_mem_imm);
5636 %}
5637 
5638 // Store Short/Char Immediate
5639 instruct storeImmC0(memory mem, immI0 zero)
5640 %{
5641   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5642   match(Set mem (StoreC mem zero));
5643 
5644   ins_cost(125); // XXX
5645   format %{ "movw    $mem, R12\t# short/char (R12_heapbase==0)" %}
5646   ins_encode %{
5647     __ movw($mem$$Address, r12);
5648   %}
5649   ins_pipe(ialu_mem_reg);
5650 %}
5651 
5652 instruct storeImmI16(memory mem, immI16 src)
5653 %{
5654   predicate(UseStoreImmI16);
5655   match(Set mem (StoreC mem src));
5656 
5657   ins_cost(150);
5658   format %{ "movw    $mem, $src\t# short/char" %}
5659   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
5660   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
5661   ins_pipe(ialu_mem_imm);
5662 %}
5663 
5664 // Store Byte Immediate
5665 instruct storeImmB0(memory mem, immI0 zero)
5666 %{
5667   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5668   match(Set mem (StoreB mem zero));
5669 
5670   ins_cost(125); // XXX
5671   format %{ "movb    $mem, R12\t# short/char (R12_heapbase==0)" %}
5672   ins_encode %{
5673     __ movb($mem$$Address, r12);
5674   %}
5675   ins_pipe(ialu_mem_reg);
5676 %}
5677 
5678 instruct storeImmB(memory mem, immI8 src)
5679 %{
5680   match(Set mem (StoreB mem src));
5681 
5682   ins_cost(150); // XXX
5683   format %{ "movb    $mem, $src\t# byte" %}
5684   opcode(0xC6); /* C6 /0 */
5685   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
5686   ins_pipe(ialu_mem_imm);
5687 %}
5688 
5689 // Store CMS card-mark Immediate
5690 instruct storeImmCM0_reg(memory mem, immI0 zero)
5691 %{
5692   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5693   match(Set mem (StoreCM mem zero));
5694 
5695   ins_cost(125); // XXX
5696   format %{ "movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)" %}
5697   ins_encode %{
5698     __ movb($mem$$Address, r12);
5699   %}
5700   ins_pipe(ialu_mem_reg);
5701 %}
5702 
5703 instruct storeImmCM0(memory mem, immI0 src)
5704 %{
5705   match(Set mem (StoreCM mem src));
5706 
5707   ins_cost(150); // XXX
5708   format %{ "movb    $mem, $src\t# CMS card-mark byte 0" %}
5709   opcode(0xC6); /* C6 /0 */
5710   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
5711   ins_pipe(ialu_mem_imm);
5712 %}
5713 
5714 // Store Float
5715 instruct storeF(memory mem, regF src)
5716 %{
5717   match(Set mem (StoreF mem src));
5718 
5719   ins_cost(95); // XXX
5720   format %{ "movss   $mem, $src\t# float" %}
5721   ins_encode %{
5722     __ movflt($mem$$Address, $src$$XMMRegister);
5723   %}
5724   ins_pipe(pipe_slow); // XXX
5725 %}
5726 
5727 // Store immediate Float value (it is faster than store from XMM register)
5728 instruct storeF0(memory mem, immF0 zero)
5729 %{
5730   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5731   match(Set mem (StoreF mem zero));
5732 
5733   ins_cost(25); // XXX
5734   format %{ "movl    $mem, R12\t# float 0. (R12_heapbase==0)" %}
5735   ins_encode %{
5736     __ movl($mem$$Address, r12);
5737   %}
5738   ins_pipe(ialu_mem_reg);
5739 %}
5740 
5741 instruct storeF_imm(memory mem, immF src)
5742 %{
5743   match(Set mem (StoreF mem src));
5744 
5745   ins_cost(50);
5746   format %{ "movl    $mem, $src\t# float" %}
5747   opcode(0xC7); /* C7 /0 */
5748   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
5749   ins_pipe(ialu_mem_imm);
5750 %}
5751 
5752 // Store Double
5753 instruct storeD(memory mem, regD src)
5754 %{
5755   match(Set mem (StoreD mem src));
5756 
5757   ins_cost(95); // XXX
5758   format %{ "movsd   $mem, $src\t# double" %}
5759   ins_encode %{
5760     __ movdbl($mem$$Address, $src$$XMMRegister);
5761   %}
5762   ins_pipe(pipe_slow); // XXX
5763 %}
5764 
5765 // Store immediate double 0.0 (it is faster than store from XMM register)
5766 instruct storeD0_imm(memory mem, immD0 src)
5767 %{
5768   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));
5769   match(Set mem (StoreD mem src));
5770 
5771   ins_cost(50);
5772   format %{ "movq    $mem, $src\t# double 0." %}
5773   opcode(0xC7); /* C7 /0 */
5774   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
5775   ins_pipe(ialu_mem_imm);
5776 %}
5777 
5778 instruct storeD0(memory mem, immD0 zero)
5779 %{
5780   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5781   match(Set mem (StoreD mem zero));
5782 
5783   ins_cost(25); // XXX
5784   format %{ "movq    $mem, R12\t# double 0. (R12_heapbase==0)" %}
5785   ins_encode %{
5786     __ movq($mem$$Address, r12);
5787   %}
5788   ins_pipe(ialu_mem_reg);
5789 %}
5790 
5791 instruct storeSSI(stackSlotI dst, rRegI src)
5792 %{
5793   match(Set dst src);
5794 
5795   ins_cost(100);
5796   format %{ "movl    $dst, $src\t# int stk" %}
5797   opcode(0x89);
5798   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
5799   ins_pipe( ialu_mem_reg );
5800 %}
5801 
5802 instruct storeSSL(stackSlotL dst, rRegL src)
5803 %{
5804   match(Set dst src);
5805 
5806   ins_cost(100);
5807   format %{ "movq    $dst, $src\t# long stk" %}
5808   opcode(0x89);
5809   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
5810   ins_pipe(ialu_mem_reg);
5811 %}
5812 
5813 instruct storeSSP(stackSlotP dst, rRegP src)
5814 %{
5815   match(Set dst src);
5816 
5817   ins_cost(100);
5818   format %{ "movq    $dst, $src\t# ptr stk" %}
5819   opcode(0x89);
5820   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
5821   ins_pipe(ialu_mem_reg);
5822 %}
5823 
5824 instruct storeSSF(stackSlotF dst, regF src)
5825 %{
5826   match(Set dst src);
5827 
5828   ins_cost(95); // XXX
5829   format %{ "movss   $dst, $src\t# float stk" %}
5830   ins_encode %{
5831     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
5832   %}
5833   ins_pipe(pipe_slow); // XXX
5834 %}
5835 
5836 instruct storeSSD(stackSlotD dst, regD src)
5837 %{
5838   match(Set dst src);
5839 
5840   ins_cost(95); // XXX
5841   format %{ "movsd   $dst, $src\t# double stk" %}
5842   ins_encode %{
5843     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
5844   %}
5845   ins_pipe(pipe_slow); // XXX
5846 %}
5847 
5848 //----------BSWAP Instructions-------------------------------------------------
5849 instruct bytes_reverse_int(rRegI dst) %{
5850   match(Set dst (ReverseBytesI dst));
5851 
5852   format %{ "bswapl  $dst" %}
5853   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
5854   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
5855   ins_pipe( ialu_reg );
5856 %}
5857 
5858 instruct bytes_reverse_long(rRegL dst) %{
5859   match(Set dst (ReverseBytesL dst));
5860 
5861   format %{ "bswapq  $dst" %}
5862   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
5863   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
5864   ins_pipe( ialu_reg);
5865 %}
5866 
5867 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
5868   match(Set dst (ReverseBytesUS dst));
5869   effect(KILL cr);
5870 
5871   format %{ "bswapl  $dst\n\t"
5872             "shrl    $dst,16\n\t" %}
5873   ins_encode %{
5874     __ bswapl($dst$$Register);
5875     __ shrl($dst$$Register, 16);
5876   %}
5877   ins_pipe( ialu_reg );
5878 %}
5879 
5880 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
5881   match(Set dst (ReverseBytesS dst));
5882   effect(KILL cr);
5883 
5884   format %{ "bswapl  $dst\n\t"
5885             "sar     $dst,16\n\t" %}
5886   ins_encode %{
5887     __ bswapl($dst$$Register);
5888     __ sarl($dst$$Register, 16);
5889   %}
5890   ins_pipe( ialu_reg );
5891 %}
5892 
5893 //---------- Zeros Count Instructions ------------------------------------------
5894 
5895 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
5896   predicate(UseCountLeadingZerosInstruction);
5897   match(Set dst (CountLeadingZerosI src));
5898   effect(KILL cr);
5899 
5900   format %{ "lzcntl  $dst, $src\t# count leading zeros (int)" %}
5901   ins_encode %{
5902     __ lzcntl($dst$$Register, $src$$Register);
5903   %}
5904   ins_pipe(ialu_reg);
5905 %}
5906 
5907 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
5908   predicate(!UseCountLeadingZerosInstruction);
5909   match(Set dst (CountLeadingZerosI src));
5910   effect(KILL cr);
5911 
5912   format %{ "bsrl    $dst, $src\t# count leading zeros (int)\n\t"
5913             "jnz     skip\n\t"
5914             "movl    $dst, -1\n"
5915       "skip:\n\t"
5916             "negl    $dst\n\t"
5917             "addl    $dst, 31" %}
5918   ins_encode %{
5919     Register Rdst = $dst$$Register;
5920     Register Rsrc = $src$$Register;
5921     Label skip;
5922     __ bsrl(Rdst, Rsrc);
5923     __ jccb(Assembler::notZero, skip);
5924     __ movl(Rdst, -1);
5925     __ bind(skip);
5926     __ negl(Rdst);
5927     __ addl(Rdst, BitsPerInt - 1);
5928   %}
5929   ins_pipe(ialu_reg);
5930 %}
5931 
5932 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
5933   predicate(UseCountLeadingZerosInstruction);
5934   match(Set dst (CountLeadingZerosL src));
5935   effect(KILL cr);
5936 
5937   format %{ "lzcntq  $dst, $src\t# count leading zeros (long)" %}
5938   ins_encode %{
5939     __ lzcntq($dst$$Register, $src$$Register);
5940   %}
5941   ins_pipe(ialu_reg);
5942 %}
5943 
5944 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
5945   predicate(!UseCountLeadingZerosInstruction);
5946   match(Set dst (CountLeadingZerosL src));
5947   effect(KILL cr);
5948 
5949   format %{ "bsrq    $dst, $src\t# count leading zeros (long)\n\t"
5950             "jnz     skip\n\t"
5951             "movl    $dst, -1\n"
5952       "skip:\n\t"
5953             "negl    $dst\n\t"
5954             "addl    $dst, 63" %}
5955   ins_encode %{
5956     Register Rdst = $dst$$Register;
5957     Register Rsrc = $src$$Register;
5958     Label skip;
5959     __ bsrq(Rdst, Rsrc);
5960     __ jccb(Assembler::notZero, skip);
5961     __ movl(Rdst, -1);
5962     __ bind(skip);
5963     __ negl(Rdst);
5964     __ addl(Rdst, BitsPerLong - 1);
5965   %}
5966   ins_pipe(ialu_reg);
5967 %}
5968 
5969 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
5970   predicate(UseCountTrailingZerosInstruction);
5971   match(Set dst (CountTrailingZerosI src));
5972   effect(KILL cr);
5973 
5974   format %{ "tzcntl    $dst, $src\t# count trailing zeros (int)" %}
5975   ins_encode %{
5976     __ tzcntl($dst$$Register, $src$$Register);
5977   %}
5978   ins_pipe(ialu_reg);
5979 %}
5980 
5981 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
5982   predicate(!UseCountTrailingZerosInstruction);
5983   match(Set dst (CountTrailingZerosI src));
5984   effect(KILL cr);
5985 
5986   format %{ "bsfl    $dst, $src\t# count trailing zeros (int)\n\t"
5987             "jnz     done\n\t"
5988             "movl    $dst, 32\n"
5989       "done:" %}
5990   ins_encode %{
5991     Register Rdst = $dst$$Register;
5992     Label done;
5993     __ bsfl(Rdst, $src$$Register);
5994     __ jccb(Assembler::notZero, done);
5995     __ movl(Rdst, BitsPerInt);
5996     __ bind(done);
5997   %}
5998   ins_pipe(ialu_reg);
5999 %}
6000 
6001 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
6002   predicate(UseCountTrailingZerosInstruction);
6003   match(Set dst (CountTrailingZerosL src));
6004   effect(KILL cr);
6005 
6006   format %{ "tzcntq    $dst, $src\t# count trailing zeros (long)" %}
6007   ins_encode %{
6008     __ tzcntq($dst$$Register, $src$$Register);
6009   %}
6010   ins_pipe(ialu_reg);
6011 %}
6012 
6013 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
6014   predicate(!UseCountTrailingZerosInstruction);
6015   match(Set dst (CountTrailingZerosL src));
6016   effect(KILL cr);
6017 
6018   format %{ "bsfq    $dst, $src\t# count trailing zeros (long)\n\t"
6019             "jnz     done\n\t"
6020             "movl    $dst, 64\n"
6021       "done:" %}
6022   ins_encode %{
6023     Register Rdst = $dst$$Register;
6024     Label done;
6025     __ bsfq(Rdst, $src$$Register);
6026     __ jccb(Assembler::notZero, done);
6027     __ movl(Rdst, BitsPerLong);
6028     __ bind(done);
6029   %}
6030   ins_pipe(ialu_reg);
6031 %}
6032 
6033 
6034 //---------- Population Count Instructions -------------------------------------
6035 
6036 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
6037   predicate(UsePopCountInstruction);
6038   match(Set dst (PopCountI src));
6039   effect(KILL cr);
6040 
6041   format %{ "popcnt  $dst, $src" %}
6042   ins_encode %{
6043     __ popcntl($dst$$Register, $src$$Register);
6044   %}
6045   ins_pipe(ialu_reg);
6046 %}
6047 
6048 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
6049   predicate(UsePopCountInstruction);
6050   match(Set dst (PopCountI (LoadI mem)));
6051   effect(KILL cr);
6052 
6053   format %{ "popcnt  $dst, $mem" %}
6054   ins_encode %{
6055     __ popcntl($dst$$Register, $mem$$Address);
6056   %}
6057   ins_pipe(ialu_reg);
6058 %}
6059 
6060 // Note: Long.bitCount(long) returns an int.
6061 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
6062   predicate(UsePopCountInstruction);
6063   match(Set dst (PopCountL src));
6064   effect(KILL cr);
6065 
6066   format %{ "popcnt  $dst, $src" %}
6067   ins_encode %{
6068     __ popcntq($dst$$Register, $src$$Register);
6069   %}
6070   ins_pipe(ialu_reg);
6071 %}
6072 
6073 // Note: Long.bitCount(long) returns an int.
6074 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
6075   predicate(UsePopCountInstruction);
6076   match(Set dst (PopCountL (LoadL mem)));
6077   effect(KILL cr);
6078 
6079   format %{ "popcnt  $dst, $mem" %}
6080   ins_encode %{
6081     __ popcntq($dst$$Register, $mem$$Address);
6082   %}
6083   ins_pipe(ialu_reg);
6084 %}
6085 
6086 
6087 //----------MemBar Instructions-----------------------------------------------
6088 // Memory barrier flavors
6089 
6090 instruct membar_acquire()
6091 %{
6092   match(MemBarAcquire);
6093   match(LoadFence);
6094   ins_cost(0);
6095 
6096   size(0);
6097   format %{ "MEMBAR-acquire ! (empty encoding)" %}
6098   ins_encode();
6099   ins_pipe(empty);
6100 %}
6101 
6102 instruct membar_acquire_lock()
6103 %{
6104   match(MemBarAcquireLock);
6105   ins_cost(0);
6106 
6107   size(0);
6108   format %{ "MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)" %}
6109   ins_encode();
6110   ins_pipe(empty);
6111 %}
6112 
6113 instruct membar_release()
6114 %{
6115   match(MemBarRelease);
6116   match(StoreFence);
6117   ins_cost(0);
6118 
6119   size(0);
6120   format %{ "MEMBAR-release ! (empty encoding)" %}
6121   ins_encode();
6122   ins_pipe(empty);
6123 %}
6124 
6125 instruct membar_release_lock()
6126 %{
6127   match(MemBarReleaseLock);
6128   ins_cost(0);
6129 
6130   size(0);
6131   format %{ "MEMBAR-release (a FastUnlock follows so empty encoding)" %}
6132   ins_encode();
6133   ins_pipe(empty);
6134 %}
6135 
6136 instruct membar_volatile(rFlagsReg cr) %{
6137   match(MemBarVolatile);
6138   effect(KILL cr);
6139   ins_cost(400);
6140 
6141   format %{
6142     $$template
6143     if (os::is_MP()) {
6144       $$emit$$"lock addl [rsp + #0], 0\t! membar_volatile"
6145     } else {
6146       $$emit$$"MEMBAR-volatile ! (empty encoding)"
6147     }
6148   %}
6149   ins_encode %{
6150     __ membar(Assembler::StoreLoad);
6151   %}
6152   ins_pipe(pipe_slow);
6153 %}
6154 
6155 instruct unnecessary_membar_volatile()
6156 %{
6157   match(MemBarVolatile);
6158   predicate(Matcher::post_store_load_barrier(n));
6159   ins_cost(0);
6160 
6161   size(0);
6162   format %{ "MEMBAR-volatile (unnecessary so empty encoding)" %}
6163   ins_encode();
6164   ins_pipe(empty);
6165 %}
6166 
6167 instruct membar_storestore() %{
6168   match(MemBarStoreStore);
6169   ins_cost(0);
6170 
6171   size(0);
6172   format %{ "MEMBAR-storestore (empty encoding)" %}
6173   ins_encode( );
6174   ins_pipe(empty);
6175 %}
6176 
6177 //----------Move Instructions--------------------------------------------------
6178 
6179 instruct castX2P(rRegP dst, rRegL src)
6180 %{
6181   match(Set dst (CastX2P src));
6182 
6183   format %{ "movq    $dst, $src\t# long-&gt;ptr" %}
6184   ins_encode %{
6185     if ($dst$$reg != $src$$reg) {
6186       __ movptr($dst$$Register, $src$$Register);
6187     }
6188   %}
6189   ins_pipe(ialu_reg_reg); // XXX
6190 %}
6191 
6192 instruct castP2X(rRegL dst, rRegP src)
6193 %{
6194   match(Set dst (CastP2X src));
6195 
6196   format %{ "movq    $dst, $src\t# ptr -&gt; long" %}
6197   ins_encode %{
6198     if ($dst$$reg != $src$$reg) {
6199       __ movptr($dst$$Register, $src$$Register);
6200     }
6201   %}
6202   ins_pipe(ialu_reg_reg); // XXX
6203 %}
6204 
6205 // Convert oop into int for vectors alignment masking
6206 instruct convP2I(rRegI dst, rRegP src)
6207 %{
6208   match(Set dst (ConvL2I (CastP2X src)));
6209 
6210   format %{ "movl    $dst, $src\t# ptr -&gt; int" %}
6211   ins_encode %{
6212     __ movl($dst$$Register, $src$$Register);
6213   %}
6214   ins_pipe(ialu_reg_reg); // XXX
6215 %}
6216 
6217 // Convert compressed oop into int for vectors alignment masking
6218 // in case of 32bit oops (heap &lt; 4Gb).
6219 instruct convN2I(rRegI dst, rRegN src)
6220 %{
6221   predicate(Universe::narrow_oop_shift() == 0);
6222   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
6223 
6224   format %{ "movl    $dst, $src\t# compressed ptr -&gt; int" %}
6225   ins_encode %{
6226     __ movl($dst$$Register, $src$$Register);
6227   %}
6228   ins_pipe(ialu_reg_reg); // XXX
6229 %}
6230 
6231 // Convert oop pointer into compressed form
6232 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
6233   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
6234   match(Set dst (EncodeP src));
6235   effect(KILL cr);
6236   format %{ "encode_heap_oop $dst,$src" %}
6237   ins_encode %{
6238     Register s = $src$$Register;
6239     Register d = $dst$$Register;
6240     if (s != d) {
6241       __ movq(d, s);
6242     }
6243     __ encode_heap_oop(d);
6244   %}
6245   ins_pipe(ialu_reg_long);
6246 %}
6247 
6248 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
6249   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
6250   match(Set dst (EncodeP src));
6251   effect(KILL cr);
6252   format %{ "encode_heap_oop_not_null $dst,$src" %}
6253   ins_encode %{
6254     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
6255   %}
6256   ins_pipe(ialu_reg_long);
6257 %}
6258 
6259 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
6260   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
6261             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
6262   match(Set dst (DecodeN src));
6263   effect(KILL cr);
6264   format %{ "decode_heap_oop $dst,$src" %}
6265   ins_encode %{
6266     Register s = $src$$Register;
6267     Register d = $dst$$Register;
6268     if (s != d) {
6269       __ movq(d, s);
6270     }
6271     __ decode_heap_oop(d);
6272   %}
6273   ins_pipe(ialu_reg_long);
6274 %}
6275 
6276 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
6277   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
6278             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
6279   match(Set dst (DecodeN src));
6280   effect(KILL cr);
6281   format %{ "decode_heap_oop_not_null $dst,$src" %}
6282   ins_encode %{
6283     Register s = $src$$Register;
6284     Register d = $dst$$Register;
6285     if (s != d) {
6286       __ decode_heap_oop_not_null(d, s);
6287     } else {
6288       __ decode_heap_oop_not_null(d);
6289     }
6290   %}
6291   ins_pipe(ialu_reg_long);
6292 %}
6293 
6294 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
6295   match(Set dst (EncodePKlass src));
6296   effect(KILL cr);
6297   format %{ "encode_klass_not_null $dst,$src" %}
6298   ins_encode %{
6299     __ encode_klass_not_null($dst$$Register, $src$$Register);
6300   %}
6301   ins_pipe(ialu_reg_long);
6302 %}
6303 
6304 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
6305   match(Set dst (DecodeNKlass src));
6306   effect(KILL cr);
6307   format %{ "decode_klass_not_null $dst,$src" %}
6308   ins_encode %{
6309     Register s = $src$$Register;
6310     Register d = $dst$$Register;
6311     if (s != d) {
6312       __ decode_klass_not_null(d, s);
6313     } else {
6314       __ decode_klass_not_null(d);
6315     }
6316   %}
6317   ins_pipe(ialu_reg_long);
6318 %}
6319 
6320 
6321 //----------Conditional Move---------------------------------------------------
6322 // Jump
6323 // dummy instruction for generating temp registers
6324 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
6325   match(Jump (LShiftL switch_val shift));
6326   ins_cost(350);
6327   predicate(false);
6328   effect(TEMP dest);
6329 
6330   format %{ "leaq    $dest, [$constantaddress]\n\t"
6331             "jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t" %}
6332   ins_encode %{
6333     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6334     // to do that and the compiler is using that register as one it can allocate.
6335     // So we build it all by hand.
6336     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
6337     // ArrayAddress dispatch(table, index);
6338     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
6339     __ lea($dest$$Register, $constantaddress);
6340     __ jmp(dispatch);
6341   %}
6342   ins_pipe(pipe_jmp);
6343 %}
6344 
6345 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
6346   match(Jump (AddL (LShiftL switch_val shift) offset));
6347   ins_cost(350);
6348   effect(TEMP dest);
6349 
6350   format %{ "leaq    $dest, [$constantaddress]\n\t"
6351             "jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t" %}
6352   ins_encode %{
6353     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6354     // to do that and the compiler is using that register as one it can allocate.
6355     // So we build it all by hand.
6356     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
6357     // ArrayAddress dispatch(table, index);
6358     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
6359     __ lea($dest$$Register, $constantaddress);
6360     __ jmp(dispatch);
6361   %}
6362   ins_pipe(pipe_jmp);
6363 %}
6364 
6365 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
6366   match(Jump switch_val);
6367   ins_cost(350);
6368   effect(TEMP dest);
6369 
6370   format %{ "leaq    $dest, [$constantaddress]\n\t"
6371             "jmp     [$dest + $switch_val]\n\t" %}
6372   ins_encode %{
6373     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6374     // to do that and the compiler is using that register as one it can allocate.
6375     // So we build it all by hand.
6376     // Address index(noreg, switch_reg, Address::times_1);
6377     // ArrayAddress dispatch(table, index);
6378     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
6379     __ lea($dest$$Register, $constantaddress);
6380     __ jmp(dispatch);
6381   %}
6382   ins_pipe(pipe_jmp);
6383 %}
6384 
6385 // Conditional move
6386 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
6387 %{
6388   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6389 
6390   ins_cost(200); // XXX
6391   format %{ "cmovl$cop $dst, $src\t# signed, int" %}
6392   opcode(0x0F, 0x40);
6393   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6394   ins_pipe(pipe_cmov_reg);
6395 %}
6396 
6397 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
6398   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6399 
6400   ins_cost(200); // XXX
6401   format %{ "cmovl$cop $dst, $src\t# unsigned, int" %}
6402   opcode(0x0F, 0x40);
6403   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6404   ins_pipe(pipe_cmov_reg);
6405 %}
6406 
6407 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
6408   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6409   ins_cost(200);
6410   expand %{
6411     cmovI_regU(cop, cr, dst, src);
6412   %}
6413 %}
6414 
6415 // Conditional move
6416 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
6417   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6418 
6419   ins_cost(250); // XXX
6420   format %{ "cmovl$cop $dst, $src\t# signed, int" %}
6421   opcode(0x0F, 0x40);
6422   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
6423   ins_pipe(pipe_cmov_mem);
6424 %}
6425 
6426 // Conditional move
6427 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
6428 %{
6429   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6430 
6431   ins_cost(250); // XXX
6432   format %{ "cmovl$cop $dst, $src\t# unsigned, int" %}
6433   opcode(0x0F, 0x40);
6434   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
6435   ins_pipe(pipe_cmov_mem);
6436 %}
6437 
6438 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
6439   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6440   ins_cost(250);
6441   expand %{
6442     cmovI_memU(cop, cr, dst, src);
6443   %}
6444 %}
6445 
6446 // Conditional move
6447 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
6448 %{
6449   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6450 
6451   ins_cost(200); // XXX
6452   format %{ "cmovl$cop $dst, $src\t# signed, compressed ptr" %}
6453   opcode(0x0F, 0x40);
6454   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6455   ins_pipe(pipe_cmov_reg);
6456 %}
6457 
6458 // Conditional move
6459 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
6460 %{
6461   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6462 
6463   ins_cost(200); // XXX
6464   format %{ "cmovl$cop $dst, $src\t# unsigned, compressed ptr" %}
6465   opcode(0x0F, 0x40);
6466   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6467   ins_pipe(pipe_cmov_reg);
6468 %}
6469 
6470 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
6471   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6472   ins_cost(200);
6473   expand %{
6474     cmovN_regU(cop, cr, dst, src);
6475   %}
6476 %}
6477 
6478 // Conditional move
6479 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
6480 %{
6481   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6482 
6483   ins_cost(200); // XXX
6484   format %{ "cmovq$cop $dst, $src\t# signed, ptr" %}
6485   opcode(0x0F, 0x40);
6486   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6487   ins_pipe(pipe_cmov_reg);  // XXX
6488 %}
6489 
6490 // Conditional move
6491 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
6492 %{
6493   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6494 
6495   ins_cost(200); // XXX
6496   format %{ "cmovq$cop $dst, $src\t# unsigned, ptr" %}
6497   opcode(0x0F, 0x40);
6498   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6499   ins_pipe(pipe_cmov_reg); // XXX
6500 %}
6501 
6502 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
6503   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6504   ins_cost(200);
6505   expand %{
6506     cmovP_regU(cop, cr, dst, src);
6507   %}
6508 %}
6509 
6510 // DISABLED: Requires the ADLC to emit a bottom_type call that
6511 // correctly meets the two pointer arguments; one is an incoming
6512 // register but the other is a memory operand.  ALSO appears to
6513 // be buggy with implicit null checks.
6514 //
6515 //// Conditional move
6516 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
6517 //%{
6518 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
6519 //  ins_cost(250);
6520 //  format %{ "CMOV$cop $dst,$src\t# ptr" %}
6521 //  opcode(0x0F,0x40);
6522 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
6523 //  ins_pipe( pipe_cmov_mem );
6524 //%}
6525 //
6526 //// Conditional move
6527 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
6528 //%{
6529 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
6530 //  ins_cost(250);
6531 //  format %{ "CMOV$cop $dst,$src\t# ptr" %}
6532 //  opcode(0x0F,0x40);
6533 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
6534 //  ins_pipe( pipe_cmov_mem );
6535 //%}
6536 
6537 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
6538 %{
6539   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6540 
6541   ins_cost(200); // XXX
6542   format %{ "cmovq$cop $dst, $src\t# signed, long" %}
6543   opcode(0x0F, 0x40);
6544   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6545   ins_pipe(pipe_cmov_reg);  // XXX
6546 %}
6547 
6548 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
6549 %{
6550   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6551 
6552   ins_cost(200); // XXX
6553   format %{ "cmovq$cop $dst, $src\t# signed, long" %}
6554   opcode(0x0F, 0x40);
6555   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
6556   ins_pipe(pipe_cmov_mem);  // XXX
6557 %}
6558 
6559 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
6560 %{
6561   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6562 
6563   ins_cost(200); // XXX
6564   format %{ "cmovq$cop $dst, $src\t# unsigned, long" %}
6565   opcode(0x0F, 0x40);
6566   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6567   ins_pipe(pipe_cmov_reg); // XXX
6568 %}
6569 
6570 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
6571   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6572   ins_cost(200);
6573   expand %{
6574     cmovL_regU(cop, cr, dst, src);
6575   %}
6576 %}
6577 
6578 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
6579 %{
6580   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6581 
6582   ins_cost(200); // XXX
6583   format %{ "cmovq$cop $dst, $src\t# unsigned, long" %}
6584   opcode(0x0F, 0x40);
6585   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
6586   ins_pipe(pipe_cmov_mem); // XXX
6587 %}
6588 
6589 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
6590   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6591   ins_cost(200);
6592   expand %{
6593     cmovL_memU(cop, cr, dst, src);
6594   %}
6595 %}
6596 
6597 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
6598 %{
6599   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6600 
6601   ins_cost(200); // XXX
6602   format %{ "jn$cop    skip\t# signed cmove float\n\t"
6603             "movss     $dst, $src\n"
6604     "skip:" %}
6605   ins_encode %{
6606     Label Lskip;
6607     // Invert sense of branch from sense of CMOV
6608     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6609     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
6610     __ bind(Lskip);
6611   %}
6612   ins_pipe(pipe_slow);
6613 %}
6614 
6615 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
6616 // %{
6617 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
6618 
6619 //   ins_cost(200); // XXX
6620 //   format %{ "jn$cop    skip\t# signed cmove float\n\t"
6621 //             "movss     $dst, $src\n"
6622 //     "skip:" %}
6623 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
6624 //   ins_pipe(pipe_slow);
6625 // %}
6626 
6627 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
6628 %{
6629   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6630 
6631   ins_cost(200); // XXX
6632   format %{ "jn$cop    skip\t# unsigned cmove float\n\t"
6633             "movss     $dst, $src\n"
6634     "skip:" %}
6635   ins_encode %{
6636     Label Lskip;
6637     // Invert sense of branch from sense of CMOV
6638     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6639     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
6640     __ bind(Lskip);
6641   %}
6642   ins_pipe(pipe_slow);
6643 %}
6644 
6645 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
6646   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6647   ins_cost(200);
6648   expand %{
6649     cmovF_regU(cop, cr, dst, src);
6650   %}
6651 %}
6652 
6653 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
6654 %{
6655   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6656 
6657   ins_cost(200); // XXX
6658   format %{ "jn$cop    skip\t# signed cmove double\n\t"
6659             "movsd     $dst, $src\n"
6660     "skip:" %}
6661   ins_encode %{
6662     Label Lskip;
6663     // Invert sense of branch from sense of CMOV
6664     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6665     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
6666     __ bind(Lskip);
6667   %}
6668   ins_pipe(pipe_slow);
6669 %}
6670 
6671 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
6672 %{
6673   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6674 
6675   ins_cost(200); // XXX
6676   format %{ "jn$cop    skip\t# unsigned cmove double\n\t"
6677             "movsd     $dst, $src\n"
6678     "skip:" %}
6679   ins_encode %{
6680     Label Lskip;
6681     // Invert sense of branch from sense of CMOV
6682     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6683     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
6684     __ bind(Lskip);
6685   %}
6686   ins_pipe(pipe_slow);
6687 %}
6688 
6689 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
6690   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6691   ins_cost(200);
6692   expand %{
6693     cmovD_regU(cop, cr, dst, src);
6694   %}
6695 %}
6696 
6697 //----------Arithmetic Instructions--------------------------------------------
6698 //----------Addition Instructions----------------------------------------------
6699 
6700 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
6701 %{
6702   match(Set dst (AddI dst src));
6703   effect(KILL cr);
6704 
6705   format %{ "addl    $dst, $src\t# int" %}
6706   opcode(0x03);
6707   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
6708   ins_pipe(ialu_reg_reg);
6709 %}
6710 
6711 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
6712 %{
6713   match(Set dst (AddI dst src));
6714   effect(KILL cr);
6715 
6716   format %{ "addl    $dst, $src\t# int" %}
6717   opcode(0x81, 0x00); /* /0 id */
6718   ins_encode(OpcSErm(dst, src), Con8or32(src));
6719   ins_pipe( ialu_reg );
6720 %}
6721 
6722 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
6723 %{
6724   match(Set dst (AddI dst (LoadI src)));
6725   effect(KILL cr);
6726 
6727   ins_cost(125); // XXX
6728   format %{ "addl    $dst, $src\t# int" %}
6729   opcode(0x03);
6730   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
6731   ins_pipe(ialu_reg_mem);
6732 %}
6733 
6734 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
6735 %{
6736   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6737   effect(KILL cr);
6738 
6739   ins_cost(150); // XXX
6740   format %{ "addl    $dst, $src\t# int" %}
6741   opcode(0x01); /* Opcode 01 /r */
6742   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
6743   ins_pipe(ialu_mem_reg);
6744 %}
6745 
6746 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
6747 %{
6748   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6749   effect(KILL cr);
6750 
6751   ins_cost(125); // XXX
6752   format %{ "addl    $dst, $src\t# int" %}
6753   opcode(0x81); /* Opcode 81 /0 id */
6754   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
6755   ins_pipe(ialu_mem_imm);
6756 %}
6757 
6758 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
6759 %{
6760   predicate(UseIncDec);
6761   match(Set dst (AddI dst src));
6762   effect(KILL cr);
6763 
6764   format %{ "incl    $dst\t# int" %}
6765   opcode(0xFF, 0x00); // FF /0
6766   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
6767   ins_pipe(ialu_reg);
6768 %}
6769 
6770 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
6771 %{
6772   predicate(UseIncDec);
6773   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6774   effect(KILL cr);
6775 
6776   ins_cost(125); // XXX
6777   format %{ "incl    $dst\t# int" %}
6778   opcode(0xFF); /* Opcode FF /0 */
6779   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
6780   ins_pipe(ialu_mem_imm);
6781 %}
6782 
6783 // XXX why does that use AddI
6784 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
6785 %{
6786   predicate(UseIncDec);
6787   match(Set dst (AddI dst src));
6788   effect(KILL cr);
6789 
6790   format %{ "decl    $dst\t# int" %}
6791   opcode(0xFF, 0x01); // FF /1
6792   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
6793   ins_pipe(ialu_reg);
6794 %}
6795 
6796 // XXX why does that use AddI
6797 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
6798 %{
6799   predicate(UseIncDec);
6800   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6801   effect(KILL cr);
6802 
6803   ins_cost(125); // XXX
6804   format %{ "decl    $dst\t# int" %}
6805   opcode(0xFF); /* Opcode FF /1 */
6806   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
6807   ins_pipe(ialu_mem_imm);
6808 %}
6809 
6810 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
6811 %{
6812   match(Set dst (AddI src0 src1));
6813 
6814   ins_cost(110);
6815   format %{ "addr32 leal $dst, [$src0 + $src1]\t# int" %}
6816   opcode(0x8D); /* 0x8D /r */
6817   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
6818   ins_pipe(ialu_reg_reg);
6819 %}
6820 
6821 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
6822 %{
6823   match(Set dst (AddL dst src));
6824   effect(KILL cr);
6825 
6826   format %{ "addq    $dst, $src\t# long" %}
6827   opcode(0x03);
6828   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
6829   ins_pipe(ialu_reg_reg);
6830 %}
6831 
6832 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
6833 %{
6834   match(Set dst (AddL dst src));
6835   effect(KILL cr);
6836 
6837   format %{ "addq    $dst, $src\t# long" %}
6838   opcode(0x81, 0x00); /* /0 id */
6839   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
6840   ins_pipe( ialu_reg );
6841 %}
6842 
6843 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
6844 %{
6845   match(Set dst (AddL dst (LoadL src)));
6846   effect(KILL cr);
6847 
6848   ins_cost(125); // XXX
6849   format %{ "addq    $dst, $src\t# long" %}
6850   opcode(0x03);
6851   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
6852   ins_pipe(ialu_reg_mem);
6853 %}
6854 
6855 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
6856 %{
6857   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
6858   effect(KILL cr);
6859 
6860   ins_cost(150); // XXX
6861   format %{ "addq    $dst, $src\t# long" %}
6862   opcode(0x01); /* Opcode 01 /r */
6863   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
6864   ins_pipe(ialu_mem_reg);
6865 %}
6866 
6867 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
6868 %{
6869   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
6870   effect(KILL cr);
6871 
6872   ins_cost(125); // XXX
6873   format %{ "addq    $dst, $src\t# long" %}
6874   opcode(0x81); /* Opcode 81 /0 id */
6875   ins_encode(REX_mem_wide(dst),
6876              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
6877   ins_pipe(ialu_mem_imm);
6878 %}
6879 
6880 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
6881 %{
6882   predicate(UseIncDec);
6883   match(Set dst (AddL dst src));
6884   effect(KILL cr);
6885 
6886   format %{ "incq    $dst\t# long" %}
6887   opcode(0xFF, 0x00); // FF /0
6888   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
6889   ins_pipe(ialu_reg);
6890 %}
6891 
6892 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
6893 %{
6894   predicate(UseIncDec);
6895   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
6896   effect(KILL cr);
6897 
6898   ins_cost(125); // XXX
6899   format %{ "incq    $dst\t# long" %}
6900   opcode(0xFF); /* Opcode FF /0 */
6901   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
6902   ins_pipe(ialu_mem_imm);
6903 %}
6904 
6905 // XXX why does that use AddL
6906 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
6907 %{
6908   predicate(UseIncDec);
6909   match(Set dst (AddL dst src));
6910   effect(KILL cr);
6911 
6912   format %{ "decq    $dst\t# long" %}
6913   opcode(0xFF, 0x01); // FF /1
6914   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
6915   ins_pipe(ialu_reg);
6916 %}
6917 
6918 // XXX why does that use AddL
6919 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
6920 %{
6921   predicate(UseIncDec);
6922   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
6923   effect(KILL cr);
6924 
6925   ins_cost(125); // XXX
6926   format %{ "decq    $dst\t# long" %}
6927   opcode(0xFF); /* Opcode FF /1 */
6928   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
6929   ins_pipe(ialu_mem_imm);
6930 %}
6931 
6932 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
6933 %{
6934   match(Set dst (AddL src0 src1));
6935 
6936   ins_cost(110);
6937   format %{ "leaq    $dst, [$src0 + $src1]\t# long" %}
6938   opcode(0x8D); /* 0x8D /r */
6939   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
6940   ins_pipe(ialu_reg_reg);
6941 %}
6942 
6943 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
6944 %{
6945   match(Set dst (AddP dst src));
6946   effect(KILL cr);
6947 
6948   format %{ "addq    $dst, $src\t# ptr" %}
6949   opcode(0x03);
6950   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
6951   ins_pipe(ialu_reg_reg);
6952 %}
6953 
6954 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
6955 %{
6956   match(Set dst (AddP dst src));
6957   effect(KILL cr);
6958 
6959   format %{ "addq    $dst, $src\t# ptr" %}
6960   opcode(0x81, 0x00); /* /0 id */
6961   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
6962   ins_pipe( ialu_reg );
6963 %}
6964 
6965 instruct castDerived_rReg(rRegP dst, rRegL src, rFlagsReg cr)
6966 %{
6967   match(Set dst (CastDerived (AddP dst src)));
6968   effect(KILL cr);
6969 
6970   format %{ "addq    $dst, $src\t# cast derived ptr" %}
6971   opcode(0x03);
6972   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
6973   ins_pipe(ialu_reg_reg);
6974 %}
6975 
6976 instruct castDerived_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
6977 %{
6978   match(Set dst (CastDerived (AddP dst src)));
6979   effect(KILL cr);
6980 
6981   format %{ "addq    $dst, $src\t# cast derived ptr" %}
6982   opcode(0x81, 0x00); /* /0 id */
6983   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
6984   ins_pipe( ialu_reg );
6985 %}
6986 
6987 // XXX addP mem ops ????
6988 
6989 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
6990 %{
6991   match(Set dst (AddP src0 src1));
6992 
6993   ins_cost(110);
6994   format %{ "leaq    $dst, [$src0 + $src1]\t# ptr" %}
6995   opcode(0x8D); /* 0x8D /r */
6996   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
6997   ins_pipe(ialu_reg_reg);
6998 %}
6999 
7000 instruct checkCastPP(rRegP dst)
7001 %{
7002   match(Set dst (CheckCastPP dst));
7003 
7004   size(0);
7005   format %{ "# checkcastPP of $dst" %}
7006   ins_encode(/* empty encoding */);
7007   ins_pipe(empty);
7008 %}
7009 
7010 instruct castPP(rRegP dst)
7011 %{
7012   match(Set dst (CastPP dst));
7013 
7014   size(0);
7015   format %{ "# castPP of $dst" %}
7016   ins_encode(/* empty encoding */);
7017   ins_pipe(empty);
7018 %}
7019 
7020 instruct castII(rRegI dst)
7021 %{
7022   match(Set dst (CastII dst));
7023 
7024   size(0);
7025   format %{ "# castII of $dst" %}
7026   ins_encode(/* empty encoding */);
7027   ins_cost(0);
7028   ins_pipe(empty);
7029 %}
7030 
7031 // LoadP-locked same as a regular LoadP when used with compare-swap
7032 instruct loadPLocked(rRegP dst, memory mem)
7033 %{
7034   match(Set dst (LoadPLocked mem));
7035 
7036   ins_cost(125); // XXX
7037   format %{ "movq    $dst, $mem\t# ptr locked" %}
7038   opcode(0x8B);
7039   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
7040   ins_pipe(ialu_reg_mem); // XXX
7041 %}
7042 
7043 // Conditional-store of the updated heap-top.
7044 // Used during allocation of the shared heap.
7045 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
7046 
7047 instruct storePConditional(memory heap_top_ptr,
7048                            rax_RegP oldval, rRegP newval,
7049                            rFlagsReg cr)
7050 %{
7051   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
7052 
7053   format %{ "cmpxchgq $heap_top_ptr, $newval\t# (ptr) "
7054             "If rax == $heap_top_ptr then store $newval into $heap_top_ptr" %}
7055   opcode(0x0F, 0xB1);
7056   ins_encode(lock_prefix,
7057              REX_reg_mem_wide(newval, heap_top_ptr),
7058              OpcP, OpcS,
7059              reg_mem(newval, heap_top_ptr));
7060   ins_pipe(pipe_cmpxchg);
7061 %}
7062 
7063 // Conditional-store of an int value.
7064 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
7065 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
7066 %{
7067   match(Set cr (StoreIConditional mem (Binary oldval newval)));
7068   effect(KILL oldval);
7069 
7070   format %{ "cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem" %}
7071   opcode(0x0F, 0xB1);
7072   ins_encode(lock_prefix,
7073              REX_reg_mem(newval, mem),
7074              OpcP, OpcS,
7075              reg_mem(newval, mem));
7076   ins_pipe(pipe_cmpxchg);
7077 %}
7078 
7079 // Conditional-store of a long value.
7080 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
7081 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
7082 %{
7083   match(Set cr (StoreLConditional mem (Binary oldval newval)));
7084   effect(KILL oldval);
7085 
7086   format %{ "cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem" %}
7087   opcode(0x0F, 0xB1);
7088   ins_encode(lock_prefix,
7089              REX_reg_mem_wide(newval, mem),
7090              OpcP, OpcS,
7091              reg_mem(newval, mem));
7092   ins_pipe(pipe_cmpxchg);
7093 %}
7094 
7095 
7096 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can't match them
7097 instruct compareAndSwapP(rRegI res,
7098                          memory mem_ptr,
7099                          rax_RegP oldval, rRegP newval,
7100                          rFlagsReg cr)
7101 %{
7102   predicate(VM_Version::supports_cx8());
7103   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
7104   effect(KILL cr, KILL oldval);
7105 
7106   format %{ "cmpxchgq $mem_ptr,$newval\t# "
7107             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7108             "sete    $res\n\t"
7109             "movzbl  $res, $res" %}
7110   opcode(0x0F, 0xB1);
7111   ins_encode(lock_prefix,
7112              REX_reg_mem_wide(newval, mem_ptr),
7113              OpcP, OpcS,
7114              reg_mem(newval, mem_ptr),
7115              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7116              REX_reg_breg(res, res), // movzbl
7117              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7118   ins_pipe( pipe_cmpxchg );
7119 %}
7120 
7121 instruct compareAndSwapL(rRegI res,
7122                          memory mem_ptr,
7123                          rax_RegL oldval, rRegL newval,
7124                          rFlagsReg cr)
7125 %{
7126   predicate(VM_Version::supports_cx8());
7127   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
7128   effect(KILL cr, KILL oldval);
7129 
7130   format %{ "cmpxchgq $mem_ptr,$newval\t# "
7131             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7132             "sete    $res\n\t"
7133             "movzbl  $res, $res" %}
7134   opcode(0x0F, 0xB1);
7135   ins_encode(lock_prefix,
7136              REX_reg_mem_wide(newval, mem_ptr),
7137              OpcP, OpcS,
7138              reg_mem(newval, mem_ptr),
7139              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7140              REX_reg_breg(res, res), // movzbl
7141              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7142   ins_pipe( pipe_cmpxchg );
7143 %}
7144 
7145 instruct compareAndSwapI(rRegI res,
7146                          memory mem_ptr,
7147                          rax_RegI oldval, rRegI newval,
7148                          rFlagsReg cr)
7149 %{
7150   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
7151   effect(KILL cr, KILL oldval);
7152 
7153   format %{ "cmpxchgl $mem_ptr,$newval\t# "
7154             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7155             "sete    $res\n\t"
7156             "movzbl  $res, $res" %}
7157   opcode(0x0F, 0xB1);
7158   ins_encode(lock_prefix,
7159              REX_reg_mem(newval, mem_ptr),
7160              OpcP, OpcS,
7161              reg_mem(newval, mem_ptr),
7162              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7163              REX_reg_breg(res, res), // movzbl
7164              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7165   ins_pipe( pipe_cmpxchg );
7166 %}
7167 
7168 
7169 instruct compareAndSwapN(rRegI res,
7170                           memory mem_ptr,
7171                           rax_RegN oldval, rRegN newval,
7172                           rFlagsReg cr) %{
7173   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
7174   effect(KILL cr, KILL oldval);
7175 
7176   format %{ "cmpxchgl $mem_ptr,$newval\t# "
7177             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7178             "sete    $res\n\t"
7179             "movzbl  $res, $res" %}
7180   opcode(0x0F, 0xB1);
7181   ins_encode(lock_prefix,
7182              REX_reg_mem(newval, mem_ptr),
7183              OpcP, OpcS,
7184              reg_mem(newval, mem_ptr),
7185              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7186              REX_reg_breg(res, res), // movzbl
7187              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7188   ins_pipe( pipe_cmpxchg );
7189 %}
7190 
7191 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
7192   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
7193   match(Set dummy (GetAndAddI mem add));
7194   effect(KILL cr);
7195   format %{ "ADDL  [$mem],$add" %}
7196   ins_encode %{
7197     if (os::is_MP()) { __ lock(); }
7198     __ addl($mem$$Address, $add$$constant);
7199   %}
7200   ins_pipe( pipe_cmpxchg );
7201 %}
7202 
7203 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
7204   match(Set newval (GetAndAddI mem newval));
7205   effect(KILL cr);
7206   format %{ "XADDL  [$mem],$newval" %}
7207   ins_encode %{
7208     if (os::is_MP()) { __ lock(); }
7209     __ xaddl($mem$$Address, $newval$$Register);
7210   %}
7211   ins_pipe( pipe_cmpxchg );
7212 %}
7213 
7214 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
7215   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
7216   match(Set dummy (GetAndAddL mem add));
7217   effect(KILL cr);
7218   format %{ "ADDQ  [$mem],$add" %}
7219   ins_encode %{
7220     if (os::is_MP()) { __ lock(); }
7221     __ addq($mem$$Address, $add$$constant);
7222   %}
7223   ins_pipe( pipe_cmpxchg );
7224 %}
7225 
7226 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
7227   match(Set newval (GetAndAddL mem newval));
7228   effect(KILL cr);
7229   format %{ "XADDQ  [$mem],$newval" %}
7230   ins_encode %{
7231     if (os::is_MP()) { __ lock(); }
7232     __ xaddq($mem$$Address, $newval$$Register);
7233   %}
7234   ins_pipe( pipe_cmpxchg );
7235 %}
7236 
7237 instruct xchgI( memory mem, rRegI newval) %{
7238   match(Set newval (GetAndSetI mem newval));
7239   format %{ "XCHGL  $newval,[$mem]" %}
7240   ins_encode %{
7241     __ xchgl($newval$$Register, $mem$$Address);
7242   %}
7243   ins_pipe( pipe_cmpxchg );
7244 %}
7245 
7246 instruct xchgL( memory mem, rRegL newval) %{
7247   match(Set newval (GetAndSetL mem newval));
7248   format %{ "XCHGL  $newval,[$mem]" %}
7249   ins_encode %{
7250     __ xchgq($newval$$Register, $mem$$Address);
7251   %}
7252   ins_pipe( pipe_cmpxchg );
7253 %}
7254 
7255 instruct xchgP( memory mem, rRegP newval) %{
7256   match(Set newval (GetAndSetP mem newval));
7257   format %{ "XCHGQ  $newval,[$mem]" %}
7258   ins_encode %{
7259     __ xchgq($newval$$Register, $mem$$Address);
7260   %}
7261   ins_pipe( pipe_cmpxchg );
7262 %}
7263 
7264 instruct xchgN( memory mem, rRegN newval) %{
7265   match(Set newval (GetAndSetN mem newval));
7266   format %{ "XCHGL  $newval,$mem]" %}
7267   ins_encode %{
7268     __ xchgl($newval$$Register, $mem$$Address);
7269   %}
7270   ins_pipe( pipe_cmpxchg );
7271 %}
7272 
7273 //----------Subtraction Instructions-------------------------------------------
7274 
7275 // Integer Subtraction Instructions
7276 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
7277 %{
7278   match(Set dst (SubI dst src));
7279   effect(KILL cr);
7280 
7281   format %{ "subl    $dst, $src\t# int" %}
7282   opcode(0x2B);
7283   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
7284   ins_pipe(ialu_reg_reg);
7285 %}
7286 
7287 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
7288 %{
7289   match(Set dst (SubI dst src));
7290   effect(KILL cr);
7291 
7292   format %{ "subl    $dst, $src\t# int" %}
7293   opcode(0x81, 0x05);  /* Opcode 81 /5 */
7294   ins_encode(OpcSErm(dst, src), Con8or32(src));
7295   ins_pipe(ialu_reg);
7296 %}
7297 
7298 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
7299 %{
7300   match(Set dst (SubI dst (LoadI src)));
7301   effect(KILL cr);
7302 
7303   ins_cost(125);
7304   format %{ "subl    $dst, $src\t# int" %}
7305   opcode(0x2B);
7306   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
7307   ins_pipe(ialu_reg_mem);
7308 %}
7309 
7310 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
7311 %{
7312   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
7313   effect(KILL cr);
7314 
7315   ins_cost(150);
7316   format %{ "subl    $dst, $src\t# int" %}
7317   opcode(0x29); /* Opcode 29 /r */
7318   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
7319   ins_pipe(ialu_mem_reg);
7320 %}
7321 
7322 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
7323 %{
7324   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
7325   effect(KILL cr);
7326 
7327   ins_cost(125); // XXX
7328   format %{ "subl    $dst, $src\t# int" %}
7329   opcode(0x81); /* Opcode 81 /5 id */
7330   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
7331   ins_pipe(ialu_mem_imm);
7332 %}
7333 
7334 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
7335 %{
7336   match(Set dst (SubL dst src));
7337   effect(KILL cr);
7338 
7339   format %{ "subq    $dst, $src\t# long" %}
7340   opcode(0x2B);
7341   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7342   ins_pipe(ialu_reg_reg);
7343 %}
7344 
7345 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
7346 %{
7347   match(Set dst (SubL dst src));
7348   effect(KILL cr);
7349 
7350   format %{ "subq    $dst, $src\t# long" %}
7351   opcode(0x81, 0x05);  /* Opcode 81 /5 */
7352   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
7353   ins_pipe(ialu_reg);
7354 %}
7355 
7356 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
7357 %{
7358   match(Set dst (SubL dst (LoadL src)));
7359   effect(KILL cr);
7360 
7361   ins_cost(125);
7362   format %{ "subq    $dst, $src\t# long" %}
7363   opcode(0x2B);
7364   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
7365   ins_pipe(ialu_reg_mem);
7366 %}
7367 
7368 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
7369 %{
7370   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
7371   effect(KILL cr);
7372 
7373   ins_cost(150);
7374   format %{ "subq    $dst, $src\t# long" %}
7375   opcode(0x29); /* Opcode 29 /r */
7376   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
7377   ins_pipe(ialu_mem_reg);
7378 %}
7379 
7380 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
7381 %{
7382   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
7383   effect(KILL cr);
7384 
7385   ins_cost(125); // XXX
7386   format %{ "subq    $dst, $src\t# long" %}
7387   opcode(0x81); /* Opcode 81 /5 id */
7388   ins_encode(REX_mem_wide(dst),
7389              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
7390   ins_pipe(ialu_mem_imm);
7391 %}
7392 
7393 // Subtract from a pointer
7394 // XXX hmpf???
7395 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
7396 %{
7397   match(Set dst (AddP dst (SubI zero src)));
7398   effect(KILL cr);
7399 
7400   format %{ "subq    $dst, $src\t# ptr - int" %}
7401   opcode(0x2B);
7402   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7403   ins_pipe(ialu_reg_reg);
7404 %}
7405 
7406 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
7407 %{
7408   match(Set dst (SubI zero dst));
7409   effect(KILL cr);
7410 
7411   format %{ "negl    $dst\t# int" %}
7412   opcode(0xF7, 0x03);  // Opcode F7 /3
7413   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7414   ins_pipe(ialu_reg);
7415 %}
7416 
7417 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
7418 %{
7419   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
7420   effect(KILL cr);
7421 
7422   format %{ "negl    $dst\t# int" %}
7423   opcode(0xF7, 0x03);  // Opcode F7 /3
7424   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7425   ins_pipe(ialu_reg);
7426 %}
7427 
7428 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
7429 %{
7430   match(Set dst (SubL zero dst));
7431   effect(KILL cr);
7432 
7433   format %{ "negq    $dst\t# long" %}
7434   opcode(0xF7, 0x03);  // Opcode F7 /3
7435   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7436   ins_pipe(ialu_reg);
7437 %}
7438 
7439 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
7440 %{
7441   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
7442   effect(KILL cr);
7443 
7444   format %{ "negq    $dst\t# long" %}
7445   opcode(0xF7, 0x03);  // Opcode F7 /3
7446   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
7447   ins_pipe(ialu_reg);
7448 %}
7449 
7450 //----------Multiplication/Division Instructions-------------------------------
7451 // Integer Multiplication Instructions
7452 // Multiply Register
7453 
7454 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
7455 %{
7456   match(Set dst (MulI dst src));
7457   effect(KILL cr);
7458 
7459   ins_cost(300);
7460   format %{ "imull   $dst, $src\t# int" %}
7461   opcode(0x0F, 0xAF);
7462   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
7463   ins_pipe(ialu_reg_reg_alu0);
7464 %}
7465 
7466 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
7467 %{
7468   match(Set dst (MulI src imm));
7469   effect(KILL cr);
7470 
7471   ins_cost(300);
7472   format %{ "imull   $dst, $src, $imm\t# int" %}
7473   opcode(0x69); /* 69 /r id */
7474   ins_encode(REX_reg_reg(dst, src),
7475              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
7476   ins_pipe(ialu_reg_reg_alu0);
7477 %}
7478 
7479 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
7480 %{
7481   match(Set dst (MulI dst (LoadI src)));
7482   effect(KILL cr);
7483 
7484   ins_cost(350);
7485   format %{ "imull   $dst, $src\t# int" %}
7486   opcode(0x0F, 0xAF);
7487   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
7488   ins_pipe(ialu_reg_mem_alu0);
7489 %}
7490 
7491 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
7492 %{
7493   match(Set dst (MulI (LoadI src) imm));
7494   effect(KILL cr);
7495 
7496   ins_cost(300);
7497   format %{ "imull   $dst, $src, $imm\t# int" %}
7498   opcode(0x69); /* 69 /r id */
7499   ins_encode(REX_reg_mem(dst, src),
7500              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
7501   ins_pipe(ialu_reg_mem_alu0);
7502 %}
7503 
7504 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
7505 %{
7506   match(Set dst (MulL dst src));
7507   effect(KILL cr);
7508 
7509   ins_cost(300);
7510   format %{ "imulq   $dst, $src\t# long" %}
7511   opcode(0x0F, 0xAF);
7512   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
7513   ins_pipe(ialu_reg_reg_alu0);
7514 %}
7515 
7516 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
7517 %{
7518   match(Set dst (MulL src imm));
7519   effect(KILL cr);
7520 
7521   ins_cost(300);
7522   format %{ "imulq   $dst, $src, $imm\t# long" %}
7523   opcode(0x69); /* 69 /r id */
7524   ins_encode(REX_reg_reg_wide(dst, src),
7525              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
7526   ins_pipe(ialu_reg_reg_alu0);
7527 %}
7528 
7529 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
7530 %{
7531   match(Set dst (MulL dst (LoadL src)));
7532   effect(KILL cr);
7533 
7534   ins_cost(350);
7535   format %{ "imulq   $dst, $src\t# long" %}
7536   opcode(0x0F, 0xAF);
7537   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
7538   ins_pipe(ialu_reg_mem_alu0);
7539 %}
7540 
7541 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
7542 %{
7543   match(Set dst (MulL (LoadL src) imm));
7544   effect(KILL cr);
7545 
7546   ins_cost(300);
7547   format %{ "imulq   $dst, $src, $imm\t# long" %}
7548   opcode(0x69); /* 69 /r id */
7549   ins_encode(REX_reg_mem_wide(dst, src),
7550              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
7551   ins_pipe(ialu_reg_mem_alu0);
7552 %}
7553 
7554 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
7555 %{
7556   match(Set dst (MulHiL src rax));
7557   effect(USE_KILL rax, KILL cr);
7558 
7559   ins_cost(300);
7560   format %{ "imulq   RDX:RAX, RAX, $src\t# mulhi" %}
7561   opcode(0xF7, 0x5); /* Opcode F7 /5 */
7562   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
7563   ins_pipe(ialu_reg_reg_alu0);
7564 %}
7565 
7566 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
7567                    rFlagsReg cr)
7568 %{
7569   match(Set rax (DivI rax div));
7570   effect(KILL rdx, KILL cr);
7571 
7572   ins_cost(30*100+10*100); // XXX
7573   format %{ "cmpl    rax, 0x80000000\t# idiv\n\t"
7574             "jne,s   normal\n\t"
7575             "xorl    rdx, rdx\n\t"
7576             "cmpl    $div, -1\n\t"
7577             "je,s    done\n"
7578     "normal: cdql\n\t"
7579             "idivl   $div\n"
7580     "done:"        %}
7581   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7582   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7583   ins_pipe(ialu_reg_reg_alu0);
7584 %}
7585 
7586 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
7587                    rFlagsReg cr)
7588 %{
7589   match(Set rax (DivL rax div));
7590   effect(KILL rdx, KILL cr);
7591 
7592   ins_cost(30*100+10*100); // XXX
7593   format %{ "movq    rdx, 0x8000000000000000\t# ldiv\n\t"
7594             "cmpq    rax, rdx\n\t"
7595             "jne,s   normal\n\t"
7596             "xorl    rdx, rdx\n\t"
7597             "cmpq    $div, -1\n\t"
7598             "je,s    done\n"
7599     "normal: cdqq\n\t"
7600             "idivq   $div\n"
7601     "done:"        %}
7602   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7603   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7604   ins_pipe(ialu_reg_reg_alu0);
7605 %}
7606 
7607 // Integer DIVMOD with Register, both quotient and mod results
7608 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
7609                              rFlagsReg cr)
7610 %{
7611   match(DivModI rax div);
7612   effect(KILL cr);
7613 
7614   ins_cost(30*100+10*100); // XXX
7615   format %{ "cmpl    rax, 0x80000000\t# idiv\n\t"
7616             "jne,s   normal\n\t"
7617             "xorl    rdx, rdx\n\t"
7618             "cmpl    $div, -1\n\t"
7619             "je,s    done\n"
7620     "normal: cdql\n\t"
7621             "idivl   $div\n"
7622     "done:"        %}
7623   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7624   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7625   ins_pipe(pipe_slow);
7626 %}
7627 
7628 // Long DIVMOD with Register, both quotient and mod results
7629 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
7630                              rFlagsReg cr)
7631 %{
7632   match(DivModL rax div);
7633   effect(KILL cr);
7634 
7635   ins_cost(30*100+10*100); // XXX
7636   format %{ "movq    rdx, 0x8000000000000000\t# ldiv\n\t"
7637             "cmpq    rax, rdx\n\t"
7638             "jne,s   normal\n\t"
7639             "xorl    rdx, rdx\n\t"
7640             "cmpq    $div, -1\n\t"
7641             "je,s    done\n"
7642     "normal: cdqq\n\t"
7643             "idivq   $div\n"
7644     "done:"        %}
7645   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7646   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7647   ins_pipe(pipe_slow);
7648 %}
7649 
7650 //----------- DivL-By-Constant-Expansions--------------------------------------
7651 // DivI cases are handled by the compiler
7652 
7653 // Magic constant, reciprocal of 10
7654 instruct loadConL_0x6666666666666667(rRegL dst)
7655 %{
7656   effect(DEF dst);
7657 
7658   format %{ "movq    $dst, #0x666666666666667\t# Used in div-by-10" %}
7659   ins_encode(load_immL(dst, 0x6666666666666667));
7660   ins_pipe(ialu_reg);
7661 %}
7662 
7663 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
7664 %{
7665   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
7666 
7667   format %{ "imulq   rdx:rax, rax, $src\t# Used in div-by-10" %}
7668   opcode(0xF7, 0x5); /* Opcode F7 /5 */
7669   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
7670   ins_pipe(ialu_reg_reg_alu0);
7671 %}
7672 
7673 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
7674 %{
7675   effect(USE_DEF dst, KILL cr);
7676 
7677   format %{ "sarq    $dst, #63\t# Used in div-by-10" %}
7678   opcode(0xC1, 0x7); /* C1 /7 ib */
7679   ins_encode(reg_opc_imm_wide(dst, 0x3F));
7680   ins_pipe(ialu_reg);
7681 %}
7682 
7683 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
7684 %{
7685   effect(USE_DEF dst, KILL cr);
7686 
7687   format %{ "sarq    $dst, #2\t# Used in div-by-10" %}
7688   opcode(0xC1, 0x7); /* C1 /7 ib */
7689   ins_encode(reg_opc_imm_wide(dst, 0x2));
7690   ins_pipe(ialu_reg);
7691 %}
7692 
7693 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
7694 %{
7695   match(Set dst (DivL src div));
7696 
7697   ins_cost((5+8)*100);
7698   expand %{
7699     rax_RegL rax;                     // Killed temp
7700     rFlagsReg cr;                     // Killed
7701     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
7702     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
7703     sarL_rReg_63(src, cr);            // sarq  src, 63
7704     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
7705     subL_rReg(dst, src, cr);          // subl  rdx, src
7706   %}
7707 %}
7708 
7709 //-----------------------------------------------------------------------------
7710 
7711 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
7712                    rFlagsReg cr)
7713 %{
7714   match(Set rdx (ModI rax div));
7715   effect(KILL rax, KILL cr);
7716 
7717   ins_cost(300); // XXX
7718   format %{ "cmpl    rax, 0x80000000\t# irem\n\t"
7719             "jne,s   normal\n\t"
7720             "xorl    rdx, rdx\n\t"
7721             "cmpl    $div, -1\n\t"
7722             "je,s    done\n"
7723     "normal: cdql\n\t"
7724             "idivl   $div\n"
7725     "done:"        %}
7726   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7727   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7728   ins_pipe(ialu_reg_reg_alu0);
7729 %}
7730 
7731 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
7732                    rFlagsReg cr)
7733 %{
7734   match(Set rdx (ModL rax div));
7735   effect(KILL rax, KILL cr);
7736 
7737   ins_cost(300); // XXX
7738   format %{ "movq    rdx, 0x8000000000000000\t# lrem\n\t"
7739             "cmpq    rax, rdx\n\t"
7740             "jne,s   normal\n\t"
7741             "xorl    rdx, rdx\n\t"
7742             "cmpq    $div, -1\n\t"
7743             "je,s    done\n"
7744     "normal: cdqq\n\t"
7745             "idivq   $div\n"
7746     "done:"        %}
7747   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7748   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7749   ins_pipe(ialu_reg_reg_alu0);
7750 %}
7751 
7752 // Integer Shift Instructions
7753 // Shift Left by one
7754 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
7755 %{
7756   match(Set dst (LShiftI dst shift));
7757   effect(KILL cr);
7758 
7759   format %{ "sall    $dst, $shift" %}
7760   opcode(0xD1, 0x4); /* D1 /4 */
7761   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7762   ins_pipe(ialu_reg);
7763 %}
7764 
7765 // Shift Left by one
7766 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
7767 %{
7768   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7769   effect(KILL cr);
7770 
7771   format %{ "sall    $dst, $shift\t" %}
7772   opcode(0xD1, 0x4); /* D1 /4 */
7773   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7774   ins_pipe(ialu_mem_imm);
7775 %}
7776 
7777 // Shift Left by 8-bit immediate
7778 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
7779 %{
7780   match(Set dst (LShiftI dst shift));
7781   effect(KILL cr);
7782 
7783   format %{ "sall    $dst, $shift" %}
7784   opcode(0xC1, 0x4); /* C1 /4 ib */
7785   ins_encode(reg_opc_imm(dst, shift));
7786   ins_pipe(ialu_reg);
7787 %}
7788 
7789 // Shift Left by 8-bit immediate
7790 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
7791 %{
7792   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7793   effect(KILL cr);
7794 
7795   format %{ "sall    $dst, $shift" %}
7796   opcode(0xC1, 0x4); /* C1 /4 ib */
7797   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
7798   ins_pipe(ialu_mem_imm);
7799 %}
7800 
7801 // Shift Left by variable
7802 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
7803 %{
7804   match(Set dst (LShiftI dst shift));
7805   effect(KILL cr);
7806 
7807   format %{ "sall    $dst, $shift" %}
7808   opcode(0xD3, 0x4); /* D3 /4 */
7809   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7810   ins_pipe(ialu_reg_reg);
7811 %}
7812 
7813 // Shift Left by variable
7814 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
7815 %{
7816   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7817   effect(KILL cr);
7818 
7819   format %{ "sall    $dst, $shift" %}
7820   opcode(0xD3, 0x4); /* D3 /4 */
7821   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7822   ins_pipe(ialu_mem_reg);
7823 %}
7824 
7825 // Arithmetic shift right by one
7826 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
7827 %{
7828   match(Set dst (RShiftI dst shift));
7829   effect(KILL cr);
7830 
7831   format %{ "sarl    $dst, $shift" %}
7832   opcode(0xD1, 0x7); /* D1 /7 */
7833   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7834   ins_pipe(ialu_reg);
7835 %}
7836 
7837 // Arithmetic shift right by one
7838 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
7839 %{
7840   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
7841   effect(KILL cr);
7842 
7843   format %{ "sarl    $dst, $shift" %}
7844   opcode(0xD1, 0x7); /* D1 /7 */
7845   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7846   ins_pipe(ialu_mem_imm);
7847 %}
7848 
7849 // Arithmetic Shift Right by 8-bit immediate
7850 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
7851 %{
7852   match(Set dst (RShiftI dst shift));
7853   effect(KILL cr);
7854 
7855   format %{ "sarl    $dst, $shift" %}
7856   opcode(0xC1, 0x7); /* C1 /7 ib */
7857   ins_encode(reg_opc_imm(dst, shift));
7858   ins_pipe(ialu_mem_imm);
7859 %}
7860 
7861 // Arithmetic Shift Right by 8-bit immediate
7862 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
7863 %{
7864   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
7865   effect(KILL cr);
7866 
7867   format %{ "sarl    $dst, $shift" %}
7868   opcode(0xC1, 0x7); /* C1 /7 ib */
7869   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
7870   ins_pipe(ialu_mem_imm);
7871 %}
7872 
7873 // Arithmetic Shift Right by variable
7874 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
7875 %{
7876   match(Set dst (RShiftI dst shift));
7877   effect(KILL cr);
7878 
7879   format %{ "sarl    $dst, $shift" %}
7880   opcode(0xD3, 0x7); /* D3 /7 */
7881   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7882   ins_pipe(ialu_reg_reg);
7883 %}
7884 
7885 // Arithmetic Shift Right by variable
7886 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
7887 %{
7888   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
7889   effect(KILL cr);
7890 
7891   format %{ "sarl    $dst, $shift" %}
7892   opcode(0xD3, 0x7); /* D3 /7 */
7893   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7894   ins_pipe(ialu_mem_reg);
7895 %}
7896 
7897 // Logical shift right by one
7898 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
7899 %{
7900   match(Set dst (URShiftI dst shift));
7901   effect(KILL cr);
7902 
7903   format %{ "shrl    $dst, $shift" %}
7904   opcode(0xD1, 0x5); /* D1 /5 */
7905   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7906   ins_pipe(ialu_reg);
7907 %}
7908 
7909 // Logical shift right by one
7910 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
7911 %{
7912   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
7913   effect(KILL cr);
7914 
7915   format %{ "shrl    $dst, $shift" %}
7916   opcode(0xD1, 0x5); /* D1 /5 */
7917   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7918   ins_pipe(ialu_mem_imm);
7919 %}
7920 
7921 // Logical Shift Right by 8-bit immediate
7922 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
7923 %{
7924   match(Set dst (URShiftI dst shift));
7925   effect(KILL cr);
7926 
7927   format %{ "shrl    $dst, $shift" %}
7928   opcode(0xC1, 0x5); /* C1 /5 ib */
7929   ins_encode(reg_opc_imm(dst, shift));
7930   ins_pipe(ialu_reg);
7931 %}
7932 
7933 // Logical Shift Right by 8-bit immediate
7934 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
7935 %{
7936   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
7937   effect(KILL cr);
7938 
7939   format %{ "shrl    $dst, $shift" %}
7940   opcode(0xC1, 0x5); /* C1 /5 ib */
7941   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
7942   ins_pipe(ialu_mem_imm);
7943 %}
7944 
7945 // Logical Shift Right by variable
7946 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
7947 %{
7948   match(Set dst (URShiftI dst shift));
7949   effect(KILL cr);
7950 
7951   format %{ "shrl    $dst, $shift" %}
7952   opcode(0xD3, 0x5); /* D3 /5 */
7953   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7954   ins_pipe(ialu_reg_reg);
7955 %}
7956 
7957 // Logical Shift Right by variable
7958 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
7959 %{
7960   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
7961   effect(KILL cr);
7962 
7963   format %{ "shrl    $dst, $shift" %}
7964   opcode(0xD3, 0x5); /* D3 /5 */
7965   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7966   ins_pipe(ialu_mem_reg);
7967 %}
7968 
7969 // Long Shift Instructions
7970 // Shift Left by one
7971 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
7972 %{
7973   match(Set dst (LShiftL dst shift));
7974   effect(KILL cr);
7975 
7976   format %{ "salq    $dst, $shift" %}
7977   opcode(0xD1, 0x4); /* D1 /4 */
7978   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7979   ins_pipe(ialu_reg);
7980 %}
7981 
7982 // Shift Left by one
7983 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
7984 %{
7985   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
7986   effect(KILL cr);
7987 
7988   format %{ "salq    $dst, $shift" %}
7989   opcode(0xD1, 0x4); /* D1 /4 */
7990   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
7991   ins_pipe(ialu_mem_imm);
7992 %}
7993 
7994 // Shift Left by 8-bit immediate
7995 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
7996 %{
7997   match(Set dst (LShiftL dst shift));
7998   effect(KILL cr);
7999 
8000   format %{ "salq    $dst, $shift" %}
8001   opcode(0xC1, 0x4); /* C1 /4 ib */
8002   ins_encode(reg_opc_imm_wide(dst, shift));
8003   ins_pipe(ialu_reg);
8004 %}
8005 
8006 // Shift Left by 8-bit immediate
8007 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8008 %{
8009   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8010   effect(KILL cr);
8011 
8012   format %{ "salq    $dst, $shift" %}
8013   opcode(0xC1, 0x4); /* C1 /4 ib */
8014   ins_encode(REX_mem_wide(dst), OpcP,
8015              RM_opc_mem(secondary, dst), Con8or32(shift));
8016   ins_pipe(ialu_mem_imm);
8017 %}
8018 
8019 // Shift Left by variable
8020 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8021 %{
8022   match(Set dst (LShiftL dst shift));
8023   effect(KILL cr);
8024 
8025   format %{ "salq    $dst, $shift" %}
8026   opcode(0xD3, 0x4); /* D3 /4 */
8027   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8028   ins_pipe(ialu_reg_reg);
8029 %}
8030 
8031 // Shift Left by variable
8032 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8033 %{
8034   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8035   effect(KILL cr);
8036 
8037   format %{ "salq    $dst, $shift" %}
8038   opcode(0xD3, 0x4); /* D3 /4 */
8039   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8040   ins_pipe(ialu_mem_reg);
8041 %}
8042 
8043 // Arithmetic shift right by one
8044 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8045 %{
8046   match(Set dst (RShiftL dst shift));
8047   effect(KILL cr);
8048 
8049   format %{ "sarq    $dst, $shift" %}
8050   opcode(0xD1, 0x7); /* D1 /7 */
8051   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8052   ins_pipe(ialu_reg);
8053 %}
8054 
8055 // Arithmetic shift right by one
8056 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8057 %{
8058   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8059   effect(KILL cr);
8060 
8061   format %{ "sarq    $dst, $shift" %}
8062   opcode(0xD1, 0x7); /* D1 /7 */
8063   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8064   ins_pipe(ialu_mem_imm);
8065 %}
8066 
8067 // Arithmetic Shift Right by 8-bit immediate
8068 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8069 %{
8070   match(Set dst (RShiftL dst shift));
8071   effect(KILL cr);
8072 
8073   format %{ "sarq    $dst, $shift" %}
8074   opcode(0xC1, 0x7); /* C1 /7 ib */
8075   ins_encode(reg_opc_imm_wide(dst, shift));
8076   ins_pipe(ialu_mem_imm);
8077 %}
8078 
8079 // Arithmetic Shift Right by 8-bit immediate
8080 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8081 %{
8082   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8083   effect(KILL cr);
8084 
8085   format %{ "sarq    $dst, $shift" %}
8086   opcode(0xC1, 0x7); /* C1 /7 ib */
8087   ins_encode(REX_mem_wide(dst), OpcP,
8088              RM_opc_mem(secondary, dst), Con8or32(shift));
8089   ins_pipe(ialu_mem_imm);
8090 %}
8091 
8092 // Arithmetic Shift Right by variable
8093 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8094 %{
8095   match(Set dst (RShiftL dst shift));
8096   effect(KILL cr);
8097 
8098   format %{ "sarq    $dst, $shift" %}
8099   opcode(0xD3, 0x7); /* D3 /7 */
8100   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8101   ins_pipe(ialu_reg_reg);
8102 %}
8103 
8104 // Arithmetic Shift Right by variable
8105 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8106 %{
8107   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8108   effect(KILL cr);
8109 
8110   format %{ "sarq    $dst, $shift" %}
8111   opcode(0xD3, 0x7); /* D3 /7 */
8112   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8113   ins_pipe(ialu_mem_reg);
8114 %}
8115 
8116 // Logical shift right by one
8117 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8118 %{
8119   match(Set dst (URShiftL dst shift));
8120   effect(KILL cr);
8121 
8122   format %{ "shrq    $dst, $shift" %}
8123   opcode(0xD1, 0x5); /* D1 /5 */
8124   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
8125   ins_pipe(ialu_reg);
8126 %}
8127 
8128 // Logical shift right by one
8129 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8130 %{
8131   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8132   effect(KILL cr);
8133 
8134   format %{ "shrq    $dst, $shift" %}
8135   opcode(0xD1, 0x5); /* D1 /5 */
8136   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8137   ins_pipe(ialu_mem_imm);
8138 %}
8139 
8140 // Logical Shift Right by 8-bit immediate
8141 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8142 %{
8143   match(Set dst (URShiftL dst shift));
8144   effect(KILL cr);
8145 
8146   format %{ "shrq    $dst, $shift" %}
8147   opcode(0xC1, 0x5); /* C1 /5 ib */
8148   ins_encode(reg_opc_imm_wide(dst, shift));
8149   ins_pipe(ialu_reg);
8150 %}
8151 
8152 
8153 // Logical Shift Right by 8-bit immediate
8154 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8155 %{
8156   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8157   effect(KILL cr);
8158 
8159   format %{ "shrq    $dst, $shift" %}
8160   opcode(0xC1, 0x5); /* C1 /5 ib */
8161   ins_encode(REX_mem_wide(dst), OpcP,
8162              RM_opc_mem(secondary, dst), Con8or32(shift));
8163   ins_pipe(ialu_mem_imm);
8164 %}
8165 
8166 // Logical Shift Right by variable
8167 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8168 %{
8169   match(Set dst (URShiftL dst shift));
8170   effect(KILL cr);
8171 
8172   format %{ "shrq    $dst, $shift" %}
8173   opcode(0xD3, 0x5); /* D3 /5 */
8174   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8175   ins_pipe(ialu_reg_reg);
8176 %}
8177 
8178 // Logical Shift Right by variable
8179 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8180 %{
8181   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8182   effect(KILL cr);
8183 
8184   format %{ "shrq    $dst, $shift" %}
8185   opcode(0xD3, 0x5); /* D3 /5 */
8186   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8187   ins_pipe(ialu_mem_reg);
8188 %}
8189 
8190 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
8191 // This idiom is used by the compiler for the i2b bytecode.
8192 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
8193 %{
8194   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
8195 
8196   format %{ "movsbl  $dst, $src\t# i2b" %}
8197   opcode(0x0F, 0xBE);
8198   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8199   ins_pipe(ialu_reg_reg);
8200 %}
8201 
8202 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
8203 // This idiom is used by the compiler the i2s bytecode.
8204 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
8205 %{
8206   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
8207 
8208   format %{ "movswl  $dst, $src\t# i2s" %}
8209   opcode(0x0F, 0xBF);
8210   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8211   ins_pipe(ialu_reg_reg);
8212 %}
8213 
8214 // ROL/ROR instructions
8215 
8216 // ROL expand
8217 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
8218   effect(KILL cr, USE_DEF dst);
8219 
8220   format %{ "roll    $dst" %}
8221   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
8222   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8223   ins_pipe(ialu_reg);
8224 %}
8225 
8226 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
8227   effect(USE_DEF dst, USE shift, KILL cr);
8228 
8229   format %{ "roll    $dst, $shift" %}
8230   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
8231   ins_encode( reg_opc_imm(dst, shift) );
8232   ins_pipe(ialu_reg);
8233 %}
8234 
8235 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
8236 %{
8237   effect(USE_DEF dst, USE shift, KILL cr);
8238 
8239   format %{ "roll    $dst, $shift" %}
8240   opcode(0xD3, 0x0); /* Opcode D3 /0 */
8241   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8242   ins_pipe(ialu_reg_reg);
8243 %}
8244 // end of ROL expand
8245 
8246 // Rotate Left by one
8247 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
8248 %{
8249   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
8250 
8251   expand %{
8252     rolI_rReg_imm1(dst, cr);
8253   %}
8254 %}
8255 
8256 // Rotate Left by 8-bit immediate
8257 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
8258 %{
8259   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
8260   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
8261 
8262   expand %{
8263     rolI_rReg_imm8(dst, lshift, cr);
8264   %}
8265 %}
8266 
8267 // Rotate Left by variable
8268 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8269 %{
8270   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
8271 
8272   expand %{
8273     rolI_rReg_CL(dst, shift, cr);
8274   %}
8275 %}
8276 
8277 // Rotate Left by variable
8278 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
8279 %{
8280   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
8281 
8282   expand %{
8283     rolI_rReg_CL(dst, shift, cr);
8284   %}
8285 %}
8286 
8287 // ROR expand
8288 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
8289 %{
8290   effect(USE_DEF dst, KILL cr);
8291 
8292   format %{ "rorl    $dst" %}
8293   opcode(0xD1, 0x1); /* D1 /1 */
8294   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8295   ins_pipe(ialu_reg);
8296 %}
8297 
8298 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
8299 %{
8300   effect(USE_DEF dst, USE shift, KILL cr);
8301 
8302   format %{ "rorl    $dst, $shift" %}
8303   opcode(0xC1, 0x1); /* C1 /1 ib */
8304   ins_encode(reg_opc_imm(dst, shift));
8305   ins_pipe(ialu_reg);
8306 %}
8307 
8308 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
8309 %{
8310   effect(USE_DEF dst, USE shift, KILL cr);
8311 
8312   format %{ "rorl    $dst, $shift" %}
8313   opcode(0xD3, 0x1); /* D3 /1 */
8314   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8315   ins_pipe(ialu_reg_reg);
8316 %}
8317 // end of ROR expand
8318 
8319 // Rotate Right by one
8320 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
8321 %{
8322   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
8323 
8324   expand %{
8325     rorI_rReg_imm1(dst, cr);
8326   %}
8327 %}
8328 
8329 // Rotate Right by 8-bit immediate
8330 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
8331 %{
8332   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
8333   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
8334 
8335   expand %{
8336     rorI_rReg_imm8(dst, rshift, cr);
8337   %}
8338 %}
8339 
8340 // Rotate Right by variable
8341 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8342 %{
8343   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
8344 
8345   expand %{
8346     rorI_rReg_CL(dst, shift, cr);
8347   %}
8348 %}
8349 
8350 // Rotate Right by variable
8351 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
8352 %{
8353   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
8354 
8355   expand %{
8356     rorI_rReg_CL(dst, shift, cr);
8357   %}
8358 %}
8359 
8360 // for long rotate
8361 // ROL expand
8362 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
8363   effect(USE_DEF dst, KILL cr);
8364 
8365   format %{ "rolq    $dst" %}
8366   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
8367   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8368   ins_pipe(ialu_reg);
8369 %}
8370 
8371 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
8372   effect(USE_DEF dst, USE shift, KILL cr);
8373 
8374   format %{ "rolq    $dst, $shift" %}
8375   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
8376   ins_encode( reg_opc_imm_wide(dst, shift) );
8377   ins_pipe(ialu_reg);
8378 %}
8379 
8380 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
8381 %{
8382   effect(USE_DEF dst, USE shift, KILL cr);
8383 
8384   format %{ "rolq    $dst, $shift" %}
8385   opcode(0xD3, 0x0); /* Opcode D3 /0 */
8386   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8387   ins_pipe(ialu_reg_reg);
8388 %}
8389 // end of ROL expand
8390 
8391 // Rotate Left by one
8392 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
8393 %{
8394   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
8395 
8396   expand %{
8397     rolL_rReg_imm1(dst, cr);
8398   %}
8399 %}
8400 
8401 // Rotate Left by 8-bit immediate
8402 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
8403 %{
8404   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
8405   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
8406 
8407   expand %{
8408     rolL_rReg_imm8(dst, lshift, cr);
8409   %}
8410 %}
8411 
8412 // Rotate Left by variable
8413 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8414 %{
8415   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
8416 
8417   expand %{
8418     rolL_rReg_CL(dst, shift, cr);
8419   %}
8420 %}
8421 
8422 // Rotate Left by variable
8423 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
8424 %{
8425   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
8426 
8427   expand %{
8428     rolL_rReg_CL(dst, shift, cr);
8429   %}
8430 %}
8431 
8432 // ROR expand
8433 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
8434 %{
8435   effect(USE_DEF dst, KILL cr);
8436 
8437   format %{ "rorq    $dst" %}
8438   opcode(0xD1, 0x1); /* D1 /1 */
8439   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8440   ins_pipe(ialu_reg);
8441 %}
8442 
8443 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
8444 %{
8445   effect(USE_DEF dst, USE shift, KILL cr);
8446 
8447   format %{ "rorq    $dst, $shift" %}
8448   opcode(0xC1, 0x1); /* C1 /1 ib */
8449   ins_encode(reg_opc_imm_wide(dst, shift));
8450   ins_pipe(ialu_reg);
8451 %}
8452 
8453 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
8454 %{
8455   effect(USE_DEF dst, USE shift, KILL cr);
8456 
8457   format %{ "rorq    $dst, $shift" %}
8458   opcode(0xD3, 0x1); /* D3 /1 */
8459   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8460   ins_pipe(ialu_reg_reg);
8461 %}
8462 // end of ROR expand
8463 
8464 // Rotate Right by one
8465 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
8466 %{
8467   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
8468 
8469   expand %{
8470     rorL_rReg_imm1(dst, cr);
8471   %}
8472 %}
8473 
8474 // Rotate Right by 8-bit immediate
8475 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
8476 %{
8477   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
8478   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
8479 
8480   expand %{
8481     rorL_rReg_imm8(dst, rshift, cr);
8482   %}
8483 %}
8484 
8485 // Rotate Right by variable
8486 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8487 %{
8488   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
8489 
8490   expand %{
8491     rorL_rReg_CL(dst, shift, cr);
8492   %}
8493 %}
8494 
8495 // Rotate Right by variable
8496 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
8497 %{
8498   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
8499 
8500   expand %{
8501     rorL_rReg_CL(dst, shift, cr);
8502   %}
8503 %}
8504 
8505 // Logical Instructions
8506 
8507 // Integer Logical Instructions
8508 
8509 // And Instructions
8510 // And Register with Register
8511 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8512 %{
8513   match(Set dst (AndI dst src));
8514   effect(KILL cr);
8515 
8516   format %{ "andl    $dst, $src\t# int" %}
8517   opcode(0x23);
8518   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8519   ins_pipe(ialu_reg_reg);
8520 %}
8521 
8522 // And Register with Immediate 255
8523 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
8524 %{
8525   match(Set dst (AndI dst src));
8526 
8527   format %{ "movzbl  $dst, $dst\t# int &amp; 0xFF" %}
8528   opcode(0x0F, 0xB6);
8529   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
8530   ins_pipe(ialu_reg);
8531 %}
8532 
8533 // And Register with Immediate 255 and promote to long
8534 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
8535 %{
8536   match(Set dst (ConvI2L (AndI src mask)));
8537 
8538   format %{ "movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long" %}
8539   opcode(0x0F, 0xB6);
8540   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8541   ins_pipe(ialu_reg);
8542 %}
8543 
8544 // And Register with Immediate 65535
8545 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
8546 %{
8547   match(Set dst (AndI dst src));
8548 
8549   format %{ "movzwl  $dst, $dst\t# int &amp; 0xFFFF" %}
8550   opcode(0x0F, 0xB7);
8551   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
8552   ins_pipe(ialu_reg);
8553 %}
8554 
8555 // And Register with Immediate 65535 and promote to long
8556 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
8557 %{
8558   match(Set dst (ConvI2L (AndI src mask)));
8559 
8560   format %{ "movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long" %}
8561   opcode(0x0F, 0xB7);
8562   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8563   ins_pipe(ialu_reg);
8564 %}
8565 
8566 // And Register with Immediate
8567 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8568 %{
8569   match(Set dst (AndI dst src));
8570   effect(KILL cr);
8571 
8572   format %{ "andl    $dst, $src\t# int" %}
8573   opcode(0x81, 0x04); /* Opcode 81 /4 */
8574   ins_encode(OpcSErm(dst, src), Con8or32(src));
8575   ins_pipe(ialu_reg);
8576 %}
8577 
8578 // And Register with Memory
8579 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
8580 %{
8581   match(Set dst (AndI dst (LoadI src)));
8582   effect(KILL cr);
8583 
8584   ins_cost(125);
8585   format %{ "andl    $dst, $src\t# int" %}
8586   opcode(0x23);
8587   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
8588   ins_pipe(ialu_reg_mem);
8589 %}
8590 
8591 // And Memory with Register
8592 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
8593 %{
8594   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
8595   effect(KILL cr);
8596 
8597   ins_cost(150);
8598   format %{ "andl    $dst, $src\t# int" %}
8599   opcode(0x21); /* Opcode 21 /r */
8600   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
8601   ins_pipe(ialu_mem_reg);
8602 %}
8603 
8604 // And Memory with Immediate
8605 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
8606 %{
8607   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
8608   effect(KILL cr);
8609 
8610   ins_cost(125);
8611   format %{ "andl    $dst, $src\t# int" %}
8612   opcode(0x81, 0x4); /* Opcode 81 /4 id */
8613   ins_encode(REX_mem(dst), OpcSE(src),
8614              RM_opc_mem(secondary, dst), Con8or32(src));
8615   ins_pipe(ialu_mem_imm);
8616 %}
8617 
8618 // BMI1 instructions
8619 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
8620   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
8621   predicate(UseBMI1Instructions);
8622   effect(KILL cr);
8623 
8624   ins_cost(125);
8625   format %{ "andnl  $dst, $src1, $src2" %}
8626 
8627   ins_encode %{
8628     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
8629   %}
8630   ins_pipe(ialu_reg_mem);
8631 %}
8632 
8633 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
8634   match(Set dst (AndI (XorI src1 minus_1) src2));
8635   predicate(UseBMI1Instructions);
8636   effect(KILL cr);
8637 
8638   format %{ "andnl  $dst, $src1, $src2" %}
8639 
8640   ins_encode %{
8641     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
8642   %}
8643   ins_pipe(ialu_reg);
8644 %}
8645 
8646 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
8647   match(Set dst (AndI (SubI imm_zero src) src));
8648   predicate(UseBMI1Instructions);
8649   effect(KILL cr);
8650 
8651   format %{ "blsil  $dst, $src" %}
8652 
8653   ins_encode %{
8654     __ blsil($dst$$Register, $src$$Register);
8655   %}
8656   ins_pipe(ialu_reg);
8657 %}
8658 
8659 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
8660   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
8661   predicate(UseBMI1Instructions);
8662   effect(KILL cr);
8663 
8664   ins_cost(125);
8665   format %{ "blsil  $dst, $src" %}
8666 
8667   ins_encode %{
8668     __ blsil($dst$$Register, $src$$Address);
8669   %}
8670   ins_pipe(ialu_reg_mem);
8671 %}
8672 
8673 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
8674 %{
8675   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
8676   predicate(UseBMI1Instructions);
8677   effect(KILL cr);
8678 
8679   ins_cost(125);
8680   format %{ "blsmskl $dst, $src" %}
8681 
8682   ins_encode %{
8683     __ blsmskl($dst$$Register, $src$$Address);
8684   %}
8685   ins_pipe(ialu_reg_mem);
8686 %}
8687 
8688 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
8689 %{
8690   match(Set dst (XorI (AddI src minus_1) src));
8691   predicate(UseBMI1Instructions);
8692   effect(KILL cr);
8693 
8694   format %{ "blsmskl $dst, $src" %}
8695 
8696   ins_encode %{
8697     __ blsmskl($dst$$Register, $src$$Register);
8698   %}
8699 
8700   ins_pipe(ialu_reg);
8701 %}
8702 
8703 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
8704 %{
8705   match(Set dst (AndI (AddI src minus_1) src) );
8706   predicate(UseBMI1Instructions);
8707   effect(KILL cr);
8708 
8709   format %{ "blsrl  $dst, $src" %}
8710 
8711   ins_encode %{
8712     __ blsrl($dst$$Register, $src$$Register);
8713   %}
8714 
8715   ins_pipe(ialu_reg_mem);
8716 %}
8717 
8718 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
8719 %{
8720   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
8721   predicate(UseBMI1Instructions);
8722   effect(KILL cr);
8723 
8724   ins_cost(125);
8725   format %{ "blsrl  $dst, $src" %}
8726 
8727   ins_encode %{
8728     __ blsrl($dst$$Register, $src$$Address);
8729   %}
8730 
8731   ins_pipe(ialu_reg);
8732 %}
8733 
8734 // Or Instructions
8735 // Or Register with Register
8736 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8737 %{
8738   match(Set dst (OrI dst src));
8739   effect(KILL cr);
8740 
8741   format %{ "orl     $dst, $src\t# int" %}
8742   opcode(0x0B);
8743   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8744   ins_pipe(ialu_reg_reg);
8745 %}
8746 
8747 // Or Register with Immediate
8748 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8749 %{
8750   match(Set dst (OrI dst src));
8751   effect(KILL cr);
8752 
8753   format %{ "orl     $dst, $src\t# int" %}
8754   opcode(0x81, 0x01); /* Opcode 81 /1 id */
8755   ins_encode(OpcSErm(dst, src), Con8or32(src));
8756   ins_pipe(ialu_reg);
8757 %}
8758 
8759 // Or Register with Memory
8760 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
8761 %{
8762   match(Set dst (OrI dst (LoadI src)));
8763   effect(KILL cr);
8764 
8765   ins_cost(125);
8766   format %{ "orl     $dst, $src\t# int" %}
8767   opcode(0x0B);
8768   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
8769   ins_pipe(ialu_reg_mem);
8770 %}
8771 
8772 // Or Memory with Register
8773 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
8774 %{
8775   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
8776   effect(KILL cr);
8777 
8778   ins_cost(150);
8779   format %{ "orl     $dst, $src\t# int" %}
8780   opcode(0x09); /* Opcode 09 /r */
8781   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
8782   ins_pipe(ialu_mem_reg);
8783 %}
8784 
8785 // Or Memory with Immediate
8786 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
8787 %{
8788   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
8789   effect(KILL cr);
8790 
8791   ins_cost(125);
8792   format %{ "orl     $dst, $src\t# int" %}
8793   opcode(0x81, 0x1); /* Opcode 81 /1 id */
8794   ins_encode(REX_mem(dst), OpcSE(src),
8795              RM_opc_mem(secondary, dst), Con8or32(src));
8796   ins_pipe(ialu_mem_imm);
8797 %}
8798 
8799 // Xor Instructions
8800 // Xor Register with Register
8801 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8802 %{
8803   match(Set dst (XorI dst src));
8804   effect(KILL cr);
8805 
8806   format %{ "xorl    $dst, $src\t# int" %}
8807   opcode(0x33);
8808   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8809   ins_pipe(ialu_reg_reg);
8810 %}
8811 
8812 // Xor Register with Immediate -1
8813 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
8814   match(Set dst (XorI dst imm));
8815 
8816   format %{ "not    $dst" %}
8817   ins_encode %{
8818      __ notl($dst$$Register);
8819   %}
8820   ins_pipe(ialu_reg);
8821 %}
8822 
8823 // Xor Register with Immediate
8824 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8825 %{
8826   match(Set dst (XorI dst src));
8827   effect(KILL cr);
8828 
8829   format %{ "xorl    $dst, $src\t# int" %}
8830   opcode(0x81, 0x06); /* Opcode 81 /6 id */
8831   ins_encode(OpcSErm(dst, src), Con8or32(src));
8832   ins_pipe(ialu_reg);
8833 %}
8834 
8835 // Xor Register with Memory
8836 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
8837 %{
8838   match(Set dst (XorI dst (LoadI src)));
8839   effect(KILL cr);
8840 
8841   ins_cost(125);
8842   format %{ "xorl    $dst, $src\t# int" %}
8843   opcode(0x33);
8844   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
8845   ins_pipe(ialu_reg_mem);
8846 %}
8847 
8848 // Xor Memory with Register
8849 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
8850 %{
8851   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
8852   effect(KILL cr);
8853 
8854   ins_cost(150);
8855   format %{ "xorl    $dst, $src\t# int" %}
8856   opcode(0x31); /* Opcode 31 /r */
8857   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
8858   ins_pipe(ialu_mem_reg);
8859 %}
8860 
8861 // Xor Memory with Immediate
8862 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
8863 %{
8864   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
8865   effect(KILL cr);
8866 
8867   ins_cost(125);
8868   format %{ "xorl    $dst, $src\t# int" %}
8869   opcode(0x81, 0x6); /* Opcode 81 /6 id */
8870   ins_encode(REX_mem(dst), OpcSE(src),
8871              RM_opc_mem(secondary, dst), Con8or32(src));
8872   ins_pipe(ialu_mem_imm);
8873 %}
8874 
8875 
8876 // Long Logical Instructions
8877 
8878 // And Instructions
8879 // And Register with Register
8880 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
8881 %{
8882   match(Set dst (AndL dst src));
8883   effect(KILL cr);
8884 
8885   format %{ "andq    $dst, $src\t# long" %}
8886   opcode(0x23);
8887   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
8888   ins_pipe(ialu_reg_reg);
8889 %}
8890 
8891 // And Register with Immediate 255
8892 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
8893 %{
8894   match(Set dst (AndL dst src));
8895 
8896   format %{ "movzbq  $dst, $dst\t# long &amp; 0xFF" %}
8897   opcode(0x0F, 0xB6);
8898   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
8899   ins_pipe(ialu_reg);
8900 %}
8901 
8902 // And Register with Immediate 65535
8903 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
8904 %{
8905   match(Set dst (AndL dst src));
8906 
8907   format %{ "movzwq  $dst, $dst\t# long &amp; 0xFFFF" %}
8908   opcode(0x0F, 0xB7);
8909   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
8910   ins_pipe(ialu_reg);
8911 %}
8912 
8913 // And Register with Immediate
8914 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
8915 %{
8916   match(Set dst (AndL dst src));
8917   effect(KILL cr);
8918 
8919   format %{ "andq    $dst, $src\t# long" %}
8920   opcode(0x81, 0x04); /* Opcode 81 /4 */
8921   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
8922   ins_pipe(ialu_reg);
8923 %}
8924 
8925 // And Register with Memory
8926 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
8927 %{
8928   match(Set dst (AndL dst (LoadL src)));
8929   effect(KILL cr);
8930 
8931   ins_cost(125);
8932   format %{ "andq    $dst, $src\t# long" %}
8933   opcode(0x23);
8934   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
8935   ins_pipe(ialu_reg_mem);
8936 %}
8937 
8938 // And Memory with Register
8939 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
8940 %{
8941   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
8942   effect(KILL cr);
8943 
8944   ins_cost(150);
8945   format %{ "andq    $dst, $src\t# long" %}
8946   opcode(0x21); /* Opcode 21 /r */
8947   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
8948   ins_pipe(ialu_mem_reg);
8949 %}
8950 
8951 // And Memory with Immediate
8952 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
8953 %{
8954   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
8955   effect(KILL cr);
8956 
8957   ins_cost(125);
8958   format %{ "andq    $dst, $src\t# long" %}
8959   opcode(0x81, 0x4); /* Opcode 81 /4 id */
8960   ins_encode(REX_mem_wide(dst), OpcSE(src),
8961              RM_opc_mem(secondary, dst), Con8or32(src));
8962   ins_pipe(ialu_mem_imm);
8963 %}
8964 
8965 // BMI1 instructions
8966 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
8967   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
8968   predicate(UseBMI1Instructions);
8969   effect(KILL cr);
8970 
8971   ins_cost(125);
8972   format %{ "andnq  $dst, $src1, $src2" %}
8973 
8974   ins_encode %{
8975     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
8976   %}
8977   ins_pipe(ialu_reg_mem);
8978 %}
8979 
8980 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
8981   match(Set dst (AndL (XorL src1 minus_1) src2));
8982   predicate(UseBMI1Instructions);
8983   effect(KILL cr);
8984 
8985   format %{ "andnq  $dst, $src1, $src2" %}
8986 
8987   ins_encode %{
8988   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
8989   %}
8990   ins_pipe(ialu_reg_mem);
8991 %}
8992 
8993 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
8994   match(Set dst (AndL (SubL imm_zero src) src));
8995   predicate(UseBMI1Instructions);
8996   effect(KILL cr);
8997 
8998   format %{ "blsiq  $dst, $src" %}
8999 
9000   ins_encode %{
9001     __ blsiq($dst$$Register, $src$$Register);
9002   %}
9003   ins_pipe(ialu_reg);
9004 %}
9005 
9006 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
9007   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
9008   predicate(UseBMI1Instructions);
9009   effect(KILL cr);
9010 
9011   ins_cost(125);
9012   format %{ "blsiq  $dst, $src" %}
9013 
9014   ins_encode %{
9015     __ blsiq($dst$$Register, $src$$Address);
9016   %}
9017   ins_pipe(ialu_reg_mem);
9018 %}
9019 
9020 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
9021 %{
9022   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
9023   predicate(UseBMI1Instructions);
9024   effect(KILL cr);
9025 
9026   ins_cost(125);
9027   format %{ "blsmskq $dst, $src" %}
9028 
9029   ins_encode %{
9030     __ blsmskq($dst$$Register, $src$$Address);
9031   %}
9032   ins_pipe(ialu_reg_mem);
9033 %}
9034 
9035 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
9036 %{
9037   match(Set dst (XorL (AddL src minus_1) src));
9038   predicate(UseBMI1Instructions);
9039   effect(KILL cr);
9040 
9041   format %{ "blsmskq $dst, $src" %}
9042 
9043   ins_encode %{
9044     __ blsmskq($dst$$Register, $src$$Register);
9045   %}
9046 
9047   ins_pipe(ialu_reg);
9048 %}
9049 
9050 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
9051 %{
9052   match(Set dst (AndL (AddL src minus_1) src) );
9053   predicate(UseBMI1Instructions);
9054   effect(KILL cr);
9055 
9056   format %{ "blsrq  $dst, $src" %}
9057 
9058   ins_encode %{
9059     __ blsrq($dst$$Register, $src$$Register);
9060   %}
9061 
9062   ins_pipe(ialu_reg);
9063 %}
9064 
9065 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
9066 %{
9067   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
9068   predicate(UseBMI1Instructions);
9069   effect(KILL cr);
9070 
9071   ins_cost(125);
9072   format %{ "blsrq  $dst, $src" %}
9073 
9074   ins_encode %{
9075     __ blsrq($dst$$Register, $src$$Address);
9076   %}
9077 
9078   ins_pipe(ialu_reg);
9079 %}
9080 
9081 // Or Instructions
9082 // Or Register with Register
9083 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9084 %{
9085   match(Set dst (OrL dst src));
9086   effect(KILL cr);
9087 
9088   format %{ "orq     $dst, $src\t# long" %}
9089   opcode(0x0B);
9090   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9091   ins_pipe(ialu_reg_reg);
9092 %}
9093 
9094 // Use any_RegP to match R15 (TLS register) without spilling.
9095 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
9096   match(Set dst (OrL dst (CastP2X src)));
9097   effect(KILL cr);
9098 
9099   format %{ "orq     $dst, $src\t# long" %}
9100   opcode(0x0B);
9101   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9102   ins_pipe(ialu_reg_reg);
9103 %}
9104 
9105 
9106 // Or Register with Immediate
9107 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9108 %{
9109   match(Set dst (OrL dst src));
9110   effect(KILL cr);
9111 
9112   format %{ "orq     $dst, $src\t# long" %}
9113   opcode(0x81, 0x01); /* Opcode 81 /1 id */
9114   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9115   ins_pipe(ialu_reg);
9116 %}
9117 
9118 // Or Register with Memory
9119 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9120 %{
9121   match(Set dst (OrL dst (LoadL src)));
9122   effect(KILL cr);
9123 
9124   ins_cost(125);
9125   format %{ "orq     $dst, $src\t# long" %}
9126   opcode(0x0B);
9127   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9128   ins_pipe(ialu_reg_mem);
9129 %}
9130 
9131 // Or Memory with Register
9132 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9133 %{
9134   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
9135   effect(KILL cr);
9136 
9137   ins_cost(150);
9138   format %{ "orq     $dst, $src\t# long" %}
9139   opcode(0x09); /* Opcode 09 /r */
9140   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9141   ins_pipe(ialu_mem_reg);
9142 %}
9143 
9144 // Or Memory with Immediate
9145 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9146 %{
9147   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
9148   effect(KILL cr);
9149 
9150   ins_cost(125);
9151   format %{ "orq     $dst, $src\t# long" %}
9152   opcode(0x81, 0x1); /* Opcode 81 /1 id */
9153   ins_encode(REX_mem_wide(dst), OpcSE(src),
9154              RM_opc_mem(secondary, dst), Con8or32(src));
9155   ins_pipe(ialu_mem_imm);
9156 %}
9157 
9158 // Xor Instructions
9159 // Xor Register with Register
9160 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9161 %{
9162   match(Set dst (XorL dst src));
9163   effect(KILL cr);
9164 
9165   format %{ "xorq    $dst, $src\t# long" %}
9166   opcode(0x33);
9167   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9168   ins_pipe(ialu_reg_reg);
9169 %}
9170 
9171 // Xor Register with Immediate -1
9172 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
9173   match(Set dst (XorL dst imm));
9174 
9175   format %{ "notq   $dst" %}
9176   ins_encode %{
9177      __ notq($dst$$Register);
9178   %}
9179   ins_pipe(ialu_reg);
9180 %}
9181 
9182 // Xor Register with Immediate
9183 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9184 %{
9185   match(Set dst (XorL dst src));
9186   effect(KILL cr);
9187 
9188   format %{ "xorq    $dst, $src\t# long" %}
9189   opcode(0x81, 0x06); /* Opcode 81 /6 id */
9190   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9191   ins_pipe(ialu_reg);
9192 %}
9193 
9194 // Xor Register with Memory
9195 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9196 %{
9197   match(Set dst (XorL dst (LoadL src)));
9198   effect(KILL cr);
9199 
9200   ins_cost(125);
9201   format %{ "xorq    $dst, $src\t# long" %}
9202   opcode(0x33);
9203   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9204   ins_pipe(ialu_reg_mem);
9205 %}
9206 
9207 // Xor Memory with Register
9208 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9209 %{
9210   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
9211   effect(KILL cr);
9212 
9213   ins_cost(150);
9214   format %{ "xorq    $dst, $src\t# long" %}
9215   opcode(0x31); /* Opcode 31 /r */
9216   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9217   ins_pipe(ialu_mem_reg);
9218 %}
9219 
9220 // Xor Memory with Immediate
9221 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9222 %{
9223   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
9224   effect(KILL cr);
9225 
9226   ins_cost(125);
9227   format %{ "xorq    $dst, $src\t# long" %}
9228   opcode(0x81, 0x6); /* Opcode 81 /6 id */
9229   ins_encode(REX_mem_wide(dst), OpcSE(src),
9230              RM_opc_mem(secondary, dst), Con8or32(src));
9231   ins_pipe(ialu_mem_imm);
9232 %}
9233 
9234 // Convert Int to Boolean
9235 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
9236 %{
9237   match(Set dst (Conv2B src));
9238   effect(KILL cr);
9239 
9240   format %{ "testl   $src, $src\t# ci2b\n\t"
9241             "setnz   $dst\n\t"
9242             "movzbl  $dst, $dst" %}
9243   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
9244              setNZ_reg(dst),
9245              REX_reg_breg(dst, dst), // movzbl
9246              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
9247   ins_pipe(pipe_slow); // XXX
9248 %}
9249 
9250 // Convert Pointer to Boolean
9251 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
9252 %{
9253   match(Set dst (Conv2B src));
9254   effect(KILL cr);
9255 
9256   format %{ "testq   $src, $src\t# cp2b\n\t"
9257             "setnz   $dst\n\t"
9258             "movzbl  $dst, $dst" %}
9259   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
9260              setNZ_reg(dst),
9261              REX_reg_breg(dst, dst), // movzbl
9262              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
9263   ins_pipe(pipe_slow); // XXX
9264 %}
9265 
9266 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
9267 %{
9268   match(Set dst (CmpLTMask p q));
9269   effect(KILL cr);
9270 
9271   ins_cost(400);
9272   format %{ "cmpl    $p, $q\t# cmpLTMask\n\t"
9273             "setlt   $dst\n\t"
9274             "movzbl  $dst, $dst\n\t"
9275             "negl    $dst" %}
9276   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
9277              setLT_reg(dst),
9278              REX_reg_breg(dst, dst), // movzbl
9279              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
9280              neg_reg(dst));
9281   ins_pipe(pipe_slow);
9282 %}
9283 
9284 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
9285 %{
9286   match(Set dst (CmpLTMask dst zero));
9287   effect(KILL cr);
9288 
9289   ins_cost(100);
9290   format %{ "sarl    $dst, #31\t# cmpLTMask0" %}
9291   ins_encode %{
9292   __ sarl($dst$$Register, 31);
9293   %}
9294   ins_pipe(ialu_reg);
9295 %}
9296 
9297 /* Better to save a register than avoid a branch */
9298 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
9299 %{
9300   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
9301   effect(KILL cr);
9302   ins_cost(300);
9303   format %{ "subl   $p,$q\t# cadd_cmpLTMask\n\t"
9304             "jge    done\n\t"
9305             "addl   $p,$y\n"
9306             "done:  " %}
9307   ins_encode %{
9308     Register Rp = $p$$Register;
9309     Register Rq = $q$$Register;
9310     Register Ry = $y$$Register;
9311     Label done;
9312     __ subl(Rp, Rq);
9313     __ jccb(Assembler::greaterEqual, done);
9314     __ addl(Rp, Ry);
9315     __ bind(done);
9316   %}
9317   ins_pipe(pipe_cmplt);
9318 %}
9319 
9320 /* Better to save a register than avoid a branch */
9321 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
9322 %{
9323   match(Set y (AndI (CmpLTMask p q) y));
9324   effect(KILL cr);
9325 
9326   ins_cost(300);
9327 
9328   format %{ "cmpl     $p, $q\t# and_cmpLTMask\n\t"
9329             "jlt      done\n\t"
9330             "xorl     $y, $y\n"
9331             "done:  " %}
9332   ins_encode %{
9333     Register Rp = $p$$Register;
9334     Register Rq = $q$$Register;
9335     Register Ry = $y$$Register;
9336     Label done;
9337     __ cmpl(Rp, Rq);
9338     __ jccb(Assembler::less, done);
9339     __ xorl(Ry, Ry);
9340     __ bind(done);
9341   %}
9342   ins_pipe(pipe_cmplt);
9343 %}
9344 
9345 
9346 //---------- FP Instructions------------------------------------------------
9347 
9348 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
9349 %{
9350   match(Set cr (CmpF src1 src2));
9351 
9352   ins_cost(145);
9353   format %{ "ucomiss $src1, $src2\n\t"
9354             "jnp,s   exit\n\t"
9355             "pushfq\t# saw NaN, set CF\n\t"
9356             "andq    [rsp], #0xffffff2b\n\t"
9357             "popfq\n"
9358     "exit:" %}
9359   ins_encode %{
9360     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9361     emit_cmpfp_fixup(_masm);
9362   %}
9363   ins_pipe(pipe_slow);
9364 %}
9365 
9366 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
9367   match(Set cr (CmpF src1 src2));
9368 
9369   ins_cost(100);
9370   format %{ "ucomiss $src1, $src2" %}
9371   ins_encode %{
9372     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9373   %}
9374   ins_pipe(pipe_slow);
9375 %}
9376 
9377 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
9378 %{
9379   match(Set cr (CmpF src1 (LoadF src2)));
9380 
9381   ins_cost(145);
9382   format %{ "ucomiss $src1, $src2\n\t"
9383             "jnp,s   exit\n\t"
9384             "pushfq\t# saw NaN, set CF\n\t"
9385             "andq    [rsp], #0xffffff2b\n\t"
9386             "popfq\n"
9387     "exit:" %}
9388   ins_encode %{
9389     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9390     emit_cmpfp_fixup(_masm);
9391   %}
9392   ins_pipe(pipe_slow);
9393 %}
9394 
9395 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
9396   match(Set cr (CmpF src1 (LoadF src2)));
9397 
9398   ins_cost(100);
9399   format %{ "ucomiss $src1, $src2" %}
9400   ins_encode %{
9401     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9402   %}
9403   ins_pipe(pipe_slow);
9404 %}
9405 
9406 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
9407   match(Set cr (CmpF src con));
9408 
9409   ins_cost(145);
9410   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t"
9411             "jnp,s   exit\n\t"
9412             "pushfq\t# saw NaN, set CF\n\t"
9413             "andq    [rsp], #0xffffff2b\n\t"
9414             "popfq\n"
9415     "exit:" %}
9416   ins_encode %{
9417     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9418     emit_cmpfp_fixup(_masm);
9419   %}
9420   ins_pipe(pipe_slow);
9421 %}
9422 
9423 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
9424   match(Set cr (CmpF src con));
9425   ins_cost(100);
9426   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con" %}
9427   ins_encode %{
9428     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9429   %}
9430   ins_pipe(pipe_slow);
9431 %}
9432 
9433 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
9434 %{
9435   match(Set cr (CmpD src1 src2));
9436 
9437   ins_cost(145);
9438   format %{ "ucomisd $src1, $src2\n\t"
9439             "jnp,s   exit\n\t"
9440             "pushfq\t# saw NaN, set CF\n\t"
9441             "andq    [rsp], #0xffffff2b\n\t"
9442             "popfq\n"
9443     "exit:" %}
9444   ins_encode %{
9445     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9446     emit_cmpfp_fixup(_masm);
9447   %}
9448   ins_pipe(pipe_slow);
9449 %}
9450 
9451 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
9452   match(Set cr (CmpD src1 src2));
9453 
9454   ins_cost(100);
9455   format %{ "ucomisd $src1, $src2 test" %}
9456   ins_encode %{
9457     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9458   %}
9459   ins_pipe(pipe_slow);
9460 %}
9461 
9462 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
9463 %{
9464   match(Set cr (CmpD src1 (LoadD src2)));
9465 
9466   ins_cost(145);
9467   format %{ "ucomisd $src1, $src2\n\t"
9468             "jnp,s   exit\n\t"
9469             "pushfq\t# saw NaN, set CF\n\t"
9470             "andq    [rsp], #0xffffff2b\n\t"
9471             "popfq\n"
9472     "exit:" %}
9473   ins_encode %{
9474     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9475     emit_cmpfp_fixup(_masm);
9476   %}
9477   ins_pipe(pipe_slow);
9478 %}
9479 
9480 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
9481   match(Set cr (CmpD src1 (LoadD src2)));
9482 
9483   ins_cost(100);
9484   format %{ "ucomisd $src1, $src2" %}
9485   ins_encode %{
9486     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9487   %}
9488   ins_pipe(pipe_slow);
9489 %}
9490 
9491 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
9492   match(Set cr (CmpD src con));
9493 
9494   ins_cost(145);
9495   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t"
9496             "jnp,s   exit\n\t"
9497             "pushfq\t# saw NaN, set CF\n\t"
9498             "andq    [rsp], #0xffffff2b\n\t"
9499             "popfq\n"
9500     "exit:" %}
9501   ins_encode %{
9502     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9503     emit_cmpfp_fixup(_masm);
9504   %}
9505   ins_pipe(pipe_slow);
9506 %}
9507 
9508 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
9509   match(Set cr (CmpD src con));
9510   ins_cost(100);
9511   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con" %}
9512   ins_encode %{
9513     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9514   %}
9515   ins_pipe(pipe_slow);
9516 %}
9517 
9518 // Compare into -1,0,1
9519 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
9520 %{
9521   match(Set dst (CmpF3 src1 src2));
9522   effect(KILL cr);
9523 
9524   ins_cost(275);
9525   format %{ "ucomiss $src1, $src2\n\t"
9526             "movl    $dst, #-1\n\t"
9527             "jp,s    done\n\t"
9528             "jb,s    done\n\t"
9529             "setne   $dst\n\t"
9530             "movzbl  $dst, $dst\n"
9531     "done:" %}
9532   ins_encode %{
9533     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9534     emit_cmpfp3(_masm, $dst$$Register);
9535   %}
9536   ins_pipe(pipe_slow);
9537 %}
9538 
9539 // Compare into -1,0,1
9540 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
9541 %{
9542   match(Set dst (CmpF3 src1 (LoadF src2)));
9543   effect(KILL cr);
9544 
9545   ins_cost(275);
9546   format %{ "ucomiss $src1, $src2\n\t"
9547             "movl    $dst, #-1\n\t"
9548             "jp,s    done\n\t"
9549             "jb,s    done\n\t"
9550             "setne   $dst\n\t"
9551             "movzbl  $dst, $dst\n"
9552     "done:" %}
9553   ins_encode %{
9554     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9555     emit_cmpfp3(_masm, $dst$$Register);
9556   %}
9557   ins_pipe(pipe_slow);
9558 %}
9559 
9560 // Compare into -1,0,1
9561 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
9562   match(Set dst (CmpF3 src con));
9563   effect(KILL cr);
9564 
9565   ins_cost(275);
9566   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t"
9567             "movl    $dst, #-1\n\t"
9568             "jp,s    done\n\t"
9569             "jb,s    done\n\t"
9570             "setne   $dst\n\t"
9571             "movzbl  $dst, $dst\n"
9572     "done:" %}
9573   ins_encode %{
9574     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9575     emit_cmpfp3(_masm, $dst$$Register);
9576   %}
9577   ins_pipe(pipe_slow);
9578 %}
9579 
9580 // Compare into -1,0,1
9581 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
9582 %{
9583   match(Set dst (CmpD3 src1 src2));
9584   effect(KILL cr);
9585 
9586   ins_cost(275);
9587   format %{ "ucomisd $src1, $src2\n\t"
9588             "movl    $dst, #-1\n\t"
9589             "jp,s    done\n\t"
9590             "jb,s    done\n\t"
9591             "setne   $dst\n\t"
9592             "movzbl  $dst, $dst\n"
9593     "done:" %}
9594   ins_encode %{
9595     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9596     emit_cmpfp3(_masm, $dst$$Register);
9597   %}
9598   ins_pipe(pipe_slow);
9599 %}
9600 
9601 // Compare into -1,0,1
9602 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
9603 %{
9604   match(Set dst (CmpD3 src1 (LoadD src2)));
9605   effect(KILL cr);
9606 
9607   ins_cost(275);
9608   format %{ "ucomisd $src1, $src2\n\t"
9609             "movl    $dst, #-1\n\t"
9610             "jp,s    done\n\t"
9611             "jb,s    done\n\t"
9612             "setne   $dst\n\t"
9613             "movzbl  $dst, $dst\n"
9614     "done:" %}
9615   ins_encode %{
9616     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9617     emit_cmpfp3(_masm, $dst$$Register);
9618   %}
9619   ins_pipe(pipe_slow);
9620 %}
9621 
9622 // Compare into -1,0,1
9623 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
9624   match(Set dst (CmpD3 src con));
9625   effect(KILL cr);
9626 
9627   ins_cost(275);
9628   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t"
9629             "movl    $dst, #-1\n\t"
9630             "jp,s    done\n\t"
9631             "jb,s    done\n\t"
9632             "setne   $dst\n\t"
9633             "movzbl  $dst, $dst\n"
9634     "done:" %}
9635   ins_encode %{
9636     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9637     emit_cmpfp3(_masm, $dst$$Register);
9638   %}
9639   ins_pipe(pipe_slow);
9640 %}
9641 
9642 // -----------Trig and Trancendental Instructions------------------------------
9643 instruct cosD_reg(regD dst) %{
9644   match(Set dst (CosD dst));
9645 
9646   format %{ "dcos   $dst\n\t" %}
9647   opcode(0xD9, 0xFF);
9648   ins_encode( Push_SrcXD(dst), OpcP, OpcS, Push_ResultXD(dst) );
9649   ins_pipe( pipe_slow );
9650 %}
9651 
9652 instruct sinD_reg(regD dst) %{
9653   match(Set dst (SinD dst));
9654 
9655   format %{ "dsin   $dst\n\t" %}
9656   opcode(0xD9, 0xFE);
9657   ins_encode( Push_SrcXD(dst), OpcP, OpcS, Push_ResultXD(dst) );
9658   ins_pipe( pipe_slow );
9659 %}
9660 
9661 instruct tanD_reg(regD dst) %{
9662   match(Set dst (TanD dst));
9663 
9664   format %{ "dtan   $dst\n\t" %}
9665   ins_encode( Push_SrcXD(dst),
9666               Opcode(0xD9), Opcode(0xF2),   //fptan
9667               Opcode(0xDD), Opcode(0xD8),   //fstp st
9668               Push_ResultXD(dst) );
9669   ins_pipe( pipe_slow );
9670 %}
9671 
9672 instruct log10D_reg(regD dst) %{
9673   // The source and result Double operands in XMM registers
9674   match(Set dst (Log10D dst));
9675   // fldlg2       ; push log_10(2) on the FPU stack; full 80-bit number
9676   // fyl2x        ; compute log_10(2) * log_2(x)
9677   format %{ "fldlg2\t\t\t#Log10\n\t"
9678             "fyl2x\t\t\t# Q=Log10*Log_2(x)\n\t"
9679          %}
9680    ins_encode(Opcode(0xD9), Opcode(0xEC),   // fldlg2
9681               Push_SrcXD(dst),
9682               Opcode(0xD9), Opcode(0xF1),   // fyl2x
9683               Push_ResultXD(dst));
9684 
9685   ins_pipe( pipe_slow );
9686 %}
9687 
9688 instruct logD_reg(regD dst) %{
9689   // The source and result Double operands in XMM registers
9690   match(Set dst (LogD dst));
9691   // fldln2       ; push log_e(2) on the FPU stack; full 80-bit number
9692   // fyl2x        ; compute log_e(2) * log_2(x)
9693   format %{ "fldln2\t\t\t#Log_e\n\t"
9694             "fyl2x\t\t\t# Q=Log_e*Log_2(x)\n\t"
9695          %}
9696   ins_encode( Opcode(0xD9), Opcode(0xED),   // fldln2
9697               Push_SrcXD(dst),
9698               Opcode(0xD9), Opcode(0xF1),   // fyl2x
9699               Push_ResultXD(dst));
9700   ins_pipe( pipe_slow );
9701 %}
9702 
9703 instruct powD_reg(regD dst, regD src0, regD src1, rax_RegI rax, rdx_RegI rdx, rcx_RegI rcx, rFlagsReg cr) %{
9704   match(Set dst (PowD src0 src1));  // Raise src0 to the src1'th power
9705   effect(KILL rax, KILL rdx, KILL rcx, KILL cr);
9706   format %{ "fast_pow $src0 $src1 -&gt; $dst  // KILL $rax, $rcx, $rdx" %}
9707   ins_encode %{
9708     __ subptr(rsp, 8);
9709     __ movdbl(Address(rsp, 0), $src1$$XMMRegister);
9710     __ fld_d(Address(rsp, 0));
9711     __ movdbl(Address(rsp, 0), $src0$$XMMRegister);
9712     __ fld_d(Address(rsp, 0));
9713     __ fast_pow();
9714     __ fstp_d(Address(rsp, 0));
9715     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
9716     __ addptr(rsp, 8);
9717   %}
9718   ins_pipe( pipe_slow );
9719 %}
9720 
9721 instruct expD_reg(regD dst, regD src, rax_RegI rax, rdx_RegI rdx, rcx_RegI rcx, rFlagsReg cr) %{
9722   match(Set dst (ExpD src));
9723   effect(KILL rax, KILL rcx, KILL rdx, KILL cr);
9724   format %{ "fast_exp $dst -&gt; $src  // KILL $rax, $rcx, $rdx" %}
9725   ins_encode %{
9726     __ subptr(rsp, 8);
9727     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
9728     __ fld_d(Address(rsp, 0));
9729     __ fast_exp();
9730     __ fstp_d(Address(rsp, 0));
9731     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
9732     __ addptr(rsp, 8);
9733   %}
9734   ins_pipe( pipe_slow );
9735 %}
9736 
9737 //----------Arithmetic Conversion Instructions---------------------------------
9738 
9739 instruct roundFloat_nop(regF dst)
9740 %{
9741   match(Set dst (RoundFloat dst));
9742 
9743   ins_cost(0);
9744   ins_encode();
9745   ins_pipe(empty);
9746 %}
9747 
9748 instruct roundDouble_nop(regD dst)
9749 %{
9750   match(Set dst (RoundDouble dst));
9751 
9752   ins_cost(0);
9753   ins_encode();
9754   ins_pipe(empty);
9755 %}
9756 
9757 instruct convF2D_reg_reg(regD dst, regF src)
9758 %{
9759   match(Set dst (ConvF2D src));
9760 
9761   format %{ "cvtss2sd $dst, $src" %}
9762   ins_encode %{
9763     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
9764   %}
9765   ins_pipe(pipe_slow); // XXX
9766 %}
9767 
9768 instruct convF2D_reg_mem(regD dst, memory src)
9769 %{
9770   match(Set dst (ConvF2D (LoadF src)));
9771 
9772   format %{ "cvtss2sd $dst, $src" %}
9773   ins_encode %{
9774     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
9775   %}
9776   ins_pipe(pipe_slow); // XXX
9777 %}
9778 
9779 instruct convD2F_reg_reg(regF dst, regD src)
9780 %{
9781   match(Set dst (ConvD2F src));
9782 
9783   format %{ "cvtsd2ss $dst, $src" %}
9784   ins_encode %{
9785     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
9786   %}
9787   ins_pipe(pipe_slow); // XXX
9788 %}
9789 
9790 instruct convD2F_reg_mem(regF dst, memory src)
9791 %{
9792   match(Set dst (ConvD2F (LoadD src)));
9793 
9794   format %{ "cvtsd2ss $dst, $src" %}
9795   ins_encode %{
9796     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
9797   %}
9798   ins_pipe(pipe_slow); // XXX
9799 %}
9800 
9801 // XXX do mem variants
9802 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
9803 %{
9804   match(Set dst (ConvF2I src));
9805   effect(KILL cr);
9806 
9807   format %{ "cvttss2sil $dst, $src\t# f2i\n\t"
9808             "cmpl    $dst, #0x80000000\n\t"
9809             "jne,s   done\n\t"
9810             "subq    rsp, #8\n\t"
9811             "movss   [rsp], $src\n\t"
9812             "call    f2i_fixup\n\t"
9813             "popq    $dst\n"
9814     "done:   "%}
9815   ins_encode %{
9816     Label done;
9817     __ cvttss2sil($dst$$Register, $src$$XMMRegister);
9818     __ cmpl($dst$$Register, 0x80000000);
9819     __ jccb(Assembler::notEqual, done);
9820     __ subptr(rsp, 8);
9821     __ movflt(Address(rsp, 0), $src$$XMMRegister);
9822     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
9823     __ pop($dst$$Register);
9824     __ bind(done);
9825   %}
9826   ins_pipe(pipe_slow);
9827 %}
9828 
9829 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
9830 %{
9831   match(Set dst (ConvF2L src));
9832   effect(KILL cr);
9833 
9834   format %{ "cvttss2siq $dst, $src\t# f2l\n\t"
9835             "cmpq    $dst, [0x8000000000000000]\n\t"
9836             "jne,s   done\n\t"
9837             "subq    rsp, #8\n\t"
9838             "movss   [rsp], $src\n\t"
9839             "call    f2l_fixup\n\t"
9840             "popq    $dst\n"
9841     "done:   "%}
9842   ins_encode %{
9843     Label done;
9844     __ cvttss2siq($dst$$Register, $src$$XMMRegister);
9845     __ cmp64($dst$$Register,
9846              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
9847     __ jccb(Assembler::notEqual, done);
9848     __ subptr(rsp, 8);
9849     __ movflt(Address(rsp, 0), $src$$XMMRegister);
9850     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
9851     __ pop($dst$$Register);
9852     __ bind(done);
9853   %}
9854   ins_pipe(pipe_slow);
9855 %}
9856 
9857 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
9858 %{
9859   match(Set dst (ConvD2I src));
9860   effect(KILL cr);
9861 
9862   format %{ "cvttsd2sil $dst, $src\t# d2i\n\t"
9863             "cmpl    $dst, #0x80000000\n\t"
9864             "jne,s   done\n\t"
9865             "subq    rsp, #8\n\t"
9866             "movsd   [rsp], $src\n\t"
9867             "call    d2i_fixup\n\t"
9868             "popq    $dst\n"
9869     "done:   "%}
9870   ins_encode %{
9871     Label done;
9872     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);
9873     __ cmpl($dst$$Register, 0x80000000);
9874     __ jccb(Assembler::notEqual, done);
9875     __ subptr(rsp, 8);
9876     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
9877     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
9878     __ pop($dst$$Register);
9879     __ bind(done);
9880   %}
9881   ins_pipe(pipe_slow);
9882 %}
9883 
9884 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
9885 %{
9886   match(Set dst (ConvD2L src));
9887   effect(KILL cr);
9888 
9889   format %{ "cvttsd2siq $dst, $src\t# d2l\n\t"
9890             "cmpq    $dst, [0x8000000000000000]\n\t"
9891             "jne,s   done\n\t"
9892             "subq    rsp, #8\n\t"
9893             "movsd   [rsp], $src\n\t"
9894             "call    d2l_fixup\n\t"
9895             "popq    $dst\n"
9896     "done:   "%}
9897   ins_encode %{
9898     Label done;
9899     __ cvttsd2siq($dst$$Register, $src$$XMMRegister);
9900     __ cmp64($dst$$Register,
9901              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
9902     __ jccb(Assembler::notEqual, done);
9903     __ subptr(rsp, 8);
9904     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
9905     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
9906     __ pop($dst$$Register);
9907     __ bind(done);
9908   %}
9909   ins_pipe(pipe_slow);
9910 %}
9911 
9912 instruct convI2F_reg_reg(regF dst, rRegI src)
9913 %{
9914   predicate(!UseXmmI2F);
9915   match(Set dst (ConvI2F src));
9916 
9917   format %{ "cvtsi2ssl $dst, $src\t# i2f" %}
9918   ins_encode %{
9919     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
9920   %}
9921   ins_pipe(pipe_slow); // XXX
9922 %}
9923 
9924 instruct convI2F_reg_mem(regF dst, memory src)
9925 %{
9926   match(Set dst (ConvI2F (LoadI src)));
9927 
9928   format %{ "cvtsi2ssl $dst, $src\t# i2f" %}
9929   ins_encode %{
9930     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
9931   %}
9932   ins_pipe(pipe_slow); // XXX
9933 %}
9934 
9935 instruct convI2D_reg_reg(regD dst, rRegI src)
9936 %{
9937   predicate(!UseXmmI2D);
9938   match(Set dst (ConvI2D src));
9939 
9940   format %{ "cvtsi2sdl $dst, $src\t# i2d" %}
9941   ins_encode %{
9942     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
9943   %}
9944   ins_pipe(pipe_slow); // XXX
9945 %}
9946 
9947 instruct convI2D_reg_mem(regD dst, memory src)
9948 %{
9949   match(Set dst (ConvI2D (LoadI src)));
9950 
9951   format %{ "cvtsi2sdl $dst, $src\t# i2d" %}
9952   ins_encode %{
9953     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
9954   %}
9955   ins_pipe(pipe_slow); // XXX
9956 %}
9957 
9958 instruct convXI2F_reg(regF dst, rRegI src)
9959 %{
9960   predicate(UseXmmI2F);
9961   match(Set dst (ConvI2F src));
9962 
9963   format %{ "movdl $dst, $src\n\t"
9964             "cvtdq2psl $dst, $dst\t# i2f" %}
9965   ins_encode %{
9966     __ movdl($dst$$XMMRegister, $src$$Register);
9967     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
9968   %}
9969   ins_pipe(pipe_slow); // XXX
9970 %}
9971 
9972 instruct convXI2D_reg(regD dst, rRegI src)
9973 %{
9974   predicate(UseXmmI2D);
9975   match(Set dst (ConvI2D src));
9976 
9977   format %{ "movdl $dst, $src\n\t"
9978             "cvtdq2pdl $dst, $dst\t# i2d" %}
9979   ins_encode %{
9980     __ movdl($dst$$XMMRegister, $src$$Register);
9981     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
9982   %}
9983   ins_pipe(pipe_slow); // XXX
9984 %}
9985 
9986 instruct convL2F_reg_reg(regF dst, rRegL src)
9987 %{
9988   match(Set dst (ConvL2F src));
9989 
9990   format %{ "cvtsi2ssq $dst, $src\t# l2f" %}
9991   ins_encode %{
9992     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
9993   %}
9994   ins_pipe(pipe_slow); // XXX
9995 %}
9996 
9997 instruct convL2F_reg_mem(regF dst, memory src)
9998 %{
9999   match(Set dst (ConvL2F (LoadL src)));
10000 
10001   format %{ "cvtsi2ssq $dst, $src\t# l2f" %}
10002   ins_encode %{
10003     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10004   %}
10005   ins_pipe(pipe_slow); // XXX
10006 %}
10007 
10008 instruct convL2D_reg_reg(regD dst, rRegL src)
10009 %{
10010   match(Set dst (ConvL2D src));
10011 
10012   format %{ "cvtsi2sdq $dst, $src\t# l2d" %}
10013   ins_encode %{
10014     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10015   %}
10016   ins_pipe(pipe_slow); // XXX
10017 %}
10018 
10019 instruct convL2D_reg_mem(regD dst, memory src)
10020 %{
10021   match(Set dst (ConvL2D (LoadL src)));
10022 
10023   format %{ "cvtsi2sdq $dst, $src\t# l2d" %}
10024   ins_encode %{
10025     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10026   %}
10027   ins_pipe(pipe_slow); // XXX
10028 %}
10029 
10030 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10031 %{
10032   match(Set dst (ConvI2L src));
10033 
10034   ins_cost(125);
10035   format %{ "movslq  $dst, $src\t# i2l" %}
10036   ins_encode %{
10037     __ movslq($dst$$Register, $src$$Register);
10038   %}
10039   ins_pipe(ialu_reg_reg);
10040 %}
10041 
10042 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10043 // %{
10044 //   match(Set dst (ConvI2L src));
10045 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10046 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10047 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10048 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10049 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10050 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10051 
10052 //   format %{ "movl    $dst, $src\t# unsigned i2l" %}
10053 //   ins_encode(enc_copy(dst, src));
10054 // //   opcode(0x63); // needs REX.W
10055 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10056 //   ins_pipe(ialu_reg_reg);
10057 // %}
10058 
10059 // Zero-extend convert int to long
10060 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10061 %{
10062   match(Set dst (AndL (ConvI2L src) mask));
10063 
10064   format %{ "movl    $dst, $src\t# i2l zero-extend\n\t" %}
10065   ins_encode %{
10066     if ($dst$$reg != $src$$reg) {
10067       __ movl($dst$$Register, $src$$Register);
10068     }
10069   %}
10070   ins_pipe(ialu_reg_reg);
10071 %}
10072 
10073 // Zero-extend convert int to long
10074 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10075 %{
10076   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10077 
10078   format %{ "movl    $dst, $src\t# i2l zero-extend\n\t" %}
10079   ins_encode %{
10080     __ movl($dst$$Register, $src$$Address);
10081   %}
10082   ins_pipe(ialu_reg_mem);
10083 %}
10084 
10085 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10086 %{
10087   match(Set dst (AndL src mask));
10088 
10089   format %{ "movl    $dst, $src\t# zero-extend long" %}
10090   ins_encode %{
10091     __ movl($dst$$Register, $src$$Register);
10092   %}
10093   ins_pipe(ialu_reg_reg);
10094 %}
10095 
10096 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10097 %{
10098   match(Set dst (ConvL2I src));
10099 
10100   format %{ "movl    $dst, $src\t# l2i" %}
10101   ins_encode %{
10102     __ movl($dst$$Register, $src$$Register);
10103   %}
10104   ins_pipe(ialu_reg_reg);
10105 %}
10106 
10107 
10108 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10109   match(Set dst (MoveF2I src));
10110   effect(DEF dst, USE src);
10111 
10112   ins_cost(125);
10113   format %{ "movl    $dst, $src\t# MoveF2I_stack_reg" %}
10114   ins_encode %{
10115     __ movl($dst$$Register, Address(rsp, $src$$disp));
10116   %}
10117   ins_pipe(ialu_reg_mem);
10118 %}
10119 
10120 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10121   match(Set dst (MoveI2F src));
10122   effect(DEF dst, USE src);
10123 
10124   ins_cost(125);
10125   format %{ "movss   $dst, $src\t# MoveI2F_stack_reg" %}
10126   ins_encode %{
10127     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10128   %}
10129   ins_pipe(pipe_slow);
10130 %}
10131 
10132 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10133   match(Set dst (MoveD2L src));
10134   effect(DEF dst, USE src);
10135 
10136   ins_cost(125);
10137   format %{ "movq    $dst, $src\t# MoveD2L_stack_reg" %}
10138   ins_encode %{
10139     __ movq($dst$$Register, Address(rsp, $src$$disp));
10140   %}
10141   ins_pipe(ialu_reg_mem);
10142 %}
10143 
10144 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10145   predicate(!UseXmmLoadAndClearUpper);
10146   match(Set dst (MoveL2D src));
10147   effect(DEF dst, USE src);
10148 
10149   ins_cost(125);
10150   format %{ "movlpd  $dst, $src\t# MoveL2D_stack_reg" %}
10151   ins_encode %{
10152     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10153   %}
10154   ins_pipe(pipe_slow);
10155 %}
10156 
10157 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10158   predicate(UseXmmLoadAndClearUpper);
10159   match(Set dst (MoveL2D src));
10160   effect(DEF dst, USE src);
10161 
10162   ins_cost(125);
10163   format %{ "movsd   $dst, $src\t# MoveL2D_stack_reg" %}
10164   ins_encode %{
10165     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10166   %}
10167   ins_pipe(pipe_slow);
10168 %}
10169 
10170 
10171 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10172   match(Set dst (MoveF2I src));
10173   effect(DEF dst, USE src);
10174 
10175   ins_cost(95); // XXX
10176   format %{ "movss   $dst, $src\t# MoveF2I_reg_stack" %}
10177   ins_encode %{
10178     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10179   %}
10180   ins_pipe(pipe_slow);
10181 %}
10182 
10183 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10184   match(Set dst (MoveI2F src));
10185   effect(DEF dst, USE src);
10186 
10187   ins_cost(100);
10188   format %{ "movl    $dst, $src\t# MoveI2F_reg_stack" %}
10189   ins_encode %{
10190     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10191   %}
10192   ins_pipe( ialu_mem_reg );
10193 %}
10194 
10195 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10196   match(Set dst (MoveD2L src));
10197   effect(DEF dst, USE src);
10198 
10199   ins_cost(95); // XXX
10200   format %{ "movsd   $dst, $src\t# MoveL2D_reg_stack" %}
10201   ins_encode %{
10202     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10203   %}
10204   ins_pipe(pipe_slow);
10205 %}
10206 
10207 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10208   match(Set dst (MoveL2D src));
10209   effect(DEF dst, USE src);
10210 
10211   ins_cost(100);
10212   format %{ "movq    $dst, $src\t# MoveL2D_reg_stack" %}
10213   ins_encode %{
10214     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10215   %}
10216   ins_pipe(ialu_mem_reg);
10217 %}
10218 
10219 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10220   match(Set dst (MoveF2I src));
10221   effect(DEF dst, USE src);
10222   ins_cost(85);
10223   format %{ "movd    $dst,$src\t# MoveF2I" %}
10224   ins_encode %{
10225     __ movdl($dst$$Register, $src$$XMMRegister);
10226   %}
10227   ins_pipe( pipe_slow );
10228 %}
10229 
10230 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10231   match(Set dst (MoveD2L src));
10232   effect(DEF dst, USE src);
10233   ins_cost(85);
10234   format %{ "movd    $dst,$src\t# MoveD2L" %}
10235   ins_encode %{
10236     __ movdq($dst$$Register, $src$$XMMRegister);
10237   %}
10238   ins_pipe( pipe_slow );
10239 %}
10240 
10241 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10242   match(Set dst (MoveI2F src));
10243   effect(DEF dst, USE src);
10244   ins_cost(100);
10245   format %{ "movd    $dst,$src\t# MoveI2F" %}
10246   ins_encode %{
10247     __ movdl($dst$$XMMRegister, $src$$Register);
10248   %}
10249   ins_pipe( pipe_slow );
10250 %}
10251 
10252 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10253   match(Set dst (MoveL2D src));
10254   effect(DEF dst, USE src);
10255   ins_cost(100);
10256   format %{ "movd    $dst,$src\t# MoveL2D" %}
10257   ins_encode %{
10258      __ movdq($dst$$XMMRegister, $src$$Register);
10259   %}
10260   ins_pipe( pipe_slow );
10261 %}
10262 
10263 
10264 // =======================================================================
10265 // fast clearing of an array
10266 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, rax_RegI zero, Universe dummy,
10267                   rFlagsReg cr)
10268 %{
10269   predicate(!UseFastStosb);
10270   match(Set dummy (ClearArray cnt base));
10271   effect(USE_KILL cnt, USE_KILL base, KILL zero, KILL cr);
10272 
10273   format %{ "xorq    rax, rax\t# ClearArray:\n\t"
10274             "rep     stosq\t# Store rax to *rdi++ while rcx--" %}
10275   ins_encode %{ 
10276     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register);
10277   %}
10278   ins_pipe(pipe_slow);
10279 %}
10280 
10281 instruct rep_fast_stosb(rcx_RegL cnt, rdi_RegP base, rax_RegI zero, Universe dummy,
10282                         rFlagsReg cr)
10283 %{
10284   predicate(UseFastStosb);
10285   match(Set dummy (ClearArray cnt base));
10286   effect(USE_KILL cnt, USE_KILL base, KILL zero, KILL cr);
10287   format %{ "xorq    rax, rax\t# ClearArray:\n\t"
10288             "shlq    rcx,3\t# Convert doublewords to bytes\n\t"
10289             "rep     stosb\t# Store rax to *rdi++ while rcx--" %}
10290   ins_encode %{ 
10291     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register);
10292   %}
10293   ins_pipe( pipe_slow );
10294 %}
10295 
10296 instruct string_compare(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
10297                         rax_RegI result, regD tmp1, rFlagsReg cr)
10298 %{
10299   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10300   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
10301 
10302   format %{ "String Compare $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1" %}
10303   ins_encode %{
10304     __ string_compare($str1$$Register, $str2$$Register,
10305                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
10306                       $tmp1$$XMMRegister);
10307   %}
10308   ins_pipe( pipe_slow );
10309 %}
10310 
10311 // fast search of substring with known size.
10312 instruct string_indexof_con(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
10313                             rbx_RegI result, regD vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
10314 %{
10315   predicate(UseSSE42Intrinsics);
10316   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
10317   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
10318 
10319   format %{ "String IndexOf $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp" %}
10320   ins_encode %{
10321     int icnt2 = (int)$int_cnt2$$constant;
10322     if (icnt2 &gt;= 8) {
10323       // IndexOf for constant substrings with size &gt;= 8 elements
10324       // which don't need to be loaded through stack.
10325       __ string_indexofC8($str1$$Register, $str2$$Register,
10326                           $cnt1$$Register, $cnt2$$Register,
10327                           icnt2, $result$$Register,
10328                           $vec$$XMMRegister, $tmp$$Register);
10329     } else {
10330       // Small strings are loaded through stack if they cross page boundary.
10331       __ string_indexof($str1$$Register, $str2$$Register,
10332                         $cnt1$$Register, $cnt2$$Register,
10333                         icnt2, $result$$Register,
10334                         $vec$$XMMRegister, $tmp$$Register);
10335     }
10336   %}
10337   ins_pipe( pipe_slow );
10338 %}
10339 
10340 instruct string_indexof(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
10341                         rbx_RegI result, regD vec, rcx_RegI tmp, rFlagsReg cr)
10342 %{
10343   predicate(UseSSE42Intrinsics);
10344   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
10345   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
10346 
10347   format %{ "String IndexOf $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all" %}
10348   ins_encode %{
10349     __ string_indexof($str1$$Register, $str2$$Register,
10350                       $cnt1$$Register, $cnt2$$Register,
10351                       (-1), $result$$Register,
10352                       $vec$$XMMRegister, $tmp$$Register);
10353   %}
10354   ins_pipe( pipe_slow );
10355 %}
10356 
10357 // fast string equals
10358 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
10359                        regD tmp1, regD tmp2, rbx_RegI tmp3, rFlagsReg cr)
10360 %{
10361   match(Set result (StrEquals (Binary str1 str2) cnt));
10362   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
10363 
10364   format %{ "String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3" %}
10365   ins_encode %{
10366     __ char_arrays_equals(false, $str1$$Register, $str2$$Register,
10367                           $cnt$$Register, $result$$Register, $tmp3$$Register,
10368                           $tmp1$$XMMRegister, $tmp2$$XMMRegister);
10369   %}
10370   ins_pipe( pipe_slow );
10371 %}
10372 
10373 // fast array equals
10374 instruct array_equals(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
10375                       regD tmp1, regD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
10376 %{
10377   match(Set result (AryEq ary1 ary2));
10378   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
10379   //ins_cost(300);
10380 
10381   format %{ "Array Equals $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4" %}
10382   ins_encode %{
10383     __ char_arrays_equals(true, $ary1$$Register, $ary2$$Register,
10384                           $tmp3$$Register, $result$$Register, $tmp4$$Register,
10385                           $tmp1$$XMMRegister, $tmp2$$XMMRegister);
10386   %}
10387   ins_pipe( pipe_slow );
10388 %}
10389 
10390 // encode char[] to byte[] in ISO_8859_1
10391 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
10392                           regD tmp1, regD tmp2, regD tmp3, regD tmp4,
10393                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
10394   match(Set result (EncodeISOArray src (Binary dst len)));
10395   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
10396 
10397   format %{ "Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI " %}
10398   ins_encode %{
10399     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
10400                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
10401                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
10402   %}
10403   ins_pipe( pipe_slow );
10404 %}
10405 
10406 //----------Overflow Math Instructions-----------------------------------------
10407 
10408 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
10409 %{
10410   match(Set cr (OverflowAddI op1 op2));
10411   effect(DEF cr, USE_KILL op1, USE op2);
10412 
10413   format %{ "addl    $op1, $op2\t# overflow check int" %}
10414 
10415   ins_encode %{
10416     __ addl($op1$$Register, $op2$$Register);
10417   %}
10418   ins_pipe(ialu_reg_reg);
10419 %}
10420 
10421 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
10422 %{
10423   match(Set cr (OverflowAddI op1 op2));
10424   effect(DEF cr, USE_KILL op1, USE op2);
10425 
10426   format %{ "addl    $op1, $op2\t# overflow check int" %}
10427 
10428   ins_encode %{
10429     __ addl($op1$$Register, $op2$$constant);
10430   %}
10431   ins_pipe(ialu_reg_reg);
10432 %}
10433 
10434 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
10435 %{
10436   match(Set cr (OverflowAddL op1 op2));
10437   effect(DEF cr, USE_KILL op1, USE op2);
10438 
10439   format %{ "addq    $op1, $op2\t# overflow check long" %}
10440   ins_encode %{
10441     __ addq($op1$$Register, $op2$$Register);
10442   %}
10443   ins_pipe(ialu_reg_reg);
10444 %}
10445 
10446 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
10447 %{
10448   match(Set cr (OverflowAddL op1 op2));
10449   effect(DEF cr, USE_KILL op1, USE op2);
10450 
10451   format %{ "addq    $op1, $op2\t# overflow check long" %}
10452   ins_encode %{
10453     __ addq($op1$$Register, $op2$$constant);
10454   %}
10455   ins_pipe(ialu_reg_reg);
10456 %}
10457 
10458 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
10459 %{
10460   match(Set cr (OverflowSubI op1 op2));
10461 
10462   format %{ "cmpl    $op1, $op2\t# overflow check int" %}
10463   ins_encode %{
10464     __ cmpl($op1$$Register, $op2$$Register);
10465   %}
10466   ins_pipe(ialu_reg_reg);
10467 %}
10468 
10469 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
10470 %{
10471   match(Set cr (OverflowSubI op1 op2));
10472 
10473   format %{ "cmpl    $op1, $op2\t# overflow check int" %}
10474   ins_encode %{
10475     __ cmpl($op1$$Register, $op2$$constant);
10476   %}
10477   ins_pipe(ialu_reg_reg);
10478 %}
10479 
10480 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
10481 %{
10482   match(Set cr (OverflowSubL op1 op2));
10483 
10484   format %{ "cmpq    $op1, $op2\t# overflow check long" %}
10485   ins_encode %{
10486     __ cmpq($op1$$Register, $op2$$Register);
10487   %}
10488   ins_pipe(ialu_reg_reg);
10489 %}
10490 
10491 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
10492 %{
10493   match(Set cr (OverflowSubL op1 op2));
10494 
10495   format %{ "cmpq    $op1, $op2\t# overflow check long" %}
10496   ins_encode %{
10497     __ cmpq($op1$$Register, $op2$$constant);
10498   %}
10499   ins_pipe(ialu_reg_reg);
10500 %}
10501 
10502 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
10503 %{
10504   match(Set cr (OverflowSubI zero op2));
10505   effect(DEF cr, USE_KILL op2);
10506 
10507   format %{ "negl    $op2\t# overflow check int" %}
10508   ins_encode %{
10509     __ negl($op2$$Register);
10510   %}
10511   ins_pipe(ialu_reg_reg);
10512 %}
10513 
10514 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
10515 %{
10516   match(Set cr (OverflowSubL zero op2));
10517   effect(DEF cr, USE_KILL op2);
10518 
10519   format %{ "negq    $op2\t# overflow check long" %}
10520   ins_encode %{
10521     __ negq($op2$$Register);
10522   %}
10523   ins_pipe(ialu_reg_reg);
10524 %}
10525 
10526 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
10527 %{
10528   match(Set cr (OverflowMulI op1 op2));
10529   effect(DEF cr, USE_KILL op1, USE op2);
10530 
10531   format %{ "imull    $op1, $op2\t# overflow check int" %}
10532   ins_encode %{
10533     __ imull($op1$$Register, $op2$$Register);
10534   %}
10535   ins_pipe(ialu_reg_reg_alu0);
10536 %}
10537 
10538 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
10539 %{
10540   match(Set cr (OverflowMulI op1 op2));
10541   effect(DEF cr, TEMP tmp, USE op1, USE op2);
10542 
10543   format %{ "imull    $tmp, $op1, $op2\t# overflow check int" %}
10544   ins_encode %{
10545     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
10546   %}
10547   ins_pipe(ialu_reg_reg_alu0);
10548 %}
10549 
10550 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
10551 %{
10552   match(Set cr (OverflowMulL op1 op2));
10553   effect(DEF cr, USE_KILL op1, USE op2);
10554 
10555   format %{ "imulq    $op1, $op2\t# overflow check long" %}
10556   ins_encode %{
10557     __ imulq($op1$$Register, $op2$$Register);
10558   %}
10559   ins_pipe(ialu_reg_reg_alu0);
10560 %}
10561 
10562 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
10563 %{
10564   match(Set cr (OverflowMulL op1 op2));
10565   effect(DEF cr, TEMP tmp, USE op1, USE op2);
10566 
10567   format %{ "imulq    $tmp, $op1, $op2\t# overflow check long" %}
10568   ins_encode %{
10569     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
10570   %}
10571   ins_pipe(ialu_reg_reg_alu0);
10572 %}
10573 
10574 
10575 //----------Control Flow Instructions------------------------------------------
10576 // Signed compare Instructions
10577 
10578 // XXX more variants!!
10579 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
10580 %{
10581   match(Set cr (CmpI op1 op2));
10582   effect(DEF cr, USE op1, USE op2);
10583 
10584   format %{ "cmpl    $op1, $op2" %}
10585   opcode(0x3B);  /* Opcode 3B /r */
10586   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
10587   ins_pipe(ialu_cr_reg_reg);
10588 %}
10589 
10590 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
10591 %{
10592   match(Set cr (CmpI op1 op2));
10593 
10594   format %{ "cmpl    $op1, $op2" %}
10595   opcode(0x81, 0x07); /* Opcode 81 /7 */
10596   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
10597   ins_pipe(ialu_cr_reg_imm);
10598 %}
10599 
10600 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
10601 %{
10602   match(Set cr (CmpI op1 (LoadI op2)));
10603 
10604   ins_cost(500); // XXX
10605   format %{ "cmpl    $op1, $op2" %}
10606   opcode(0x3B); /* Opcode 3B /r */
10607   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
10608   ins_pipe(ialu_cr_reg_mem);
10609 %}
10610 
10611 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
10612 %{
10613   match(Set cr (CmpI src zero));
10614 
10615   format %{ "testl   $src, $src" %}
10616   opcode(0x85);
10617   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
10618   ins_pipe(ialu_cr_reg_imm);
10619 %}
10620 
10621 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
10622 %{
10623   match(Set cr (CmpI (AndI src con) zero));
10624 
10625   format %{ "testl   $src, $con" %}
10626   opcode(0xF7, 0x00);
10627   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
10628   ins_pipe(ialu_cr_reg_imm);
10629 %}
10630 
10631 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
10632 %{
10633   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
10634 
10635   format %{ "testl   $src, $mem" %}
10636   opcode(0x85);
10637   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
10638   ins_pipe(ialu_cr_reg_mem);
10639 %}
10640 
10641 // Unsigned compare Instructions; really, same as signed except they
10642 // produce an rFlagsRegU instead of rFlagsReg.
10643 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
10644 %{
10645   match(Set cr (CmpU op1 op2));
10646 
10647   format %{ "cmpl    $op1, $op2\t# unsigned" %}
10648   opcode(0x3B); /* Opcode 3B /r */
10649   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
10650   ins_pipe(ialu_cr_reg_reg);
10651 %}
10652 
10653 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
10654 %{
10655   match(Set cr (CmpU op1 op2));
10656 
10657   format %{ "cmpl    $op1, $op2\t# unsigned" %}
10658   opcode(0x81,0x07); /* Opcode 81 /7 */
10659   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
10660   ins_pipe(ialu_cr_reg_imm);
10661 %}
10662 
10663 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
10664 %{
10665   match(Set cr (CmpU op1 (LoadI op2)));
10666 
10667   ins_cost(500); // XXX
10668   format %{ "cmpl    $op1, $op2\t# unsigned" %}
10669   opcode(0x3B); /* Opcode 3B /r */
10670   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
10671   ins_pipe(ialu_cr_reg_mem);
10672 %}
10673 
10674 // // // Cisc-spilled version of cmpU_rReg
10675 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
10676 // //%{
10677 // //  match(Set cr (CmpU (LoadI op1) op2));
10678 // //
10679 // //  format %{ "CMPu   $op1,$op2" %}
10680 // //  ins_cost(500);
10681 // //  opcode(0x39);  /* Opcode 39 /r */
10682 // //  ins_encode( OpcP, reg_mem( op1, op2) );
10683 // //%}
10684 
10685 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
10686 %{
10687   match(Set cr (CmpU src zero));
10688 
10689   format %{ "testl  $src, $src\t# unsigned" %}
10690   opcode(0x85);
10691   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
10692   ins_pipe(ialu_cr_reg_imm);
10693 %}
10694 
10695 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
10696 %{
10697   match(Set cr (CmpP op1 op2));
10698 
10699   format %{ "cmpq    $op1, $op2\t# ptr" %}
10700   opcode(0x3B); /* Opcode 3B /r */
10701   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
10702   ins_pipe(ialu_cr_reg_reg);
10703 %}
10704 
10705 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
10706 %{
10707   match(Set cr (CmpP op1 (LoadP op2)));
10708 
10709   ins_cost(500); // XXX
10710   format %{ "cmpq    $op1, $op2\t# ptr" %}
10711   opcode(0x3B); /* Opcode 3B /r */
10712   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
10713   ins_pipe(ialu_cr_reg_mem);
10714 %}
10715 
10716 // // // Cisc-spilled version of cmpP_rReg
10717 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
10718 // //%{
10719 // //  match(Set cr (CmpP (LoadP op1) op2));
10720 // //
10721 // //  format %{ "CMPu   $op1,$op2" %}
10722 // //  ins_cost(500);
10723 // //  opcode(0x39);  /* Opcode 39 /r */
10724 // //  ins_encode( OpcP, reg_mem( op1, op2) );
10725 // //%}
10726 
10727 // XXX this is generalized by compP_rReg_mem???
10728 // Compare raw pointer (used in out-of-heap check).
10729 // Only works because non-oop pointers must be raw pointers
10730 // and raw pointers have no anti-dependencies.
10731 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
10732 %{
10733   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none);
10734   match(Set cr (CmpP op1 (LoadP op2)));
10735 
10736   format %{ "cmpq    $op1, $op2\t# raw ptr" %}
10737   opcode(0x3B); /* Opcode 3B /r */
10738   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
10739   ins_pipe(ialu_cr_reg_mem);
10740 %}
10741 
10742 // This will generate a signed flags result. This should be OK since
10743 // any compare to a zero should be eq/neq.
10744 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
10745 %{
10746   match(Set cr (CmpP src zero));
10747 
10748   format %{ "testq   $src, $src\t# ptr" %}
10749   opcode(0x85);
10750   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
10751   ins_pipe(ialu_cr_reg_imm);
10752 %}
10753 
10754 // This will generate a signed flags result. This should be OK since
10755 // any compare to a zero should be eq/neq.
10756 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
10757 %{
10758   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));
10759   match(Set cr (CmpP (LoadP op) zero));
10760 
10761   ins_cost(500); // XXX
10762   format %{ "testq   $op, 0xffffffffffffffff\t# ptr" %}
10763   opcode(0xF7); /* Opcode F7 /0 */
10764   ins_encode(REX_mem_wide(op),
10765              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
10766   ins_pipe(ialu_cr_reg_imm);
10767 %}
10768 
10769 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
10770 %{
10771   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
10772   match(Set cr (CmpP (LoadP mem) zero));
10773 
10774   format %{ "cmpq    R12, $mem\t# ptr (R12_heapbase==0)" %}
10775   ins_encode %{
10776     __ cmpq(r12, $mem$$Address);
10777   %}
10778   ins_pipe(ialu_cr_reg_mem);
10779 %}
10780 
10781 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
10782 %{
10783   match(Set cr (CmpN op1 op2));
10784 
10785   format %{ "cmpl    $op1, $op2\t# compressed ptr" %}
10786   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
10787   ins_pipe(ialu_cr_reg_reg);
10788 %}
10789 
10790 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
10791 %{
10792   match(Set cr (CmpN src (LoadN mem)));
10793 
10794   format %{ "cmpl    $src, $mem\t# compressed ptr" %}
10795   ins_encode %{
10796     __ cmpl($src$$Register, $mem$$Address);
10797   %}
10798   ins_pipe(ialu_cr_reg_mem);
10799 %}
10800 
10801 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
10802   match(Set cr (CmpN op1 op2));
10803 
10804   format %{ "cmpl    $op1, $op2\t# compressed ptr" %}
10805   ins_encode %{
10806     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
10807   %}
10808   ins_pipe(ialu_cr_reg_imm);
10809 %}
10810 
10811 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
10812 %{
10813   match(Set cr (CmpN src (LoadN mem)));
10814 
10815   format %{ "cmpl    $mem, $src\t# compressed ptr" %}
10816   ins_encode %{
10817     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
10818   %}
10819   ins_pipe(ialu_cr_reg_mem);
10820 %}
10821 
10822 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
10823   match(Set cr (CmpN op1 op2));
10824 
10825   format %{ "cmpl    $op1, $op2\t# compressed klass ptr" %}
10826   ins_encode %{
10827     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
10828   %}
10829   ins_pipe(ialu_cr_reg_imm);
10830 %}
10831 
10832 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
10833 %{
10834   match(Set cr (CmpN src (LoadNKlass mem)));
10835 
10836   format %{ "cmpl    $mem, $src\t# compressed klass ptr" %}
10837   ins_encode %{
10838     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
10839   %}
10840   ins_pipe(ialu_cr_reg_mem);
10841 %}
10842 
10843 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
10844   match(Set cr (CmpN src zero));
10845 
10846   format %{ "testl   $src, $src\t# compressed ptr" %}
10847   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
10848   ins_pipe(ialu_cr_reg_imm);
10849 %}
10850 
10851 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
10852 %{
10853   predicate(Universe::narrow_oop_base() != NULL);
10854   match(Set cr (CmpN (LoadN mem) zero));
10855 
10856   ins_cost(500); // XXX
10857   format %{ "testl   $mem, 0xffffffff\t# compressed ptr" %}
10858   ins_encode %{
10859     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
10860   %}
10861   ins_pipe(ialu_cr_reg_mem);
10862 %}
10863 
10864 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
10865 %{
10866   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; (Universe::narrow_klass_base() == NULL));
10867   match(Set cr (CmpN (LoadN mem) zero));
10868 
10869   format %{ "cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)" %}
10870   ins_encode %{
10871     __ cmpl(r12, $mem$$Address);
10872   %}
10873   ins_pipe(ialu_cr_reg_mem);
10874 %}
10875 
10876 // Yanked all unsigned pointer compare operations.
10877 // Pointer compares are done with CmpP which is already unsigned.
10878 
10879 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
10880 %{
10881   match(Set cr (CmpL op1 op2));
10882 
10883   format %{ "cmpq    $op1, $op2" %}
10884   opcode(0x3B);  /* Opcode 3B /r */
10885   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
10886   ins_pipe(ialu_cr_reg_reg);
10887 %}
10888 
10889 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
10890 %{
10891   match(Set cr (CmpL op1 op2));
10892 
10893   format %{ "cmpq    $op1, $op2" %}
10894   opcode(0x81, 0x07); /* Opcode 81 /7 */
10895   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
10896   ins_pipe(ialu_cr_reg_imm);
10897 %}
10898 
10899 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
10900 %{
10901   match(Set cr (CmpL op1 (LoadL op2)));
10902 
10903   format %{ "cmpq    $op1, $op2" %}
10904   opcode(0x3B); /* Opcode 3B /r */
10905   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
10906   ins_pipe(ialu_cr_reg_mem);
10907 %}
10908 
10909 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
10910 %{
10911   match(Set cr (CmpL src zero));
10912 
10913   format %{ "testq   $src, $src" %}
10914   opcode(0x85);
10915   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
10916   ins_pipe(ialu_cr_reg_imm);
10917 %}
10918 
10919 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
10920 %{
10921   match(Set cr (CmpL (AndL src con) zero));
10922 
10923   format %{ "testq   $src, $con\t# long" %}
10924   opcode(0xF7, 0x00);
10925   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
10926   ins_pipe(ialu_cr_reg_imm);
10927 %}
10928 
10929 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
10930 %{
10931   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
10932 
10933   format %{ "testq   $src, $mem" %}
10934   opcode(0x85);
10935   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
10936   ins_pipe(ialu_cr_reg_mem);
10937 %}
10938 
10939 // Manifest a CmpL result in an integer register.  Very painful.
10940 // This is the test to avoid.
10941 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
10942 %{
10943   match(Set dst (CmpL3 src1 src2));
10944   effect(KILL flags);
10945 
10946   ins_cost(275); // XXX
10947   format %{ "cmpq    $src1, $src2\t# CmpL3\n\t"
10948             "movl    $dst, -1\n\t"
10949             "jl,s    done\n\t"
10950             "setne   $dst\n\t"
10951             "movzbl  $dst, $dst\n\t"
10952     "done:" %}
10953   ins_encode(cmpl3_flag(src1, src2, dst));
10954   ins_pipe(pipe_slow);
10955 %}
10956 
10957 //----------Max and Min--------------------------------------------------------
10958 // Min Instructions
10959 
10960 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
10961 %{
10962   effect(USE_DEF dst, USE src, USE cr);
10963 
10964   format %{ "cmovlgt $dst, $src\t# min" %}
10965   opcode(0x0F, 0x4F);
10966   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
10967   ins_pipe(pipe_cmov_reg);
10968 %}
10969 
10970 
10971 instruct minI_rReg(rRegI dst, rRegI src)
10972 %{
10973   match(Set dst (MinI dst src));
10974 
10975   ins_cost(200);
10976   expand %{
10977     rFlagsReg cr;
10978     compI_rReg(cr, dst, src);
10979     cmovI_reg_g(dst, src, cr);
10980   %}
10981 %}
10982 
10983 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
10984 %{
10985   effect(USE_DEF dst, USE src, USE cr);
10986 
10987   format %{ "cmovllt $dst, $src\t# max" %}
10988   opcode(0x0F, 0x4C);
10989   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
10990   ins_pipe(pipe_cmov_reg);
10991 %}
10992 
10993 
10994 instruct maxI_rReg(rRegI dst, rRegI src)
10995 %{
10996   match(Set dst (MaxI dst src));
10997 
10998   ins_cost(200);
10999   expand %{
11000     rFlagsReg cr;
11001     compI_rReg(cr, dst, src);
11002     cmovI_reg_l(dst, src, cr);
11003   %}
11004 %}
11005 
11006 // ============================================================================
11007 // Branch Instructions
11008 
11009 // Jump Direct - Label defines a relative address from JMP+1
11010 instruct jmpDir(label labl)
11011 %{
11012   match(Goto);
11013   effect(USE labl);
11014 
11015   ins_cost(300);
11016   format %{ "jmp     $labl" %}
11017   size(5);
11018   ins_encode %{
11019     Label* L = $labl$$label;
11020     __ jmp(*L, false); // Always long jump
11021   %}
11022   ins_pipe(pipe_jmp);
11023 %}
11024 
11025 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11026 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
11027 %{
11028   match(If cop cr);
11029   effect(USE labl);
11030 
11031   ins_cost(300);
11032   format %{ "j$cop     $labl" %}
11033   size(6);
11034   ins_encode %{
11035     Label* L = $labl$$label;
11036     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11037   %}
11038   ins_pipe(pipe_jcc);
11039 %}
11040 
11041 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11042 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
11043 %{
11044   match(CountedLoopEnd cop cr);
11045   effect(USE labl);
11046 
11047   ins_cost(300);
11048   format %{ "j$cop     $labl\t# loop end" %}
11049   size(6);
11050   ins_encode %{
11051     Label* L = $labl$$label;
11052     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11053   %}
11054   ins_pipe(pipe_jcc);
11055 %}
11056 
11057 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11058 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11059   match(CountedLoopEnd cop cmp);
11060   effect(USE labl);
11061 
11062   ins_cost(300);
11063   format %{ "j$cop,u   $labl\t# loop end" %}
11064   size(6);
11065   ins_encode %{
11066     Label* L = $labl$$label;
11067     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11068   %}
11069   ins_pipe(pipe_jcc);
11070 %}
11071 
11072 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11073   match(CountedLoopEnd cop cmp);
11074   effect(USE labl);
11075 
11076   ins_cost(200);
11077   format %{ "j$cop,u   $labl\t# loop end" %}
11078   size(6);
11079   ins_encode %{
11080     Label* L = $labl$$label;
11081     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11082   %}
11083   ins_pipe(pipe_jcc);
11084 %}
11085 
11086 // Jump Direct Conditional - using unsigned comparison
11087 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11088   match(If cop cmp);
11089   effect(USE labl);
11090 
11091   ins_cost(300);
11092   format %{ "j$cop,u  $labl" %}
11093   size(6);
11094   ins_encode %{
11095     Label* L = $labl$$label;
11096     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11097   %}
11098   ins_pipe(pipe_jcc);
11099 %}
11100 
11101 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11102   match(If cop cmp);
11103   effect(USE labl);
11104 
11105   ins_cost(200);
11106   format %{ "j$cop,u  $labl" %}
11107   size(6);
11108   ins_encode %{
11109     Label* L = $labl$$label;
11110     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11111   %}
11112   ins_pipe(pipe_jcc);
11113 %}
11114 
11115 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
11116   match(If cop cmp);
11117   effect(USE labl);
11118 
11119   ins_cost(200);
11120   format %{ $$template
11121     if ($cop$$cmpcode == Assembler::notEqual) {
11122       $$emit$$"jp,u   $labl\n\t"
11123       $$emit$$"j$cop,u   $labl"
11124     } else {
11125       $$emit$$"jp,u   done\n\t"
11126       $$emit$$"j$cop,u   $labl\n\t"
11127       $$emit$$"done:"
11128     }
11129   %}
11130   ins_encode %{
11131     Label* l = $labl$$label;
11132     if ($cop$$cmpcode == Assembler::notEqual) {
11133       __ jcc(Assembler::parity, *l, false);
11134       __ jcc(Assembler::notEqual, *l, false);
11135     } else if ($cop$$cmpcode == Assembler::equal) {
11136       Label done;
11137       __ jccb(Assembler::parity, done);
11138       __ jcc(Assembler::equal, *l, false);
11139       __ bind(done);
11140     } else {
11141        ShouldNotReachHere();
11142     }
11143   %}
11144   ins_pipe(pipe_jcc);
11145 %}
11146 
11147 // ============================================================================
11148 // The 2nd slow-half of a subtype check.  Scan the subklass's 2ndary
11149 // superklass array for an instance of the superklass.  Set a hidden
11150 // internal cache on a hit (cache is checked with exposed code in
11151 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
11152 // encoding ALSO sets flags.
11153 
11154 instruct partialSubtypeCheck(rdi_RegP result,
11155                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
11156                              rFlagsReg cr)
11157 %{
11158   match(Set result (PartialSubtypeCheck sub super));
11159   effect(KILL rcx, KILL cr);
11160 
11161   ins_cost(1100);  // slightly larger than the next version
11162   format %{ "movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t"
11163             "movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t"
11164             "addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t"
11165             "repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t"
11166             "jne,s   miss\t\t# Missed: rdi not-zero\n\t"
11167             "movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t"
11168             "xorq    $result, $result\t\t Hit: rdi zero\n\t"
11169     "miss:\t" %}
11170 
11171   opcode(0x1); // Force a XOR of RDI
11172   ins_encode(enc_PartialSubtypeCheck());
11173   ins_pipe(pipe_slow);
11174 %}
11175 
11176 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
11177                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
11178                                      immP0 zero,
11179                                      rdi_RegP result)
11180 %{
11181   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
11182   effect(KILL rcx, KILL result);
11183 
11184   ins_cost(1000);
11185   format %{ "movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t"
11186             "movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t"
11187             "addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t"
11188             "repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t"
11189             "jne,s   miss\t\t# Missed: flags nz\n\t"
11190             "movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t"
11191     "miss:\t" %}
11192 
11193   opcode(0x0); // No need to XOR RDI
11194   ins_encode(enc_PartialSubtypeCheck());
11195   ins_pipe(pipe_slow);
11196 %}
11197 
11198 // ============================================================================
11199 // Branch Instructions -- short offset versions
11200 //
11201 // These instructions are used to replace jumps of a long offset (the default
11202 // match) with jumps of a shorter offset.  These instructions are all tagged
11203 // with the ins_short_branch attribute, which causes the ADLC to suppress the
11204 // match rules in general matching.  Instead, the ADLC generates a conversion
11205 // method in the MachNode which can be used to do in-place replacement of the
11206 // long variant with the shorter variant.  The compiler will determine if a
11207 // branch can be taken by the is_short_branch_offset() predicate in the machine
11208 // specific code section of the file.
11209 
11210 // Jump Direct - Label defines a relative address from JMP+1
11211 instruct jmpDir_short(label labl) %{
11212   match(Goto);
11213   effect(USE labl);
11214 
11215   ins_cost(300);
11216   format %{ "jmp,s   $labl" %}
11217   size(2);
11218   ins_encode %{
11219     Label* L = $labl$$label;
11220     __ jmpb(*L);
11221   %}
11222   ins_pipe(pipe_jmp);
11223   ins_short_branch(1);
11224 %}
11225 
11226 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11227 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
11228   match(If cop cr);
11229   effect(USE labl);
11230 
11231   ins_cost(300);
11232   format %{ "j$cop,s   $labl" %}
11233   size(2);
11234   ins_encode %{
11235     Label* L = $labl$$label;
11236     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11237   %}
11238   ins_pipe(pipe_jcc);
11239   ins_short_branch(1);
11240 %}
11241 
11242 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11243 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
11244   match(CountedLoopEnd cop cr);
11245   effect(USE labl);
11246 
11247   ins_cost(300);
11248   format %{ "j$cop,s   $labl\t# loop end" %}
11249   size(2);
11250   ins_encode %{
11251     Label* L = $labl$$label;
11252     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11253   %}
11254   ins_pipe(pipe_jcc);
11255   ins_short_branch(1);
11256 %}
11257 
11258 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11259 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11260   match(CountedLoopEnd cop cmp);
11261   effect(USE labl);
11262 
11263   ins_cost(300);
11264   format %{ "j$cop,us  $labl\t# loop end" %}
11265   size(2);
11266   ins_encode %{
11267     Label* L = $labl$$label;
11268     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11269   %}
11270   ins_pipe(pipe_jcc);
11271   ins_short_branch(1);
11272 %}
11273 
11274 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11275   match(CountedLoopEnd cop cmp);
11276   effect(USE labl);
11277 
11278   ins_cost(300);
11279   format %{ "j$cop,us  $labl\t# loop end" %}
11280   size(2);
11281   ins_encode %{
11282     Label* L = $labl$$label;
11283     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11284   %}
11285   ins_pipe(pipe_jcc);
11286   ins_short_branch(1);
11287 %}
11288 
11289 // Jump Direct Conditional - using unsigned comparison
11290 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11291   match(If cop cmp);
11292   effect(USE labl);
11293 
11294   ins_cost(300);
11295   format %{ "j$cop,us  $labl" %}
11296   size(2);
11297   ins_encode %{
11298     Label* L = $labl$$label;
11299     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11300   %}
11301   ins_pipe(pipe_jcc);
11302   ins_short_branch(1);
11303 %}
11304 
11305 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11306   match(If cop cmp);
11307   effect(USE labl);
11308 
11309   ins_cost(300);
11310   format %{ "j$cop,us  $labl" %}
11311   size(2);
11312   ins_encode %{
11313     Label* L = $labl$$label;
11314     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11315   %}
11316   ins_pipe(pipe_jcc);
11317   ins_short_branch(1);
11318 %}
11319 
11320 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
11321   match(If cop cmp);
11322   effect(USE labl);
11323 
11324   ins_cost(300);
11325   format %{ $$template
11326     if ($cop$$cmpcode == Assembler::notEqual) {
11327       $$emit$$"jp,u,s   $labl\n\t"
11328       $$emit$$"j$cop,u,s   $labl"
11329     } else {
11330       $$emit$$"jp,u,s   done\n\t"
11331       $$emit$$"j$cop,u,s  $labl\n\t"
11332       $$emit$$"done:"
11333     }
11334   %}
11335   size(4);
11336   ins_encode %{
11337     Label* l = $labl$$label;
11338     if ($cop$$cmpcode == Assembler::notEqual) {
11339       __ jccb(Assembler::parity, *l);
11340       __ jccb(Assembler::notEqual, *l);
11341     } else if ($cop$$cmpcode == Assembler::equal) {
11342       Label done;
11343       __ jccb(Assembler::parity, done);
11344       __ jccb(Assembler::equal, *l);
11345       __ bind(done);
11346     } else {
11347        ShouldNotReachHere();
11348     }
11349   %}
11350   ins_pipe(pipe_jcc);
11351   ins_short_branch(1);
11352 %}
11353 
11354 // ============================================================================
11355 // inlined locking and unlocking
11356 
11357 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
11358   predicate(Compile::current()-&gt;use_rtm());
11359   match(Set cr (FastLock object box));
11360   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
11361   ins_cost(300);
11362   format %{ "fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2" %}
11363   ins_encode %{
11364     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
11365                  $scr$$Register, $cx1$$Register, $cx2$$Register,
11366                  _counters, _rtm_counters, _stack_rtm_counters,
11367                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
11368                  true, ra_-&gt;C-&gt;profile_rtm());
11369   %}
11370   ins_pipe(pipe_slow);
11371 %}
11372 
11373 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{
11374   predicate(!Compile::current()-&gt;use_rtm());
11375   match(Set cr (FastLock object box));
11376   effect(TEMP tmp, TEMP scr, USE_KILL box);
11377   ins_cost(300);
11378   format %{ "fastlock $object,$box\t! kills $box,$tmp,$scr" %}
11379   ins_encode %{
11380     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
11381                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
11382   %}
11383   ins_pipe(pipe_slow);
11384 %}
11385 
11386 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
11387   match(Set cr (FastUnlock object box));
11388   effect(TEMP tmp, USE_KILL box);
11389   ins_cost(300);
11390   format %{ "fastunlock $object,$box\t! kills $box,$tmp" %}
11391   ins_encode %{
11392     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
11393   %}
11394   ins_pipe(pipe_slow);
11395 %}
11396 
11397 
11398 // ============================================================================
11399 // Safepoint Instructions
11400 instruct safePoint_poll(rFlagsReg cr)
11401 %{
11402   predicate(!Assembler::is_polling_page_far());
11403   match(SafePoint);
11404   effect(KILL cr);
11405 
11406   format %{ "testl  rax, [rip + #offset_to_poll_page]\t"
11407             "# Safepoint: poll for GC" %}
11408   ins_cost(125);
11409   ins_encode %{
11410     AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
11411     __ testl(rax, addr);
11412   %}
11413   ins_pipe(ialu_reg_mem);
11414 %}
11415 
11416 instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)
11417 %{
11418   predicate(Assembler::is_polling_page_far());
11419   match(SafePoint poll);
11420   effect(KILL cr, USE poll);
11421 
11422   format %{ "testl  rax, [$poll]\t"
11423             "# Safepoint: poll for GC" %}
11424   ins_cost(125);
11425   ins_encode %{
11426     __ relocate(relocInfo::poll_type);
11427     __ testl(rax, Address($poll$$Register, 0));
11428   %}
11429   ins_pipe(ialu_reg_mem);
11430 %}
11431 
11432 // ============================================================================
11433 // Procedure Call/Return Instructions
11434 // Call Java Static Instruction
11435 // Note: If this code changes, the corresponding ret_addr_offset() and
11436 //       compute_padding() functions will have to be adjusted.
11437 instruct CallStaticJavaDirect(method meth) %{
11438   match(CallStaticJava);
11439   predicate(!((CallStaticJavaNode*) n)-&gt;is_method_handle_invoke());
11440   effect(USE meth);
11441 
11442   ins_cost(300);
11443   format %{ "call,static " %}
11444   opcode(0xE8); /* E8 cd */
11445   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
11446   ins_pipe(pipe_slow);
11447   ins_alignment(4);
11448 %}
11449 
11450 // Call Java Static Instruction (method handle version)
11451 // Note: If this code changes, the corresponding ret_addr_offset() and
11452 //       compute_padding() functions will have to be adjusted.
11453 instruct CallStaticJavaHandle(method meth, rbp_RegP rbp_mh_SP_save) %{
11454   match(CallStaticJava);
11455   predicate(((CallStaticJavaNode*) n)-&gt;is_method_handle_invoke());
11456   effect(USE meth);
11457   // RBP is saved by all callees (for interpreter stack correction).
11458   // We use it here for a similar purpose, in {preserve,restore}_SP.
11459 
11460   ins_cost(300);
11461   format %{ "call,static/MethodHandle " %}
11462   opcode(0xE8); /* E8 cd */
11463   ins_encode(clear_avx, preserve_SP,
11464              Java_Static_Call(meth),
11465              restore_SP,
11466              call_epilog);
11467   ins_pipe(pipe_slow);
11468   ins_alignment(4);
11469 %}
11470 
11471 // Call Java Dynamic Instruction
11472 // Note: If this code changes, the corresponding ret_addr_offset() and
11473 //       compute_padding() functions will have to be adjusted.
11474 instruct CallDynamicJavaDirect(method meth)
11475 %{
11476   match(CallDynamicJava);
11477   effect(USE meth);
11478 
11479   ins_cost(300);
11480   format %{ "movq    rax, #Universe::non_oop_word()\n\t"
11481             "call,dynamic " %}
11482   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
11483   ins_pipe(pipe_slow);
11484   ins_alignment(4);
11485 %}
11486 
11487 // Call Runtime Instruction
11488 instruct CallRuntimeDirect(method meth)
11489 %{
11490   match(CallRuntime);
11491   effect(USE meth);
11492 
11493   ins_cost(300);
11494   format %{ "call,runtime " %}
11495   ins_encode(clear_avx, Java_To_Runtime(meth));
11496   ins_pipe(pipe_slow);
11497 %}
11498 
11499 // Call runtime without safepoint
11500 instruct CallLeafDirect(method meth)
11501 %{
11502   match(CallLeaf);
11503   effect(USE meth);
11504 
11505   ins_cost(300);
11506   format %{ "call_leaf,runtime " %}
11507   ins_encode(clear_avx, Java_To_Runtime(meth));
11508   ins_pipe(pipe_slow);
11509 %}
11510 
11511 // Call runtime without safepoint
11512 instruct CallLeafNoFPDirect(method meth)
11513 %{
11514   match(CallLeafNoFP);
11515   effect(USE meth);
11516 
11517   ins_cost(300);
11518   format %{ "call_leaf_nofp,runtime " %}
11519   ins_encode(Java_To_Runtime(meth));
11520   ins_pipe(pipe_slow);
11521 %}
11522 
11523 // Return Instruction
11524 // Remove the return address &amp; jump to it.
11525 // Notice: We always emit a nop after a ret to make sure there is room
11526 // for safepoint patching
11527 instruct Ret()
11528 %{
11529   match(Return);
11530 
11531   format %{ "ret" %}
11532   opcode(0xC3);
11533   ins_encode(OpcP);
11534   ins_pipe(pipe_jmp);
11535 %}
11536 
11537 // Tail Call; Jump from runtime stub to Java code.
11538 // Also known as an 'interprocedural jump'.
11539 // Target of jump will eventually return to caller.
11540 // TailJump below removes the return address.
11541 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
11542 %{
11543   match(TailCall jump_target method_oop);
11544 
11545   ins_cost(300);
11546   format %{ "jmp     $jump_target\t# rbx holds method oop" %}
11547   opcode(0xFF, 0x4); /* Opcode FF /4 */
11548   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
11549   ins_pipe(pipe_jmp);
11550 %}
11551 
11552 // Tail Jump; remove the return address; jump to target.
11553 // TailCall above leaves the return address around.
11554 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
11555 %{
11556   match(TailJump jump_target ex_oop);
11557 
11558   ins_cost(300);
11559   format %{ "popq    rdx\t# pop return address\n\t"
11560             "jmp     $jump_target" %}
11561   opcode(0xFF, 0x4); /* Opcode FF /4 */
11562   ins_encode(Opcode(0x5a), // popq rdx
11563              REX_reg(jump_target), OpcP, reg_opc(jump_target));
11564   ins_pipe(pipe_jmp);
11565 %}
11566 
11567 // Create exception oop: created by stack-crawling runtime code.
11568 // Created exception is now available to this handler, and is setup
11569 // just prior to jumping to this handler.  No code emitted.
11570 instruct CreateException(rax_RegP ex_oop)
11571 %{
11572   match(Set ex_oop (CreateEx));
11573 
11574   size(0);
11575   // use the following format syntax
11576   format %{ "# exception oop is in rax; no code emitted" %}
11577   ins_encode();
11578   ins_pipe(empty);
11579 %}
11580 
11581 // Rethrow exception:
11582 // The exception oop will come in the first argument position.
11583 // Then JUMP (not call) to the rethrow stub code.
11584 instruct RethrowException()
11585 %{
11586   match(Rethrow);
11587 
11588   // use the following format syntax
11589   format %{ "jmp     rethrow_stub" %}
11590   ins_encode(enc_rethrow);
11591   ins_pipe(pipe_jmp);
11592 %}
11593 
11594 
11595 // ============================================================================
11596 // This name is KNOWN by the ADLC and cannot be changed.
11597 // The ADLC forces a 'TypeRawPtr::BOTTOM' output type
11598 // for this guy.
11599 instruct tlsLoadP(r15_RegP dst) %{
11600   match(Set dst (ThreadLocal));
11601   effect(DEF dst);
11602 
11603   size(0);
11604   format %{ "# TLS is in R15" %}
11605   ins_encode( /*empty encoding*/ );
11606   ins_pipe(ialu_reg_reg);
11607 %}
11608 
11609 
11610 //----------PEEPHOLE RULES-----------------------------------------------------
11611 // These must follow all instruction definitions as they use the names
11612 // defined in the instructions definitions.
11613 //
11614 // peepmatch ( root_instr_name [preceding_instruction]* );
11615 //
11616 // peepconstraint %{
11617 // (instruction_number.operand_name relational_op instruction_number.operand_name
11618 //  [, ...] );
11619 // // instruction numbers are zero-based using left to right order in peepmatch
11620 //
11621 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
11622 // // provide an instruction_number.operand_name for each operand that appears
11623 // // in the replacement instruction's match rule
11624 //
11625 // ---------VM FLAGS---------------------------------------------------------
11626 //
11627 // All peephole optimizations can be turned off using -XX:-OptoPeephole
11628 //
11629 // Each peephole rule is given an identifying number starting with zero and
11630 // increasing by one in the order seen by the parser.  An individual peephole
11631 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
11632 // on the command-line.
11633 //
11634 // ---------CURRENT LIMITATIONS----------------------------------------------
11635 //
11636 // Only match adjacent instructions in same basic block
11637 // Only equality constraints
11638 // Only constraints between operands, not (0.dest_reg == RAX_enc)
11639 // Only one replacement instruction
11640 //
11641 // ---------EXAMPLE----------------------------------------------------------
11642 //
11643 // // pertinent parts of existing instructions in architecture description
11644 // instruct movI(rRegI dst, rRegI src)
11645 // %{
11646 //   match(Set dst (CopyI src));
11647 // %}
11648 //
11649 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
11650 // %{
11651 //   match(Set dst (AddI dst src));
11652 //   effect(KILL cr);
11653 // %}
11654 //
11655 // // Change (inc mov) to lea
11656 // peephole %{
11657 //   // increment preceeded by register-register move
11658 //   peepmatch ( incI_rReg movI );
11659 //   // require that the destination register of the increment
11660 //   // match the destination register of the move
11661 //   peepconstraint ( 0.dst == 1.dst );
11662 //   // construct a replacement instruction that sets
11663 //   // the destination to ( move's source register + one )
11664 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
11665 // %}
11666 //
11667 
11668 // Implementation no longer uses movX instructions since
11669 // machine-independent system no longer uses CopyX nodes.
11670 //
11671 // peephole
11672 // %{
11673 //   peepmatch (incI_rReg movI);
11674 //   peepconstraint (0.dst == 1.dst);
11675 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
11676 // %}
11677 
11678 // peephole
11679 // %{
11680 //   peepmatch (decI_rReg movI);
11681 //   peepconstraint (0.dst == 1.dst);
11682 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
11683 // %}
11684 
11685 // peephole
11686 // %{
11687 //   peepmatch (addI_rReg_imm movI);
11688 //   peepconstraint (0.dst == 1.dst);
11689 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
11690 // %}
11691 
11692 // peephole
11693 // %{
11694 //   peepmatch (incL_rReg movL);
11695 //   peepconstraint (0.dst == 1.dst);
11696 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
11697 // %}
11698 
11699 // peephole
11700 // %{
11701 //   peepmatch (decL_rReg movL);
11702 //   peepconstraint (0.dst == 1.dst);
11703 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
11704 // %}
11705 
11706 // peephole
11707 // %{
11708 //   peepmatch (addL_rReg_imm movL);
11709 //   peepconstraint (0.dst == 1.dst);
11710 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
11711 // %}
11712 
11713 // peephole
11714 // %{
11715 //   peepmatch (addP_rReg_imm movP);
11716 //   peepconstraint (0.dst == 1.dst);
11717 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
11718 // %}
11719 
11720 // // Change load of spilled value to only a spill
11721 // instruct storeI(memory mem, rRegI src)
11722 // %{
11723 //   match(Set mem (StoreI mem src));
11724 // %}
11725 //
11726 // instruct loadI(rRegI dst, memory mem)
11727 // %{
11728 //   match(Set dst (LoadI mem));
11729 // %}
11730 //
11731 
11732 peephole
11733 %{
11734   peepmatch (loadI storeI);
11735   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
11736   peepreplace (storeI(1.mem 1.mem 1.src));
11737 %}
11738 
11739 peephole
11740 %{
11741   peepmatch (loadL storeL);
11742   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
11743   peepreplace (storeL(1.mem 1.mem 1.src));
11744 %}
11745 
11746 //----------SMARTSPILL RULES---------------------------------------------------
11747 // These must follow all instruction definitions as they use the names
11748 // defined in the instructions definitions.
</pre></body></html>
